diff --git a/g2o/core/CMakeLists.txt b/g2o/core/CMakeLists.txt
deleted file mode 100644
index 9cd13f06..00000000
--- a/g2o/core/CMakeLists.txt
+++ /dev/null
@@ -1,60 +0,0 @@
-add_library(core ${G2O_LIB_TYPE}
-dynamic_aligned_buffer.hpp
-ownership.h
-base_edge.h
-base_binary_edge.h          hyper_graph_action.cpp
-base_binary_edge.hpp        hyper_graph_action.h
-base_multi_edge.h           hyper_graph.cpp
-base_multi_edge.hpp         hyper_graph.h
-base_unary_edge.h           linear_solver.h
-base_unary_edge.hpp         marginal_covariance_cholesky.cpp
-base_vertex.h               marginal_covariance_cholesky.h
-base_vertex.hpp             matrix_structure.cpp
-batch_stats.cpp             matrix_structure.h
-batch_stats.h               openmp_mutex.h
-block_solver.h              block_solver.hpp
-parameter.cpp               parameter.h
-cache.cpp                   cache.h
-optimizable_graph.cpp       optimizable_graph.h
-solver.cpp                  solver.h
-creators.h                  optimization_algorithm_factory.cpp
-estimate_propagator.cpp     optimization_algorithm_factory.h
-estimate_propagator.h
-factory.cpp                 optimization_algorithm_property.h
-factory.h                   sparse_block_matrix.h
-sparse_optimizer.cpp  sparse_block_matrix.hpp
-sparse_optimizer.h
-hyper_dijkstra.cpp hyper_dijkstra.h
-parameter_container.cpp     parameter_container.h
-optimization_algorithm.cpp optimization_algorithm.h
-optimization_algorithm_with_hessian.cpp optimization_algorithm_with_hessian.h
-optimization_algorithm_gauss_newton.cpp optimization_algorithm_gauss_newton.h
-optimization_algorithm_levenberg.cpp optimization_algorithm_levenberg.h
-optimization_algorithm_dogleg.cpp optimization_algorithm_dogleg.h
-sparse_optimizer_terminate_action.cpp sparse_optimizer_terminate_action.h
-jacobian_workspace.cpp jacobian_workspace.h
-robust_kernel.cpp robust_kernel.h
-robust_kernel_impl.cpp robust_kernel_impl.h
-robust_kernel_factory.cpp robust_kernel_factory.h
-io_helper.h
-g2o_core_api.h
-)
-
-set_target_properties(core PROPERTIES OUTPUT_NAME ${LIB_PREFIX}core)
-target_link_libraries(core PUBLIC stuff ${G2O_EIGEN3_EIGEN_TARGET})
-
-if (APPLE)
-  set_target_properties(core PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-install(TARGETS core
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/core)
diff --git a/g2o/core/base_binary_edge.h b/g2o/core/base_binary_edge.h
index 0aef5f9a..cc769b52 100644
--- a/g2o/core/base_binary_edge.h
+++ b/g2o/core/base_binary_edge.h
@@ -33,8 +33,6 @@
 #include "base_edge.h"
 #include "robust_kernel.h"
 #include "g2o/config.h"
-#include "g2o/stuff/misc.h"
-#include "dynamic_aligned_buffer.hpp"
 
 namespace g2o {
 
@@ -51,15 +49,13 @@ namespace g2o {
 
       static const int Dimension = BaseEdge<D, E>::Dimension;
       typedef typename BaseEdge<D,E>::Measurement Measurement;
-      typedef typename Eigen::Matrix<number_t, D, Di, D==1?Eigen::RowMajor:Eigen::ColMajor>::AlignedMapType JacobianXiOplusType;
-      typedef typename Eigen::Matrix<number_t, D, Dj, D==1?Eigen::RowMajor:Eigen::ColMajor>::AlignedMapType JacobianXjOplusType;
+      typedef typename Eigen::Matrix<double, D, Di>::AlignedMapType JacobianXiOplusType;
+      typedef typename Eigen::Matrix<double, D, Dj>::AlignedMapType JacobianXjOplusType;
       typedef typename BaseEdge<D,E>::ErrorVector ErrorVector;
       typedef typename BaseEdge<D,E>::InformationType InformationType;
 
-      typedef Eigen::Map<Eigen::Matrix<number_t, Di, Dj, Di==1?Eigen::RowMajor:Eigen::ColMajor>,
-                         Eigen::Matrix<number_t, Di, Dj, Di==1?Eigen::RowMajor:Eigen::ColMajor>::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockType;
-      typedef Eigen::Map<Eigen::Matrix<number_t, Dj, Di, Dj==1?Eigen::RowMajor:Eigen::ColMajor>,
-                         Eigen::Matrix<number_t, Dj, Di, Dj==1?Eigen::RowMajor:Eigen::ColMajor>::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockTransposedType;
+      typedef Eigen::Map<Eigen::Matrix<double, Di, Dj>, Eigen::Matrix<double, Di, Dj>::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockType;
+      typedef Eigen::Map<Eigen::Matrix<double, Dj, Di>, Eigen::Matrix<double, Dj, Di>::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockTransposedType;
 
       BaseBinaryEdge() : BaseEdge<D,E>(),
       _hessianRowMajor(false),
@@ -67,33 +63,32 @@ namespace g2o {
       _hessianTransposed(0, VertexXjType::Dimension, VertexXiType::Dimension),
       _jacobianOplusXi(0, D, Di), _jacobianOplusXj(0, D, Dj)
       {
-        _vertices.resize(2, nullptr);
+        _vertices.resize(2);
       }
 
-      inline virtual OptimizableGraph::Vertex* createFrom();
-      inline virtual OptimizableGraph::Vertex* createTo();
-      inline virtual OptimizableGraph::Vertex* createVertex(int i);
+      virtual OptimizableGraph::Vertex* createFrom();
+      virtual OptimizableGraph::Vertex* createTo();
 
-      inline virtual void resize(size_t size);
+      virtual void resize(size_t size);
 
-      inline virtual bool allVerticesFixed() const;
+      virtual bool allVerticesFixed() const;
 
-      inline virtual void linearizeOplus(JacobianWorkspace& jacobianWorkspace);
+      virtual void linearizeOplus(JacobianWorkspace& jacobianWorkspace);
 
       /**
        * Linearizes the oplus operator in the vertex, and stores
        * the result in temporary variables _jacobianOplusXi and _jacobianOplusXj
        */
-      inline virtual void linearizeOplus();
+      virtual void linearizeOplus();
 
       //! returns the result of the linearization in the manifold space for the node xi
       const JacobianXiOplusType& jacobianOplusXi() const { return _jacobianOplusXi;}
       //! returns the result of the linearization in the manifold space for the node xj
       const JacobianXjOplusType& jacobianOplusXj() const { return _jacobianOplusXj;}
 
-      inline virtual void constructQuadraticForm() ;
+      virtual void constructQuadraticForm() ;
 
-      inline virtual void mapHessianMemory(number_t* d, int i, int j, bool rowMajor);
+      virtual void mapHessianMemory(double* d, int i, int j, bool rowMajor);
 
       using BaseEdge<D,E>::resize;
       using BaseEdge<D,E>::computeError;
@@ -112,7 +107,7 @@ namespace g2o {
       JacobianXjOplusType _jacobianOplusXj;
 
     public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+      
   };
 
 #include "base_binary_edge.hpp"
diff --git a/g2o/core/base_binary_edge.hpp b/g2o/core/base_binary_edge.hpp
index e6984f42..e28453b2 100644
--- a/g2o/core/base_binary_edge.hpp
+++ b/g2o/core/base_binary_edge.hpp
@@ -24,32 +24,23 @@
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#define G2O_VERTEX_I_DIM ((VertexXiType::Dimension < 0) ? static_cast<const VertexXiType*> (_vertices[0])->dimension() : VertexXiType::Dimension)
-#define G2O_VERTEX_J_DIM ((VertexXjType::Dimension < 0) ? static_cast<const VertexXjType*> (_vertices[1])->dimension() : VertexXjType::Dimension)
-
 template <int D, typename E, typename VertexXiType, typename VertexXjType>
 OptimizableGraph::Vertex* BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::createFrom(){
-  return createVertex(0);
+  return new VertexXiType();
 }
 
 template <int D, typename E, typename VertexXiType, typename VertexXjType>
 OptimizableGraph::Vertex* BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::createTo(){
-  return createVertex(1);
+  return new VertexXjType();
 }
 
-template <int D, typename E, typename VertexXiType, typename VertexXjType>
-OptimizableGraph::Vertex* BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::createVertex(int i){
-  switch(i) {
-  case 0: return new VertexXiType();
-  case 1: return new VertexXjType();
-  default: return nullptr;
-  }
-}
 
 template <int D, typename E, typename VertexXiType, typename VertexXjType>
 void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::resize(size_t size)
 {
-  assert(size == 2 && "attempting to resize a binary edge");
+  if (size != 2) {
+    std::cerr << "WARNING, attempting to resize binary edge " << BaseEdge<D, E>::id() << " to " << size << std::endl;
+  }
   BaseEdge<D, E>::resize(size);
 }
 
@@ -75,19 +66,17 @@ void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::constructQuadraticForm()
   bool toNotFixed = !(to->fixed());
 
   if (fromNotFixed || toNotFixed) {
+#ifdef G2O_OPENMP
+    from->lockQuadraticForm();
+    to->lockQuadraticForm();
+#endif
     const InformationType& omega = _information;
-    Eigen::Matrix<number_t, D, 1, Eigen::ColMajor> omega_r = - omega * _error;
+    Eigen::Matrix<double, D, 1> omega_r = - omega * _error;
     if (this->robustKernel() == 0) {
       if (fromNotFixed) {
-        Eigen::Matrix<number_t, VertexXiType::Dimension, D, Eigen::ColMajor> AtO = A.transpose() * omega;
-
-        {
-          internal::QuadraticFormLock lck(*from);
-
-          from->b().noalias() += A.transpose() * omega_r;
-          from->A().noalias() += AtO*A;
-        }
-
+        Eigen::Matrix<double, VertexXiType::Dimension, D> AtO = A.transpose() * omega;
+        from->b().noalias() += A.transpose() * omega_r;
+        from->A().noalias() += AtO*A;
         if (toNotFixed ) {
           if (_hessianRowMajor) // we have to write to the block as transposed
             _hessianTransposed.noalias() += B.transpose() * AtO.transpose();
@@ -96,14 +85,12 @@ void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::constructQuadraticForm()
         }
       } 
       if (toNotFixed) {
-        internal::QuadraticFormLock lck(*to);
-
         to->b().noalias() += B.transpose() * omega_r;
         to->A().noalias() += B.transpose() * omega * B;
       }
     } else { // robust (weighted) error according to some kernel
-      number_t error = this->chi2();
-      Vector3 rho;
+      double error = this->chi2();
+      Eigen::Vector3d rho;
       this->robustKernel()->robustify(error, rho);
       InformationType weightedOmega = this->robustInformation(rho);
       //std::cout << PVAR(rho.transpose()) << std::endl;
@@ -111,13 +98,8 @@ void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::constructQuadraticForm()
 
       omega_r *= rho[1];
       if (fromNotFixed) {
-        {
-          internal::QuadraticFormLock lck(*from);
-
-          from->b().noalias() += A.transpose() * omega_r;
-          from->A().noalias() += A.transpose() * weightedOmega * A;
-        }
-
+        from->b().noalias() += A.transpose() * omega_r;
+        from->A().noalias() += A.transpose() * weightedOmega * A;
         if (toNotFixed ) {
           if (_hessianRowMajor) // we have to write to the block as transposed
             _hessianTransposed.noalias() += B.transpose() * weightedOmega * A;
@@ -126,20 +108,22 @@ void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::constructQuadraticForm()
         }
       } 
       if (toNotFixed) {
-        internal::QuadraticFormLock lck(*to);
-
         to->b().noalias() += B.transpose() * omega_r;
         to->A().noalias() += B.transpose() * weightedOmega * B;
       }
     }
+#ifdef G2O_OPENMP
+    to->unlockQuadraticForm();
+    from->unlockQuadraticForm();
+#endif
   }
 }
 
 template <int D, typename E, typename VertexXiType, typename VertexXjType>
 void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::linearizeOplus(JacobianWorkspace& jacobianWorkspace)
 {
-  new (&_jacobianOplusXi) JacobianXiOplusType(jacobianWorkspace.workspaceForVertex(0), D < 0 ? _dimension : D, G2O_VERTEX_I_DIM);
-  new (&_jacobianOplusXj) JacobianXjOplusType(jacobianWorkspace.workspaceForVertex(1), D < 0 ? _dimension : D, G2O_VERTEX_J_DIM);
+  new (&_jacobianOplusXi) JacobianXiOplusType(jacobianWorkspace.workspaceForVertex(0), D, Di);
+  new (&_jacobianOplusXj) JacobianXjOplusType(jacobianWorkspace.workspaceForVertex(1), D, Dj);
   linearizeOplus();
 }
 
@@ -155,140 +139,80 @@ void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::linearizeOplus()
   if (!iNotFixed && !jNotFixed)
     return;
 
-  const number_t delta = cst(1e-9);
-  const number_t scalar = 1 / (2*delta);
+#ifdef G2O_OPENMP
+  vi->lockQuadraticForm();
+  vj->lockQuadraticForm();
+#endif
+
+  const double delta = 1e-9;
+  const double scalar = 1.0 / (2*delta);
   ErrorVector errorBak;
   ErrorVector errorBeforeNumeric = _error;
 
-  // A statically allocated array is far and away the most efficient
-  // way to construct the perturbation vector for the Jacobian. If the
-  // dimension is known at compile time, use directly. If the
-  // dimension is known at run time and is less than 12, use an
-  // allocated array of up to 12. Otherwise, use a fallback of a
-  // dynamically allocated array. The value of 12 is used because
-  // most vertices have a dimension significantly smaller than this.
-  
   if (iNotFixed) {
-    internal::QuadraticFormLock lck(*vi);
     //Xi - estimate the jacobian numerically
-
-    const int vi_dim = G2O_VERTEX_I_DIM;
-    
-    if ((VertexXiType::Dimension >= 0) || (vi_dim <= 12)) {
-	number_t add_vi[(VertexXiType::Dimension >= 0) ? VertexXiType::Dimension : 12] = {};
-        
-        // add small step along the unit vector in each dimension
-        for (int d = 0; d < vi_dim; ++d) {
-          vi->push();
-          add_vi[d] = delta;
-          vi->oplus(add_vi);
-          computeError();
-          errorBak = _error;
-          vi->pop();
-          vi->push();
-          add_vi[d] = -delta;
-          vi->oplus(add_vi);
-          computeError();
-          errorBak -= _error;
-          vi->pop();
-          add_vi[d] = 0.0;          
-          _jacobianOplusXi.col(d) = scalar * errorBak;
-        } // end dimension
-      }
-    else {
-	dynamic_aligned_buffer<number_t> buffer{ size_t(vi_dim) };
-        number_t* add_vi = buffer.request(vi_dim);
-        std::fill(add_vi, add_vi + vi_dim, cst(0.0));
-
-        // add small step along the unit vector in each dimension
-        for (int d = 0; d < vi_dim; ++d) {
-          vi->push();
-          add_vi[d] = delta;
-          vi->oplus(add_vi);
-          computeError();
-          errorBak = _error;
-          vi->pop();
-          vi->push();
-          add_vi[d] = - delta;
-          vi->oplus(add_vi);
-          computeError();
-          errorBak -= _error;
-          vi->pop();
-          add_vi[d] = 0;
-          _jacobianOplusXi.col(d) = scalar * errorBak;
-        } // end dimension
-      }
+    double add_vi[VertexXiType::Dimension];
+    std::fill(add_vi, add_vi + VertexXiType::Dimension, 0.0);
+    // add small step along the unit vector in each dimension
+    for (int d = 0; d < VertexXiType::Dimension; ++d) {
+      vi->push();
+      add_vi[d] = delta;
+      vi->oplus(add_vi);
+      computeError();
+      errorBak = _error;
+      vi->pop();
+      vi->push();
+      add_vi[d] = -delta;
+      vi->oplus(add_vi);
+      computeError();
+      errorBak -= _error;
+      vi->pop();
+      add_vi[d] = 0.0;
+
+      _jacobianOplusXi.col(d) = scalar * errorBak;
+    } // end dimension
   }
 
   if (jNotFixed) {
-    internal::QuadraticFormLock lck(*vj);
     //Xj - estimate the jacobian numerically
+    double add_vj[VertexXjType::Dimension];
+    std::fill(add_vj, add_vj + VertexXjType::Dimension, 0.0);
+    // add small step along the unit vector in each dimension
+    for (int d = 0; d < VertexXjType::Dimension; ++d) {
+      vj->push();
+      add_vj[d] = delta;
+      vj->oplus(add_vj);
+      computeError();
+      errorBak = _error;
+      vj->pop();
+      vj->push();
+      add_vj[d] = -delta;
+      vj->oplus(add_vj);
+      computeError();
+      errorBak -= _error;
+      vj->pop();
+      add_vj[d] = 0.0;
+
+      _jacobianOplusXj.col(d) = scalar * errorBak;
+    }
+  } // end dimension
 
-    const int vj_dim = G2O_VERTEX_J_DIM;
-    
-    if ((VertexXjType::Dimension >= 0) || (vj_dim <= 12)) {
-        number_t add_vj[(VertexXjType::Dimension >= 0) ? VertexXjType::Dimension : 12] = {};
-
-        // add small step along the unit vector in each dimension
-        for (int d = 0; d < vj_dim; ++d) {
-          vj->push();
-          add_vj[d] = delta;
-          vj->oplus(add_vj);
-          computeError();
-          errorBak = _error;
-          vj->pop();
-          vj->push();
-          add_vj[d] = -delta;
-          vj->oplus(add_vj);
-          computeError();
-          errorBak -= _error;
-          vj->pop();
-          add_vj[d] = 0.0;
-          
-          _jacobianOplusXj.col(d) = scalar * errorBak;
-        } // end dimension
-      }
-    else {
-        const int vj_dim = vj->dimension();
-        dynamic_aligned_buffer<number_t> buffer{ size_t(vj_dim) };
-        number_t* add_vj = buffer.request(vj_dim);
-        std::fill(add_vj, add_vj + vj_dim, cst(0.0));
-        
-        // add small step along the unit vector in each dimension
-        for (int d = 0; d < vj_dim; ++d) {
-          vj->push();
-          add_vj[d] = delta;
-          vj->oplus(add_vj);
-          computeError();
-          errorBak = _error;
-          vj->pop();
-          vj->push();
-          add_vj[d] = - delta;
-          vj->oplus(add_vj);
-          computeError();
-          errorBak -= _error;
-          vj->pop();
-          add_vj[d] = 0;
-          _jacobianOplusXj.col(d) = scalar * errorBak;
-        } // end dimension
-      }
-  }
   _error = errorBeforeNumeric;
+#ifdef G2O_OPENMP
+  vj->unlockQuadraticForm();
+  vi->unlockQuadraticForm();
+#endif
 }
 
 template <int D, typename E, typename VertexXiType, typename VertexXjType>
-void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::mapHessianMemory(number_t* d, int i, int j, bool rowMajor)
+void BaseBinaryEdge<D, E, VertexXiType, VertexXjType>::mapHessianMemory(double* d, int i, int j, bool rowMajor)
 {
   (void) i; (void) j;
   //assert(i == 0 && j == 1);
   if (rowMajor) {
-    new (&_hessianTransposed) HessianBlockTransposedType(d, G2O_VERTEX_J_DIM, G2O_VERTEX_I_DIM);
+    new (&_hessianTransposed) HessianBlockTransposedType(d, VertexXjType::Dimension, VertexXiType::Dimension);
   } else {
-    new (&_hessian) HessianBlockType(d, G2O_VERTEX_I_DIM, G2O_VERTEX_J_DIM);
+    new (&_hessian) HessianBlockType(d, VertexXiType::Dimension, VertexXjType::Dimension);
   }
   _hessianRowMajor = rowMajor;
 }
-
-#undef G2O_VERTEX_I_DIM
-#undef G2O_VERTEX_J_DIM
-
diff --git a/g2o/core/base_dynamic_vertex.h b/g2o/core/base_dynamic_vertex.h
deleted file mode 100644
index 97ea7d70..00000000
--- a/g2o/core/base_dynamic_vertex.h
+++ /dev/null
@@ -1,92 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_BASE_DYNAMIC_VERTEX_H
-#define G2O_BASE_DYNAMIC_VERTEX_H
-
-#include "base_vertex.h"
-
-namespace g2o {
-  template <typename T>
-    class BaseDynamicVertex : public BaseVertex<-1, T>
-    {
-    public:
-      
-      inline virtual bool setDimension(int newDimension);
-    
-    protected:
-      
-      // This method is responsible for actually changing the dimension of the state
-      virtual bool setDimensionImpl(int newDimension) = 0;
-
-      using BaseVertex<-1, T>::_graph;
-      using BaseVertex<-1, T>::_dimension;
-      using BaseVertex<-1, T>::_b;
-      using BaseVertex<-1, T>::_edges;
-      using BaseVertex<-1, T>::setHessianIndex;
-      using BaseVertex<-1, T>::mapHessianMemory;
-      using BaseVertex<-1, T>::updateCache;
-      
-    };
-
-  template <typename T>
-    bool BaseDynamicVertex<T>::setDimension(int newDimension) {
-  // Check the dimension is non-negative.
-  assert(newDimension >= 0);
-  if (newDimension < 0)
-    return false;
-
-  // Nothing to do if the dimension is unchanged.
-  if (newDimension == _dimension)
-    return true;
-
-  // Change the state to the requested dimension
-  if (setDimensionImpl(newDimension) == false)
-    return false;
-
-  // Store the old dimension and assign the new
-  int oldDimension = _dimension;
-  _dimension = newDimension;
-
-  // Reset the allocation associated with this vertex and update the cache
-  setHessianIndex(-1);
-  mapHessianMemory(nullptr);
-  _b.resize(_dimension);
-  updateCache();
-
-  // If the dimension is being increased and this vertex is in a
-  // graph, update the size of the Jacobian workspace just in case it
-  // needs to grow.
-  if ((newDimension > oldDimension) && (_graph != nullptr)) {
-      JacobianWorkspace& jacobianWorkspace = _graph->jacobianWorkspace();
-      for (auto e : _edges)
-        jacobianWorkspace.updateSize(e);
-    }
-
-  return true;
- }
-}
-#endif
diff --git a/g2o/core/base_edge.h b/g2o/core/base_edge.h
index e4c259e4..89489a02 100644
--- a/g2o/core/base_edge.h
+++ b/g2o/core/base_edge.h
@@ -29,7 +29,6 @@
 
 #include <iostream>
 #include <limits>
-#include <type_traits>
 
 #include <Eigen/Core>
 
@@ -37,52 +36,16 @@
 
 namespace g2o {
 
-  namespace internal {
-
-  #ifdef G2O_OPENMP
-    struct QuadraticFormLock {
-      explicit QuadraticFormLock(OptimizableGraph::Vertex& vertex)
-        :_vertex(vertex) {
-          _vertex.lockQuadraticForm();
-        }
-      ~QuadraticFormLock() {
-        _vertex.unlockQuadraticForm();
-      }
-      private:
-      OptimizableGraph::Vertex& _vertex;
-    };
-  #else
-    struct QuadraticFormLock {
-      explicit QuadraticFormLock(OptimizableGraph::Vertex& ) { }
-      ~QuadraticFormLock() { }
-    };
-  #endif
-
-    template <int D>
-    struct BaseEdgeTraits {
-      static constexpr int Dimension = D;
-      typedef Eigen::Matrix<number_t, D, 1, Eigen::ColMajor> ErrorVector;
-      typedef Eigen::Matrix<number_t, D, D, Eigen::ColMajor> InformationType;
-    };
-
-    template <>
-    struct BaseEdgeTraits<-1> {
-      static constexpr int Dimension = -1;
-      typedef Eigen::Matrix<number_t, Eigen::Dynamic, 1, Eigen::ColMajor> ErrorVector;
-      typedef Eigen::Matrix<number_t, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor> InformationType;
-    };
-
-  } // internal namespace
 
   template <int D, typename E>
   class BaseEdge : public OptimizableGraph::Edge
   {
     public:
 
-      static constexpr int Dimension = internal::BaseEdgeTraits<D>::Dimension;
+      static const int Dimension = D;
       typedef E Measurement;
-      typedef typename internal::BaseEdgeTraits<D>::ErrorVector ErrorVector;
-      typedef typename internal::BaseEdgeTraits<D>::InformationType InformationType;
+      typedef Eigen::Matrix<double, D, 1> ErrorVector;
+      typedef Eigen::Matrix<double, D, D> InformationType;
 
       BaseEdge() : OptimizableGraph::Edge()
       {
@@ -91,26 +54,26 @@ namespace g2o {
 
       virtual ~BaseEdge() {}
 
-      virtual number_t chi2() const
+      virtual double chi2() const 
       {
         return _error.dot(information()*_error);
       }
 
-      virtual const number_t* errorData() const { return _error.data();}
-      virtual number_t* errorData() { return _error.data();}
+      virtual const double* errorData() const { return _error.data();}
+      virtual double* errorData() { return _error.data();}
       const ErrorVector& error() const { return _error;}
       ErrorVector& error() { return _error;}
 
       //! information matrix of the constraint
-      EIGEN_STRONG_INLINE const InformationType& information() const { return _information;}
-      EIGEN_STRONG_INLINE InformationType& information() { return _information;}
-      EIGEN_STRONG_INLINE void setInformation(const InformationType& information) { _information = information;}
+      const InformationType& information() const { return _information;}
+      InformationType& information() { return _information;}
+      void setInformation(const InformationType& information) { _information = information;}
 
-      virtual const number_t* informationData() const { return _information.data();}
-      virtual number_t* informationData() { return _information.data();}
+      virtual const double* informationData() const { return _information.data();}
+      virtual double* informationData() { return _information.data();}
 
       //! accessor functions for the measurement represented by the edge
-      EIGEN_STRONG_INLINE const Measurement& measurement() const { return _measurement;}
+      const Measurement& measurement() const { return _measurement;}
       virtual void setMeasurement(const Measurement& m) { _measurement = m;}
 
       virtual int rank() const {return _dimension;}
@@ -120,17 +83,6 @@ namespace g2o {
         std::cerr << "inititialEstimate() is not implemented, please give implementation in your derived class" << std::endl;
       }
 
-      /**
-       * set the dimension for a dynamically sizeable error function.
-       * The member will not be declared for edges having a fixed size at compile time.
-       */
-      template <int Dim = D>
-      typename std::enable_if<Dim == -1, void>::type setDimension(int dim) {
-        _dimension = dim;
-        _information.resize(dim, dim);
-        _error.resize(dim, 1);
-      }
-
     protected:
 
       Measurement _measurement;
@@ -140,7 +92,7 @@ namespace g2o {
       /**
        * calculate the robust information matrix by updating the information matrix of the error
        */
-      InformationType robustInformation(const Vector3& rho) const
+      InformationType robustInformation(const Eigen::Vector3d& rho)
       {
         InformationType result = rho[1] * _information;
         //ErrorVector weightedErrror = _information * _error;
@@ -148,37 +100,8 @@ namespace g2o {
         return result;
       }
 
-      bool writeInformationMatrix(std::ostream& os) const {
-        for (int i = 0; i < information().rows(); ++i)
-          for (int j = i; j < information().cols(); ++j) os << information()(i, j) << " ";
-        return os.good();
-      }
-
-      bool readInformationMatrix(std::istream& is) {
-        for (int i = 0; i < information().rows() && is.good(); ++i)
-          for (int j = i; j < information().cols() && is.good(); ++j) {
-            is >> information()(i, j);
-            if (i != j) information()(j, i) = information()(i, j);
-          }
-        return is.good() || is.eof();
-      }
-
-      bool writeParamIds(std::ostream& os) const {
-        for (auto id : _parameterIds) os << id << " ";
-        return os.good();
-      }
-
-      bool readParamIds(std::istream& is) {
-        for (size_t i = 0; i < numParameters(); ++i) {
-          int paramId;
-          is >> paramId;
-          setParameterId(i, paramId);
-        }
-        return is.good() || is.eof();
-      }
-
     public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+      
   };
 
 } // end namespace g2o
diff --git a/g2o/core/base_multi_edge.h b/g2o/core/base_multi_edge.h
index 6992a716..ade08b1f 100644
--- a/g2o/core/base_multi_edge.h
+++ b/g2o/core/base_multi_edge.h
@@ -31,14 +31,15 @@
 #include <iomanip>
 #include <limits>
 
+#include <Eigen/StdVector>
+
 #include "base_edge.h"
 #include "robust_kernel.h"
 #include "g2o/config.h"
-#include "g2o/stuff/misc.h"
-#include "dynamic_aligned_buffer.hpp"
 
 namespace g2o {
 
+
   /**
    * \brief base class to represent an edge connecting an arbitrary number of nodes
    *
@@ -46,14 +47,14 @@ namespace g2o {
    * E - type to represent the measurement
    */
   template <int D, typename E>
-    class BaseMultiEdge : public BaseEdge<D,E>
-    {
+  class BaseMultiEdge : public BaseEdge<D,E>
+  {
     public:
       /**
        * \brief helper for mapping the Hessian memory of the upper triangular block
        */
       struct HessianHelper {
-        Eigen::Map<MatrixX> matrix;     ///< the mapped memory
+        Eigen::Map<Eigen::MatrixXd> matrix;     ///< the mapped memory
         bool transposed;          ///< the block has to be transposed
         HessianHelper() : matrix(0, 0, 0), transposed(false) {}
       };
@@ -61,10 +62,10 @@ namespace g2o {
     public:
       static const int Dimension = BaseEdge<D,E>::Dimension;
       typedef typename BaseEdge<D,E>::Measurement Measurement;
-      typedef MatrixX::MapType JacobianType;
+      typedef Eigen::MatrixXd::MapType JacobianType;
       typedef typename BaseEdge<D,E>::ErrorVector ErrorVector;
       typedef typename BaseEdge<D,E>::InformationType InformationType;
-      typedef Eigen::Map<MatrixX, MatrixX::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockType;
+      typedef Eigen::Map<Eigen::MatrixXd, Eigen::MatrixXd::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockType;
 
       BaseMultiEdge() : BaseEdge<D,E>()
       {
@@ -84,7 +85,7 @@ namespace g2o {
 
       virtual void constructQuadraticForm() ;
 
-      virtual void mapHessianMemory(number_t* d, int i, int j, bool rowMajor);
+      virtual void mapHessianMemory(double* d, int i, int j, bool rowMajor);
 
       using BaseEdge<D,E>::computeError;
 
@@ -101,72 +102,8 @@ namespace g2o {
       void computeQuadraticForm(const InformationType& omega, const ErrorVector& weightedError);
 
     public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    };
-
-
-
-  // PARTIAL TEMPLATE SPECIALIZATION
-  template <typename E>
-  class BaseMultiEdge<-1,E> : public BaseEdge<-1,E>
-  {
-    public:
-      /**
-       * \brief helper for mapping the Hessian memory of the upper triangular block
-       */
-      struct HessianHelper {
-        Eigen::Map<MatrixX> matrix;     ///< the mapped memory
-        bool transposed;          ///< the block has to be transposed
-        HessianHelper() : matrix(0, 0, 0), transposed(false) {}
-      };
-
-    public:
-      static const int Dimension = BaseEdge<-1,E>::Dimension;
-      typedef typename BaseEdge<-1,E>::Measurement Measurement;
-      typedef MatrixX::MapType JacobianType;
-      typedef typename BaseEdge<-1,E>::ErrorVector ErrorVector;
-      typedef typename BaseEdge<-1,E>::InformationType InformationType;
-      typedef Eigen::Map<MatrixX, MatrixX::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned > HessianBlockType;
-
-      BaseMultiEdge() : BaseEdge<-1,E>()
-    {
-      // this->_variableSize = true;
-    }
-
-      virtual void linearizeOplus(JacobianWorkspace& jacobianWorkspace);
-
-      /**
-       * Linearizes the oplus operator in the vertex, and stores
-       * the result in temporary variable vector _jacobianOplus
-       */
-      virtual void linearizeOplus();
-
-      virtual void resize(size_t size);
-
-      virtual bool allVerticesFixed() const;
-
-      virtual void constructQuadraticForm() ;
-
-      virtual void mapHessianMemory(number_t* d, int i, int j, bool rowMajor);
-
-      using BaseEdge<-1,E>::computeError;
-
-    protected:
-      using BaseEdge<-1,E>::_measurement;
-      using BaseEdge<-1,E>::_information;
-      using BaseEdge<-1,E>::_error;
-      using BaseEdge<-1,E>::_vertices;
-      using BaseEdge<-1,E>::_dimension;
-
-      std::vector<HessianHelper> _hessian;
-      std::vector<JacobianType, Eigen::aligned_allocator<JacobianType> > _jacobianOplus; ///< jacobians of the edge (w.r.t. oplus)
-
-      void computeQuadraticForm(const InformationType& omega, const ErrorVector& weightedError);
-
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    };
       
+  };
 
 #include "base_multi_edge.hpp"
 
diff --git a/g2o/core/base_multi_edge.hpp b/g2o/core/base_multi_edge.hpp
index d1967adc..2696d2f6 100644
--- a/g2o/core/base_multi_edge.hpp
+++ b/g2o/core/base_multi_edge.hpp
@@ -36,10 +36,10 @@ template <int D, typename E>
 void BaseMultiEdge<D, E>::constructQuadraticForm()
 {
   if (this->robustKernel()) {
-    number_t error = this->chi2();
-    Vector3 rho;
+    double error = this->chi2();
+    Eigen::Vector3d rho;
     this->robustKernel()->robustify(error, rho);
-    Eigen::Matrix<number_t, D, 1, Eigen::ColMajor> omega_r = - _information * _error;
+    Eigen::Matrix<double, D, 1> omega_r = - _information * _error;
     omega_r *= rho[1];
     computeQuadraticForm(this->robustInformation(rho), omega_r);
   } else {
@@ -54,7 +54,7 @@ void BaseMultiEdge<D, E>::linearizeOplus(JacobianWorkspace& jacobianWorkspace)
   for (size_t i = 0; i < _vertices.size(); ++i) {
     OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
     assert(v->dimension() >= 0);
-    new (&_jacobianOplus[i]) JacobianType(jacobianWorkspace.workspaceForVertex(i), D < 0 ? _dimension : D, v->dimension());
+    new (&_jacobianOplus[i]) JacobianType(jacobianWorkspace.workspaceForVertex(i), D, v->dimension());
   }
   linearizeOplus();
 }
@@ -62,85 +62,71 @@ void BaseMultiEdge<D, E>::linearizeOplus(JacobianWorkspace& jacobianWorkspace)
 template <int D, typename E>
 void BaseMultiEdge<D, E>::linearizeOplus()
 {
-  const number_t delta = cst(1e-9);
-  const number_t scalar = 1 / (2*delta);
+#ifdef G2O_OPENMP
+  for (size_t i = 0; i < _vertices.size(); ++i) {
+    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
+    v->lockQuadraticForm();
+  }
+#endif
+
+  const double delta = 1e-9;
+  const double scalar = 1.0 / (2*delta);
   ErrorVector errorBak;
   ErrorVector errorBeforeNumeric = _error;
 
-  // A statically allocated array is far and away the most efficient
-  // way to construct the perturbation vector for the Jacobian. If the
-  // dimension is less than 12, use a statically allocated
-  // buffer. Otherwise, a fallback of the dynamically allocated
-  // array. The value of 12 is used because most vertices have a
-  // dimension significantly smaller than this.
-  
-  dynamic_aligned_buffer<number_t> buffer{ 12 };
-  
   for (size_t i = 0; i < _vertices.size(); ++i) {
     //Xi - estimate the jacobian numerically
     OptimizableGraph::Vertex* vi = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
 
-    if (vi->fixed()) {
+    if (vi->fixed())
       continue;
-    }
 
-    internal::QuadraticFormLock lck(*vi);
     const int vi_dim = vi->dimension();
     assert(vi_dim >= 0);
-    
+#ifdef _MSC_VER
+    double* add_vi = new double[vi_dim];
+#else
+    double add_vi[vi_dim];
+#endif
+    std::fill(add_vi, add_vi + vi_dim, 0.0);
     assert(_dimension >= 0);
     assert(_jacobianOplus[i].rows() == _dimension && _jacobianOplus[i].cols() == vi_dim && "jacobian cache dimension does not match");
-    _jacobianOplus[i].resize(_dimension, vi_dim);
+      _jacobianOplus[i].resize(_dimension, vi_dim);
     // add small step along the unit vector in each dimension
-    if (vi_dim <= 12)
-      {
-	number_t add_vi[12] = {};
-	for (int d = 0; d < vi_dim; ++d) {
-	  vi->push();
-	  add_vi[d] = delta;
-	  vi->oplus(add_vi);
-	  computeError();
-	  errorBak = _error;
-	  vi->pop();
-	  vi->push();
-	  add_vi[d] = -delta;
-	  vi->oplus(add_vi);
-	  computeError();
-	  errorBak -= _error;
-	  vi->pop();
-	  add_vi[d] = 0.0;
-          
-	  _jacobianOplus[i].col(d) = scalar * errorBak;
-	} // end dimension
-      }
-    else
-      {
-	number_t* add_vi = buffer.request(vi_dim);
-	std::fill(add_vi, add_vi + vi_dim, cst(0.0));
-	for (int d = 0; d < vi_dim; ++d) {
-	  vi->push();
-	  add_vi[d] = delta;
-	  vi->oplus(add_vi);
-	  computeError();
-	  errorBak = _error;
-	  vi->pop();
-	  vi->push();
-	  add_vi[d] = -delta;
-	  vi->oplus(add_vi);
-	  computeError();
-	  errorBak -= _error;
-	  vi->pop();
-	  add_vi[d] = 0.0;
+    for (int d = 0; d < vi_dim; ++d) {
+      vi->push();
+      add_vi[d] = delta;
+      vi->oplus(add_vi);
+      computeError();
+      errorBak = _error;
+      vi->pop();
+      vi->push();
+      add_vi[d] = -delta;
+      vi->oplus(add_vi);
+      computeError();
+      errorBak -= _error;
+      vi->pop();
+      add_vi[d] = 0.0;
+
+      _jacobianOplus[i].col(d) = scalar * errorBak;
+    } // end dimension
+#ifdef _MSC_VER
+    delete[] add_vi;
+#endif
+  }
+  _error = errorBeforeNumeric;
 
-	  _jacobianOplus[i].col(d) = scalar * errorBak;
-	} // end dimension
-      }
-    _error = errorBeforeNumeric;
+#ifdef G2O_OPENMP
+  for (int i = (int)(_vertices.size()) - 1; i >= 0; --i) {
+    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
+    v->unlockQuadraticForm();
   }
+#endif
+
 }
 
 template <int D, typename E>
-void BaseMultiEdge<D, E>::mapHessianMemory(number_t* d, int i, int j, bool rowMajor)
+void BaseMultiEdge<D, E>::mapHessianMemory(double* d, int i, int j, bool rowMajor)
 {
   int idx = internal::computeUpperTriangleIndex(i, j);
   assert(idx < (int)_hessian.size());
@@ -189,29 +175,30 @@ void BaseMultiEdge<D, E>::computeQuadraticForm(const InformationType& omega, con
     bool istatus = !(from->fixed());
 
     if (istatus) {
-      const JacobianType& A = _jacobianOplus[i];
+      const Eigen::MatrixXd& A = _jacobianOplus[i];
 
-      MatrixX AtO = A.transpose() * omega;
+      Eigen::MatrixXd AtO = A.transpose() * omega;
       int fromDim = from->dimension();
       assert(fromDim >= 0);
-      Eigen::Map<MatrixX> fromMap(from->hessianData(), fromDim, fromDim);
-      Eigen::Map<VectorX> fromB(from->bData(), fromDim);
+      Eigen::Map<Eigen::MatrixXd> fromMap(from->hessianData(), fromDim, fromDim);
+      Eigen::Map<Eigen::VectorXd> fromB(from->bData(), fromDim);
 
       // ii block in the hessian
-      {
-        internal::QuadraticFormLock lck(*from);
-        fromMap.noalias() += AtO * A;
-        fromB.noalias() += A.transpose() * weightedError;
-      }
+#ifdef G2O_OPENMP
+      from->lockQuadraticForm();
+#endif
+      fromMap.noalias() += AtO * A;
+      fromB.noalias() += A.transpose() * weightedError;
 
       // compute the off-diagonal blocks ij for all j
       for (size_t j = i+1; j < _vertices.size(); ++j) {
         OptimizableGraph::Vertex* to = static_cast<OptimizableGraph::Vertex*>(_vertices[j]);
-
+#ifdef G2O_OPENMP
+        to->lockQuadraticForm();
+#endif
         bool jstatus = !(to->fixed());
         if (jstatus) {
-          internal::QuadraticFormLock lck(*to);
-          const JacobianType& B = _jacobianOplus[j];
+          const Eigen::MatrixXd& B = _jacobianOplus[j];
           int idx = internal::computeUpperTriangleIndex(i, j);
           assert(idx < (int)_hessian.size());
           HessianHelper& hhelper = _hessian[idx];
@@ -221,201 +208,15 @@ void BaseMultiEdge<D, E>::computeQuadraticForm(const InformationType& omega, con
             hhelper.matrix.noalias() += AtO * B;
           }
         }
+#ifdef G2O_OPENMP
+        to->unlockQuadraticForm();
+#endif
       }
-    }
-  }
-}
-
-
-// PARTIAL TEMPLATE SPECIALIZATION
-
-template <typename E>
-void BaseMultiEdge<-1, E>::constructQuadraticForm()
-{
-  if (this->robustKernel()) {
-    number_t error = this->chi2();
-    Vector3 rho;
-    this->robustKernel()->robustify(error, rho);
-    Eigen::Matrix<number_t, Eigen::Dynamic, 1, Eigen::ColMajor> omega_r = - _information * _error;
-    omega_r *= rho[1];
-    computeQuadraticForm(this->robustInformation(rho), omega_r);
-  } else {
-    computeQuadraticForm(_information, - _information * _error);
-  }
-}
-
-
-template <typename E>
-void BaseMultiEdge<-1, E>::linearizeOplus(JacobianWorkspace& jacobianWorkspace)
-{
-  for (size_t i = 0; i < _vertices.size(); ++i) {
-    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
-    assert(v->dimension() >= 0);
-    new (&_jacobianOplus[i]) JacobianType(jacobianWorkspace.workspaceForVertex(i), _dimension, v->dimension());
-  }
-  linearizeOplus();
-}
-
-template <typename E>
-void BaseMultiEdge<-1, E>::linearizeOplus()
-{
-  const number_t delta = cst(1e-9);
-  const number_t scalar = 1 / (2*delta);
-  ErrorVector errorBak;
-  ErrorVector errorBeforeNumeric = _error;
-
-  for (size_t i = 0; i < _vertices.size(); ++i) {
-    //Xi - estimate the jacobian numerically
-    OptimizableGraph::Vertex* vi = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
-
-    if (vi->fixed()) {
-      continue;
-    }
-
-    internal::QuadraticFormLock lck(*vi);
-    const int vi_dim = vi->dimension();
-    assert(vi_dim >= 0);
-
-    assert(_jacobianOplus[i].rows() == _dimension && _jacobianOplus[i].cols() == vi_dim && "jacobian cache dimension does not match");
-    _jacobianOplus[i].resize(_dimension, vi_dim);
-
-    if (vi_dim < 20)
-    {
-      number_t add_vi[20] = {};
-      
-      // add small step along the unit vector in each dimension
-      for (int d = 0; d < vi_dim; ++d) {
-        vi->push();
-        add_vi[d] = delta;
-        vi->oplus(add_vi);
-        computeError();
-        errorBak = _error;
-        vi->pop();
-        vi->push();
-        add_vi[d] = -delta;
-        vi->oplus(add_vi);
-        computeError();
-        errorBak -= _error;
-        vi->pop();
-        add_vi[d] = 0.0;
-        
-        _jacobianOplus[i].col(d) = scalar * errorBak;
-      } // end dimension
-    }
-  else
-    {
-      Eigen::Matrix<number_t, Eigen::Dynamic, 1> add_vi(vi_dim);
-      add_vi.setZero();
-      number_t* v = add_vi.data();
-
-      // add small step along the unit vector in each dimension
-      for (int d = 0; d < vi_dim; ++d) {
-        vi->push();
-        *v = delta;
-        vi->oplus(v);
-        computeError();
-        errorBak = _error;
-        vi->pop();
-        vi->push();
-        *v = - delta;
-        vi->oplus(v);
-        computeError();
-        errorBak -= _error;
-        vi->pop();
-        *(v++) = 0;
-        _jacobianOplus[i].col(d) = scalar * errorBak;
-      } // end dimension
-    }
-
-  
-    _error = errorBeforeNumeric;
-
-  }
-}
-
 
-template <typename E>
-void BaseMultiEdge<-1, E>::mapHessianMemory(number_t* d, int i, int j, bool rowMajor)
-{
-  int idx = internal::computeUpperTriangleIndex(i, j);
-  assert(idx < (int)_hessian.size());
-  OptimizableGraph::Vertex* vi = static_cast<OptimizableGraph::Vertex*>(HyperGraph::Edge::vertex(i));
-  OptimizableGraph::Vertex* vj = static_cast<OptimizableGraph::Vertex*>(HyperGraph::Edge::vertex(j));
-  assert(vi->dimension() >= 0);
-  assert(vj->dimension() >= 0);
-  HessianHelper& h = _hessian[idx];
-  if (rowMajor) {
-    if (h.matrix.data() != d || h.transposed != rowMajor)
-      new (&h.matrix) HessianBlockType(d, vj->dimension(), vi->dimension());
-  } else {
-    if (h.matrix.data() != d || h.transposed != rowMajor)
-      new (&h.matrix) HessianBlockType(d, vi->dimension(), vj->dimension());
-  }
-  h.transposed = rowMajor;
-}
-
-template <typename E>
-void BaseMultiEdge<-1, E>::resize(size_t size)
-{
-  BaseEdge<-1,E>::resize(size);
-  int n = (int)_vertices.size();
-  int maxIdx = (n * (n-1))/2;
-  assert(maxIdx >= 0);
-  _hessian.resize(maxIdx);
-  _jacobianOplus.resize(size, JacobianType(0,0,0));
-}
-
-template <typename E>
-bool BaseMultiEdge<-1, E>::allVerticesFixed() const
-{
-  for (size_t i = 0; i < _vertices.size(); ++i) {
-    if (!static_cast<const OptimizableGraph::Vertex*> (_vertices[i])->fixed()) {
-      return false;
+#ifdef G2O_OPENMP
+      from->unlockQuadraticForm();
+#endif
     }
-  }
-  return true;
-}
-
-template <typename E>
-void BaseMultiEdge<-1, E>::computeQuadraticForm(const InformationType& omega, const ErrorVector& weightedError)
-{
-  for (size_t i = 0; i < _vertices.size(); ++i) {
-    OptimizableGraph::Vertex* from = static_cast<OptimizableGraph::Vertex*>(_vertices[i]);
-    bool istatus = !(from->fixed());
-
-    if (istatus) {
-      const JacobianType& A = _jacobianOplus[i];
-
-      MatrixX AtO = A.transpose() * omega;
-      int fromDim = from->dimension();
-      assert(fromDim >= 0);
-      Eigen::Map<MatrixX> fromMap(from->hessianData(), fromDim, fromDim);
-      Eigen::Map<VectorX> fromB(from->bData(), fromDim);
-
-      // ii block in the hessian
-      {
-        internal::QuadraticFormLock lck(*from);
-        fromMap.noalias() += AtO * A;
-        fromB.noalias() += A.transpose() * weightedError;
-      }
 
-      // compute the off-diagonal blocks ij for all j
-      for (size_t j = i+1; j < _vertices.size(); ++j) {
-        OptimizableGraph::Vertex* to = static_cast<OptimizableGraph::Vertex*>(_vertices[j]);
-        bool jstatus = !(to->fixed());
-        if (jstatus) {
-          internal::QuadraticFormLock lck(*to);
-          const JacobianType& B = _jacobianOplus[j];
-          int idx = internal::computeUpperTriangleIndex(i, j);
-          assert(idx < (int)_hessian.size());
-          HessianHelper& hhelper = _hessian[idx];
-          if (hhelper.transposed) { // we have to write to the block as transposed
-            hhelper.matrix.noalias() += B.transpose() * AtO.transpose();
-          } else {
-            hhelper.matrix.noalias() += AtO * B;
-          }
-        }
-      }
-    }
   }
 }
diff --git a/g2o/core/base_unary_edge.h b/g2o/core/base_unary_edge.h
index b20141c2..b0c5b2b4 100644
--- a/g2o/core/base_unary_edge.h
+++ b/g2o/core/base_unary_edge.h
@@ -31,11 +31,9 @@
 #include <cassert>
 #include <limits>
 
-#include "g2o/config.h"
-#include "g2o/stuff/misc.h"
 #include "base_edge.h"
 #include "robust_kernel.h"
-#include "dynamic_aligned_buffer.hpp"
+#include "g2o/config.h"
 
 namespace g2o {
 
@@ -47,14 +45,14 @@ namespace g2o {
       static const int Dimension = BaseEdge<D, E>::Dimension;
       typedef typename BaseEdge<D,E>::Measurement Measurement;
       typedef VertexXi VertexXiType;
-      typedef typename Eigen::Matrix<number_t, D, VertexXiType::Dimension, D==1?Eigen::RowMajor:Eigen::ColMajor>::AlignedMapType JacobianXiOplusType;
+      typedef typename Eigen::Matrix<double, D, VertexXiType::Dimension>::AlignedMapType JacobianXiOplusType;
       typedef typename BaseEdge<D,E>::ErrorVector ErrorVector;
       typedef typename BaseEdge<D,E>::InformationType InformationType;
 
       BaseUnaryEdge() : BaseEdge<D,E>(),
         _jacobianOplusXi(0, D, VertexXiType::Dimension)
       {
-        _vertices.resize(1, nullptr);
+        _vertices.resize(1);
       }
 
       virtual void resize(size_t size);
@@ -63,8 +61,6 @@ namespace g2o {
 
       virtual void linearizeOplus(JacobianWorkspace& jacobianWorkspace);
 
-      virtual OptimizableGraph::Vertex* createVertex(int i);
-      
       /**
        * Linearizes the oplus operator in the vertex, and stores
        * the result in temporary variables _jacobianOplusXi and _jacobianOplusXj
@@ -78,7 +74,7 @@ namespace g2o {
 
       virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
 
-      virtual void mapHessianMemory(number_t*, int, int, bool) {assert(0 && "BaseUnaryEdge does not map memory of the Hessian");}
+      virtual void mapHessianMemory(double*, int, int, bool) {assert(0 && "BaseUnaryEdge does not map memory of the Hessian");}
 
       using BaseEdge<D,E>::resize;
       using BaseEdge<D,E>::computeError;
@@ -93,7 +89,7 @@ namespace g2o {
       JacobianXiOplusType _jacobianOplusXi;
 
     public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+      
   };
 
 #include "base_unary_edge.hpp"
diff --git a/g2o/core/base_unary_edge.hpp b/g2o/core/base_unary_edge.hpp
index edeca201..464900fb 100644
--- a/g2o/core/base_unary_edge.hpp
+++ b/g2o/core/base_unary_edge.hpp
@@ -24,12 +24,12 @@
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#define G2O_VERTEX_I_DIM ((VertexXiType::Dimension < 0) ? static_cast<const VertexXiType*> (_vertices[0])->dimension() : VertexXiType::Dimension)
-
 template <int D, typename E, typename VertexXiType>
 void BaseUnaryEdge<D, E, VertexXiType>::resize(size_t size)
 {
-  assert(size == 1 && "error resizing unary edge where size != 1");
+  if (size != 1) {
+    std::cerr << "WARNING, attempting to resize unary edge " << BaseEdge<D, E>::id() << " to " << size << std::endl;
+  }
   BaseEdge<D, E>::resize(size);
 }
 
@@ -39,14 +39,6 @@ bool BaseUnaryEdge<D, E, VertexXiType>::allVerticesFixed() const
   return static_cast<const VertexXiType*> (_vertices[0])->fixed();
 }
 
-template <int D, typename E, typename VertexXiType>
-OptimizableGraph::Vertex* BaseUnaryEdge<D, E, VertexXiType>::createVertex(int i)
-{
-  if (i!=0)
-    return nullptr;
-  return new VertexXiType();
-}
-
 template <int D, typename E, typename VertexXiType>
 void BaseUnaryEdge<D, E, VertexXiType>::constructQuadraticForm()
 {
@@ -58,30 +50,31 @@ void BaseUnaryEdge<D, E, VertexXiType>::constructQuadraticForm()
 
   bool istatus = !from->fixed();
   if (istatus) {
-    internal::QuadraticFormLock lck(*from);
+#ifdef G2O_OPENMP
+    from->lockQuadraticForm();
+#endif
     if (this->robustKernel()) {
-      number_t error = this->chi2();
-      Vector3 rho;
+      double error = this->chi2();
+      Eigen::Vector3d rho;
       this->robustKernel()->robustify(error, rho);
       InformationType weightedOmega = this->robustInformation(rho);
 
       from->b().noalias() -= rho[1] * A.transpose() * omega * _error;
       from->A().noalias() += A.transpose() * weightedOmega * A;
     } else {
-      //std::cout << "from->b()=" << from->b().transpose() << std::endl;
-      //std::cout << "A.transpose()=" << A.transpose() << std::endl;
-      //std::cout << "omega=" << omega << std::endl;
-      //std::cout << "_error=" << _error.transpose() << std::endl;
       from->b().noalias() -= A.transpose() * omega * _error;
       from->A().noalias() += A.transpose() * omega * A;
     }
+#ifdef G2O_OPENMP
+    from->unlockQuadraticForm();
+#endif
   }
 }
 
 template <int D, typename E, typename VertexXiType>
 void BaseUnaryEdge<D, E, VertexXiType>::linearizeOplus(JacobianWorkspace& jacobianWorkspace)
 {
-  new (&_jacobianOplusXi) JacobianXiOplusType(jacobianWorkspace.workspaceForVertex(0), D < 0 ? _dimension : D, G2O_VERTEX_I_DIM);
+  new (&_jacobianOplusXi) JacobianXiOplusType(jacobianWorkspace.workspaceForVertex(0), D, VertexXiType::Dimension);
   linearizeOplus();
 }
 
@@ -94,71 +87,39 @@ void BaseUnaryEdge<D, E, VertexXiType>::linearizeOplus()
   if (vi->fixed())
     return;
 
-  internal::QuadraticFormLock lck(*vi);
+#ifdef G2O_OPENMP
+  vi->lockQuadraticForm();
+#endif
 
-  const number_t delta = cst(1e-9);
-  const number_t scalar = 1 / (2*delta);
-  ErrorVector errorBak;
+  const double delta = 1e-9;
+  const double scalar = 1.0 / (2*delta);
+  ErrorVector error1;
   ErrorVector errorBeforeNumeric = _error;
 
-  // A statically allocated array is far and away the most efficient
-  // way to construct the perturbation vector for the Jacobian. If the
-  // dimension is known at compile time, use directly. If the
-  // dimension is known at run time and is less than 12, use an
-  // allocated array of up to 12. Otherwise, use a fallback of the
-  // dynamically allocated array. The value of 12 is used because
-  // most vertices have a dimension significantly smaller than this.
-
-  const int vi_dim = G2O_VERTEX_I_DIM;
-
-  if ((VertexXiType::Dimension >= 0) || (vi_dim <= 12))
-    {
-      number_t add_vi[(VertexXiType::Dimension >= 0) ? VertexXiType::Dimension : 12] = {};
-
-      // add small step along the unit vector in each dimension
-      for (int d = 0; d < vi_dim; ++d) {
-        vi->push();
-        add_vi[d] = delta;
-        vi->oplus(add_vi);
-        computeError();
-        errorBak = _error;
-        vi->pop();
-        vi->push();
-        add_vi[d] = -delta;
-        vi->oplus(add_vi);
-        computeError();
-        errorBak -= _error;
-        vi->pop();
-        add_vi[d] = 0.0;
-        _jacobianOplusXi.col(d) = scalar * errorBak;
-      } // end dimension
-    }
-  else
-    {
-      dynamic_aligned_buffer<number_t> buffer{ size_t(vi_dim) };
-      number_t* add_vi = buffer.request(vi_dim);
-      std::fill(add_vi, add_vi + vi_dim, cst(0.0));
-      
-      // add small step along the unit vector in each dimension
-      for (int d = 0; d < vi_dim; ++d) {
-        vi->push();
-        add_vi[d] = delta;
-        vi->oplus(add_vi);
-        computeError();
-        errorBak = _error;
-        vi->pop();
-        vi->push();
-        add_vi[d] = - delta;
-        vi->oplus(add_vi);
-        computeError();
-        errorBak -= _error;
-        vi->pop();
-        add_vi[d] = 0;
-        _jacobianOplusXi.col(d) = scalar * errorBak;
-      } // end dimension
-    }
+  double add_vi[VertexXiType::Dimension];
+  std::fill(add_vi, add_vi + VertexXiType::Dimension, 0.0);
+  // add small step along the unit vector in each dimension
+  for (int d = 0; d < VertexXiType::Dimension; ++d) {
+    vi->push();
+    add_vi[d] = delta;
+    vi->oplus(add_vi);
+    computeError();
+    error1 = _error;
+    vi->pop();
+    vi->push();
+    add_vi[d] = -delta;
+    vi->oplus(add_vi);
+    computeError();
+    vi->pop();
+    add_vi[d] = 0.0;
+
+    _jacobianOplusXi.col(d) = scalar * (error1 - _error);
+  } // end dimension
 
   _error = errorBeforeNumeric;
+#ifdef G2O_OPENMP
+  vi->unlockQuadraticForm();
+#endif
 }
 
 template <int D, typename E, typename VertexXiType>
@@ -166,5 +127,3 @@ void BaseUnaryEdge<D, E, VertexXiType>::initialEstimate(const OptimizableGraph::
 {
   std::cerr << __PRETTY_FUNCTION__ << " is not implemented, please give implementation in your derived class" << std::endl;
 }
-
-#undef G2O_VERTEX_I_DIM
diff --git a/g2o/core/base_vertex.h b/g2o/core/base_vertex.h
index 4e12cd83..7cc340a7 100644
--- a/g2o/core/base_vertex.h
+++ b/g2o/core/base_vertex.h
@@ -29,20 +29,23 @@
 
 #include "optimizable_graph.h"
 #include "creators.h"
-#include "g2o/stuff/macros.h"
+#include "../stuff/macros.h"
 
 #include <Eigen/Core>
 #include <Eigen/Dense>
 #include <Eigen/Cholesky>
+#include <Eigen/StdVector>
 #include <stack>
 
 namespace g2o {
-#define G2O_VERTEX_DIM ((D == Eigen::Dynamic) ? _dimension : D)
-  /**
+
+
+
+/**
  * \brief Templatized BaseVertex
  *
  * Templatized BaseVertex
- * D  : minimal dimension of the vertex, e.g., 3 for rotation in 3D. -1 means dynamically assigned at runtime.
+ * D  : minimal dimension of the vertex, e.g., 3 for rotation in 3D
  * T  : internal type to represent the estimate, e.g., Quaternion for rotation in 3D
  */
   template <int D, typename T>
@@ -55,38 +58,36 @@ namespace g2o {
 
     static const int Dimension = D;           ///< dimension of the estimate (minimal) in the manifold space
 
-    typedef Eigen::Map<Eigen::Matrix<number_t, D, D, Eigen::ColMajor>, Eigen::Matrix<number_t, D, D, Eigen::ColMajor>::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned >  HessianBlockType;
+    typedef Eigen::Map<Eigen::Matrix<double, D, D>, Eigen::Matrix<double,D,D>::Flags & Eigen::PacketAccessBit ? Eigen::Aligned : Eigen::Unaligned >  HessianBlockType;
 
   public:
     BaseVertex();
 
-    virtual const number_t& hessian(int i, int j) const { assert(i<G2O_VERTEX_DIM && j<G2O_VERTEX_DIM); return _hessian(i,j);}
-    virtual number_t& hessian(int i, int j)  { assert(i<G2O_VERTEX_DIM && j<G2O_VERTEX_DIM); return _hessian(i,j);}
-    virtual number_t hessianDeterminant() const {return _hessian.determinant();}
-    virtual number_t* hessianData() { return const_cast<number_t*>(_hessian.data());}
+    virtual const double& hessian(int i, int j) const { assert(i<D && j<D); return _hessian(i,j);}
+    virtual double& hessian(int i, int j)  { assert(i<D && j<D); return _hessian(i,j);}
+    virtual double hessianDeterminant() const {return _hessian.determinant();}
+    virtual double* hessianData() { return const_cast<double*>(_hessian.data());}
 
-    inline virtual void mapHessianMemory(number_t* d);
+    virtual void mapHessianMemory(double* d);
 
-
-    virtual int copyB(number_t* b_) const {
-      const int vertexDim = G2O_VERTEX_DIM;
-      memcpy(b_, _b.data(), vertexDim * sizeof(number_t));
-      return vertexDim; 
+    virtual int copyB(double* b_) const {
+      memcpy(b_, _b.data(), Dimension * sizeof(double));
+      return Dimension; 
     }
 
-    virtual const number_t& b(int i) const { assert(i < D); return _b(i);}
-    virtual number_t& b(int i) { assert(i < G2O_VERTEX_DIM); return _b(i);}
-    virtual number_t* bData() { return _b.data();}
+    virtual const double& b(int i) const { assert(i < D); return _b(i);}
+    virtual double& b(int i) { assert(i < D); return _b(i);}
+    virtual double* bData() { return _b.data();}
 
-    inline virtual void clearQuadraticForm();
+    virtual void clearQuadraticForm();
 
     //! updates the current vertex with the direct solution x += H_ii\b_ii
     //! @returns the determinant of the inverted hessian
-    inline virtual number_t solveDirect(number_t lambda=0);
+    virtual double solveDirect(double lambda=0);
 
     //! return right hand side b of the constructed linear system
-    Eigen::Matrix<number_t, D, 1, Eigen::ColMajor>& b() { return _b;}
-    const Eigen::Matrix<number_t, D, 1, Eigen::ColMajor>& b() const { return _b;}
+    Eigen::Matrix<double, D, 1>& b() { return _b;}
+    const Eigen::Matrix<double, D, 1>& b() const { return _b;}
     //! return the hessian block associated with the vertex
     HessianBlockType& A() { return _hessian;}
     const HessianBlockType& A() const { return _hessian;}
@@ -103,17 +104,15 @@ namespace g2o {
 
   protected:
     HessianBlockType _hessian;
-    Eigen::Matrix<number_t, D, 1, Eigen::ColMajor> _b;
+    Eigen::Matrix<double, D, 1> _b;
     EstimateType _estimate;
     BackupStackType _backup;
   public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+    
 };
 
 #include "base_vertex.hpp"
 
-#undef G2O_VERTEX_DIM
-
 } // end namespace g2o
 
 
diff --git a/g2o/core/base_vertex.hpp b/g2o/core/base_vertex.hpp
index 30c2b183..e09a4aff 100644
--- a/g2o/core/base_vertex.hpp
+++ b/g2o/core/base_vertex.hpp
@@ -27,18 +27,18 @@
 template <int D, typename T>
 BaseVertex<D, T>::BaseVertex() :
   OptimizableGraph::Vertex(),
-  _hessian(nullptr, D, D)
+  _hessian(0, D, D)
 {
   _dimension = D;
 }
 
 template <int D, typename T>
-number_t BaseVertex<D, T>::solveDirect(number_t lambda) {
-  Eigen::Matrix<number_t, D, D, Eigen::ColMajor> tempA=_hessian + Eigen::Matrix<number_t, D, D, Eigen::ColMajor>::Identity(G2O_VERTEX_DIM, G2O_VERTEX_DIM)*lambda;
-  number_t det=tempA.determinant();
-  if (g2o_isnan(det) || det < std::numeric_limits<number_t>::epsilon())
+double BaseVertex<D, T>::solveDirect(double lambda) {
+  Eigen::Matrix <double, D, D> tempA=_hessian + Eigen::Matrix <double, D, D>::Identity()*lambda;
+  double det=tempA.determinant();
+  if (g2o_isnan(det) || det < std::numeric_limits<double>::epsilon())
     return det;
-  Eigen::Matrix<number_t, D, 1, Eigen::ColMajor> dx=tempA.llt().solve(_b);
+  Eigen::Matrix <double, D, 1> dx=tempA.llt().solve(_b);
   oplus(&dx[0]);
   return det;
 }
@@ -49,8 +49,7 @@ void BaseVertex<D, T>::clearQuadraticForm() {
 }
 
 template <int D, typename T>
-void BaseVertex<D, T>::mapHessianMemory(number_t* d)
+void BaseVertex<D, T>::mapHessianMemory(double* d)
 {
-  const int vertexDim = G2O_VERTEX_DIM;
-  new (&_hessian) HessianBlockType(d, vertexDim, vertexDim);
+  new (&_hessian) HessianBlockType(d, D, D);
 }
diff --git a/g2o/core/batch_stats.cpp b/g2o/core/batch_stats.cpp
index a6beb69b..65292931 100644
--- a/g2o/core/batch_stats.cpp
+++ b/g2o/core/batch_stats.cpp
@@ -28,7 +28,7 @@
 #include <cstring>
 
 namespace g2o {
-  using namespace std;
+  
 
   G2OBatchStatistics* G2OBatchStatistics::_globalStats=0;
 
diff --git a/g2o/core/batch_stats.h b/g2o/core/batch_stats.h
index 3e229cfb..d039f656 100644
--- a/g2o/core/batch_stats.h
+++ b/g2o/core/batch_stats.h
@@ -30,39 +30,38 @@
 #include <iostream>
 #include <vector>
 
-#include "g2o_core_api.h"
 
 namespace g2o {
 
   /**
    * \brief statistics about the optimization
    */
-  struct G2O_CORE_API G2OBatchStatistics {
+  struct  G2OBatchStatistics {
     G2OBatchStatistics();
     int iteration;                    ///< which iteration
     int numVertices;                  ///< how many vertices are involved
     int numEdges;                     ///< how many edges
-    number_t chi2;                      ///< total chi2
+    double chi2;                      ///< total chi2
 
     /** timings **/
     // nonlinear part
-    number_t timeResiduals;             ///< residuals
-    number_t timeLinearize;             ///< jacobians
-    number_t timeQuadraticForm;         ///< construct the quadratic form in the graph
+    double timeResiduals;             ///< residuals
+    double timeLinearize;             ///< jacobians
+    double timeQuadraticForm;         ///< construct the quadratic form in the graph
     int levenbergIterations;          ///< number of iterations performed by LM
     // block_solver (constructs Ax=b, plus maybe schur)
-    number_t timeSchurComplement;      ///< compute schur complement (0 if not done)
+    double timeSchurComplement;      ///< compute schur complement (0 if not done)
 
     // linear solver (computes Ax=b);
-    number_t timeSymbolicDecomposition; ///< symbolic decomposition (0 if not done)
-    number_t timeNumericDecomposition;  ///< numeric decomposition  (0 if not done)
-    number_t timeLinearSolution;        ///< total time for solving Ax=b (including detup for schur)
-    number_t timeLinearSolver;          ///< time for solving, excluding Schur setup
+    double timeSymbolicDecomposition; ///< symbolic decomposition (0 if not done)
+    double timeNumericDecomposition;  ///< numeric decomposition  (0 if not done)
+    double timeLinearSolution;        ///< total time for solving Ax=b (including detup for schur)
+    double timeLinearSolver;          ///< time for solving, excluding Schur setup
     int    iterationsLinearSolver;    ///< iterations of PCG, (0 if not used, i.e., Cholesky)
-    number_t timeUpdate;                ///< time to apply the update
-    number_t timeIteration;             ///< total time;
+    double timeUpdate;                ///< time to apply the update
+    double timeIteration;             ///< total time;
 
-    number_t timeMarginals;             ///< computing the inverse elements (solve blocks) and thus the marginal covariances
+    double timeMarginals;             ///< computing the inverse elements (solve blocks) and thus the marginal covariances
 
     // information about the Hessian matrix
     size_t hessianDimension;          ///< rows / cols of the Hessian
@@ -76,7 +75,7 @@ namespace g2o {
     static G2OBatchStatistics* _globalStats;
   };
 
-  G2O_CORE_API std::ostream& operator<<(std::ostream&, const G2OBatchStatistics&);
+   std::ostream& operator<<(std::ostream&, const G2OBatchStatistics&);
 
   typedef std::vector<G2OBatchStatistics> BatchStatisticsContainer;
 }
diff --git a/g2o/core/block_solver.h b/g2o/core/block_solver.h
index 816c5509..77717269 100644
--- a/g2o/core/block_solver.h
+++ b/g2o/core/block_solver.h
@@ -26,7 +26,6 @@
 
 #ifndef G2O_BLOCK_SOLVER_H
 #define G2O_BLOCK_SOLVER_H
-
 #include <Eigen/Core>
 #include "solver.h"
 #include "linear_solver.h"
@@ -34,9 +33,6 @@
 #include "sparse_block_matrix_diagonal.h"
 #include "openmp_mutex.h"
 #include "g2o/config.h"
-#include "dynamic_aligned_buffer.hpp"
-
-#include <memory>
 
 namespace g2o {
 
@@ -48,11 +44,11 @@ namespace g2o {
   {
     static const int PoseDim = _PoseDim;
     static const int LandmarkDim = _LandmarkDim;
-    typedef Eigen::Matrix<number_t, PoseDim, PoseDim, Eigen::ColMajor> PoseMatrixType;
-    typedef Eigen::Matrix<number_t, LandmarkDim, LandmarkDim, Eigen::ColMajor> LandmarkMatrixType;
-    typedef Eigen::Matrix<number_t, PoseDim, LandmarkDim, Eigen::ColMajor> PoseLandmarkMatrixType;
-    typedef Eigen::Matrix<number_t, PoseDim, 1, Eigen::ColMajor> PoseVectorType;
-    typedef Eigen::Matrix<number_t, LandmarkDim, 1, Eigen::ColMajor> LandmarkVectorType;
+    typedef Eigen::Matrix<double, PoseDim, PoseDim> PoseMatrixType;
+    typedef Eigen::Matrix<double, LandmarkDim, LandmarkDim> LandmarkMatrixType;
+    typedef Eigen::Matrix<double, PoseDim, LandmarkDim> PoseLandmarkMatrixType;
+    typedef Eigen::Matrix<double, PoseDim, 1> PoseVectorType;
+    typedef Eigen::Matrix<double, LandmarkDim, 1> LandmarkVectorType;
 
     typedef SparseBlockMatrix<PoseMatrixType> PoseHessianType;
     typedef SparseBlockMatrix<LandmarkMatrixType> LandmarkHessianType;
@@ -68,11 +64,11 @@ namespace g2o {
   {
     static const int PoseDim = Eigen::Dynamic;
     static const int LandmarkDim = Eigen::Dynamic;
-    typedef MatrixX PoseMatrixType;
-    typedef MatrixX LandmarkMatrixType;
-    typedef MatrixX PoseLandmarkMatrixType;
-    typedef VectorX PoseVectorType;
-    typedef VectorX LandmarkVectorType;
+    typedef Eigen::MatrixXd PoseMatrixType;
+    typedef Eigen::MatrixXd LandmarkMatrixType;
+    typedef Eigen::MatrixXd PoseLandmarkMatrixType;
+    typedef Eigen::VectorXd PoseVectorType;
+    typedef Eigen::VectorXd LandmarkVectorType;
 
     typedef SparseBlockMatrix<PoseMatrixType> PoseHessianType;
     typedef SparseBlockMatrix<LandmarkMatrixType> LandmarkHessianType;
@@ -90,16 +86,16 @@ namespace g2o {
       /**
        * compute dest = H * src
        */
-      virtual void multiplyHessian(number_t* dest, const number_t* src) const = 0;
+      virtual void multiplyHessian(double* dest, const double* src) const = 0;
   };
 
   /**
    * \brief Implementation of a solver operating on the blocks of the Hessian
    */
   template <typename Traits>
-  class BlockSolver: public BlockSolverBase
-  {
+  class BlockSolver: public BlockSolverBase {
     public:
+
       static const int PoseDim = Traits::PoseDim;
       static const int LandmarkDim = Traits::LandmarkDim;
       typedef typename Traits::PoseMatrixType PoseMatrixType;
@@ -120,7 +116,7 @@ namespace g2o {
        * NOTE: The BlockSolver assumes exclusive access to the linear solver and will therefore free the pointer
        * in its destructor.
        */
-      BlockSolver(std::unique_ptr<LinearSolverType> linearSolver);
+      BlockSolver(LinearSolverType* linearSolver);
       ~BlockSolver();
 
       virtual bool init(SparseOptimizer* optmizer, bool online = false);
@@ -128,21 +124,21 @@ namespace g2o {
       virtual bool updateStructure(const std::vector<HyperGraph::Vertex*>& vset, const HyperGraph::EdgeSet& edges);
       virtual bool buildSystem();
       virtual bool solve();
-      virtual bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices);
-      virtual bool setLambda(number_t lambda, bool backup = false);
+      virtual bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices);
+      virtual bool setLambda(double lambda, bool backup = false);
       virtual void restoreDiagonal();
       virtual bool supportsSchur() {return true;}
       virtual bool schur() { return _doSchur;}
       virtual void setSchur(bool s) { _doSchur = s;}
 
-      LinearSolver<PoseMatrixType>& linearSolver() const { return *_linearSolver;}
+      LinearSolver<PoseMatrixType>* linearSolver() const { return _linearSolver;}
 
       virtual void setWriteDebug(bool writeDebug);
       virtual bool writeDebug() const {return _linearSolver->writeDebug();}
 
       virtual bool saveHessian(const std::string& fileName) const;
 
-      virtual void multiplyHessian(number_t* dest, const number_t* src) const { _Hpp->multiplySymmetricUpperTriangle(dest, src);}
+      virtual void multiplyHessian(double* dest, const double* src) const { _Hpp->multiplySymmetricUpperTriangle(dest, src);}
 
     protected:
       void resize(int* blockPoseIndices, int numPoseBlocks, 
@@ -150,17 +146,17 @@ namespace g2o {
 
       void deallocate();
 
-      std::unique_ptr<SparseBlockMatrix<PoseMatrixType>> _Hpp;
-      std::unique_ptr<SparseBlockMatrix<LandmarkMatrixType>> _Hll;
-      std::unique_ptr<SparseBlockMatrix<PoseLandmarkMatrixType>> _Hpl;
+      SparseBlockMatrix<PoseMatrixType>* _Hpp;
+      SparseBlockMatrix<LandmarkMatrixType>* _Hll;
+      SparseBlockMatrix<PoseLandmarkMatrixType>* _Hpl;
 
-      std::unique_ptr<SparseBlockMatrix<PoseMatrixType>> _Hschur;
-      std::unique_ptr<SparseBlockMatrixDiagonal<LandmarkMatrixType>> _DInvSchur;
+      SparseBlockMatrix<PoseMatrixType>* _Hschur;
+      SparseBlockMatrixDiagonal<LandmarkMatrixType>* _DInvSchur;
 
-      std::unique_ptr<SparseBlockMatrixCCS<PoseLandmarkMatrixType>> _HplCCS;
-      std::unique_ptr<SparseBlockMatrixCCS<PoseMatrixType>> _HschurTransposedCCS;
+      SparseBlockMatrixCCS<PoseLandmarkMatrixType>* _HplCCS;
+      SparseBlockMatrixCCS<PoseMatrixType>* _HschurTransposedCCS;
 
-      std::unique_ptr<LinearSolverType> _linearSolver;
+      LinearSolver<PoseMatrixType>* _linearSolver;
 
       std::vector<PoseVectorType, Eigen::aligned_allocator<PoseVectorType> > _diagonalBackupPose;
       std::vector<LandmarkVectorType, Eigen::aligned_allocator<LandmarkVectorType> > _diagonalBackupLandmark;
@@ -171,28 +167,22 @@ namespace g2o {
 
       bool _doSchur;
 
-      std::unique_ptr<number_t[], aligned_deleter<number_t>> _coefficients;
-      std::unique_ptr<number_t[], aligned_deleter<number_t>> _bschur;
+      double* _coefficients;
+      double* _bschur;
 
       int _numPoses, _numLandmarks;
       int _sizePoses, _sizeLandmarks;
   };
 
 
-  template<int p, int l>
-  using BlockSolverPL = BlockSolver< BlockSolverTraits<p, l> >;
-
   //variable size solver
-  using BlockSolverX = BlockSolverPL<Eigen::Dynamic, Eigen::Dynamic>;
-
+  typedef BlockSolver< BlockSolverTraits<Eigen::Dynamic, Eigen::Dynamic> > BlockSolverX;
   // solver for BA/3D SLAM
-  using BlockSolver_6_3 = BlockSolverPL<6, 3>;
-
+  typedef BlockSolver< BlockSolverTraits<6, 3> > BlockSolver_6_3;  
   // solver fo BA with scale
-  using BlockSolver_7_3 = BlockSolverPL<7, 3>;
-
+  typedef BlockSolver< BlockSolverTraits<7, 3> > BlockSolver_7_3;  
   // 2Dof landmarks 3Dof poses
-  using BlockSolver_3_2 = BlockSolverPL<3, 2>;
+  typedef BlockSolver< BlockSolverTraits<3, 2> > BlockSolver_3_2;
 
 } // end namespace
 
diff --git a/g2o/core/block_solver.hpp b/g2o/core/block_solver.hpp
index 899675b1..4a78e6a7 100644
--- a/g2o/core/block_solver.hpp
+++ b/g2o/core/block_solver.hpp
@@ -25,23 +25,31 @@
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "sparse_optimizer.h"
-
 #include <Eigen/LU>
 #include <fstream>
 #include <iomanip>
 
-#include "g2o/stuff/timeutil.h"
-#include "g2o/stuff/macros.h"
-#include "g2o/stuff/misc.h"
+#include "../stuff/timeutil.h"
+#include "../stuff/macros.h"
+#include "../stuff/misc.h"
 
 namespace g2o {
 
 template <typename Traits>
-BlockSolver<Traits>::BlockSolver(std::unique_ptr<LinearSolverType> linearSolver)
-    :   BlockSolverBase(),
-        _linearSolver(std::move(linearSolver))
+BlockSolver<Traits>::BlockSolver(LinearSolverType* linearSolver) :
+  BlockSolverBase(),
+  _linearSolver(linearSolver)
 {
   // workspace
+  _Hpp=0;
+  _Hll=0;
+  _Hpl=0;
+  _HplCCS = 0;
+  _HschurTransposedCCS = 0;
+  _Hschur=0;
+  _DInvSchur=0;
+  _coefficients=0;
+  _bschur = 0;
   _xSize=0;
   _numPoses=0;
   _numLandmarks=0;
@@ -62,18 +70,18 @@ void BlockSolver<Traits>::resize(int* blockPoseIndices, int numPoseBlocks,
   if (_doSchur) {
     // the following two are only used in schur
     assert(_sizePoses > 0 && "allocating with wrong size");
-    _coefficients.reset(allocate_aligned<number_t>(s));
-    _bschur.reset(allocate_aligned<number_t>(_sizePoses));
+    _coefficients = new double [s];
+    _bschur = new double[_sizePoses];
   }
 
-  _Hpp= g2o::make_unique<PoseHessianType>(blockPoseIndices, blockPoseIndices, numPoseBlocks, numPoseBlocks);
+  _Hpp=new PoseHessianType(blockPoseIndices, blockPoseIndices, numPoseBlocks, numPoseBlocks);
   if (_doSchur) {
-    _Hschur = g2o::make_unique<PoseHessianType>(blockPoseIndices, blockPoseIndices, numPoseBlocks, numPoseBlocks);
-    _Hll = g2o::make_unique<LandmarkHessianType>(blockLandmarkIndices, blockLandmarkIndices, numLandmarkBlocks, numLandmarkBlocks);
-    _DInvSchur = g2o::make_unique<SparseBlockMatrixDiagonal<LandmarkMatrixType>>(_Hll->colBlockIndices());
-    _Hpl = g2o::make_unique<PoseLandmarkHessianType>(blockPoseIndices, blockLandmarkIndices, numPoseBlocks, numLandmarkBlocks);
-    _HplCCS = g2o::make_unique<SparseBlockMatrixCCS<PoseLandmarkMatrixType>>(_Hpl->rowBlockIndices(), _Hpl->colBlockIndices());
-    _HschurTransposedCCS = g2o::make_unique<SparseBlockMatrixCCS<PoseMatrixType>>(_Hschur->colBlockIndices(), _Hschur->rowBlockIndices());
+    _Hschur=new PoseHessianType(blockPoseIndices, blockPoseIndices, numPoseBlocks, numPoseBlocks);
+    _Hll=new LandmarkHessianType(blockLandmarkIndices, blockLandmarkIndices, numLandmarkBlocks, numLandmarkBlocks);
+    _DInvSchur = new SparseBlockMatrixDiagonal<LandmarkMatrixType>(_Hll->colBlockIndices());
+    _Hpl=new PoseLandmarkHessianType(blockPoseIndices, blockLandmarkIndices, numPoseBlocks, numLandmarkBlocks);
+    _HplCCS = new SparseBlockMatrixCCS<PoseLandmarkMatrixType>(_Hpl->rowBlockIndices(), _Hpl->colBlockIndices());
+    _HschurTransposedCCS = new SparseBlockMatrixCCS<PoseMatrixType>(_Hschur->colBlockIndices(), _Hschur->rowBlockIndices());
 #ifdef G2O_OPENMP
     _coefficientsMutex.resize(numPoseBlocks);
 #endif
@@ -83,21 +91,50 @@ void BlockSolver<Traits>::resize(int* blockPoseIndices, int numPoseBlocks,
 template <typename Traits>
 void BlockSolver<Traits>::deallocate()
 {
-    _Hpp.reset();
-    _Hll.reset();
-    _Hpl.reset();
-    _Hschur.reset();
-    _DInvSchur.reset();
-    _coefficients.reset();
-    _bschur.reset();
-    
-    _HplCCS.reset();
-    _HschurTransposedCCS.reset();
+  if (_Hpp){
+    delete _Hpp;
+    _Hpp=0;
+  }
+  if (_Hll){
+    delete _Hll;
+    _Hll=0;
+  }
+  if (_Hpl){
+    delete _Hpl;
+    _Hpl = 0;
+  }
+  if (_Hschur){
+    delete _Hschur;
+    _Hschur=0;
+  }
+  if (_DInvSchur){
+    delete _DInvSchur;
+    _DInvSchur=0;
+  }
+  if (_coefficients) {
+    delete[] _coefficients;
+    _coefficients = 0;
+  }
+  if (_bschur) {
+    delete[] _bschur;
+    _bschur = 0;
+  }
+  if (_HplCCS) {
+    delete _HplCCS;
+    _HplCCS = 0;
+  }
+  if (_HschurTransposedCCS) {
+    delete _HschurTransposedCCS;
+    _HschurTransposedCCS = 0;
+  }
 }
 
 template <typename Traits>
 BlockSolver<Traits>::~BlockSolver()
-{}
+{
+  delete _linearSolver;
+  deallocate();
+}
 
 template <typename Traits>
 bool BlockSolver<Traits>::buildStructure(bool zeroBlocks)
@@ -213,15 +250,14 @@ bool BlockSolver<Traits>::buildStructure(bool zeroBlocks)
     }
   }
 
-  if (! _doSchur) {
-    delete schurMatrixLookup;
+  if (! _doSchur)
     return true;
-  }
 
   _DInvSchur->diagonal().resize(landmarkIdx);
   _Hpl->fillSparseBlockMatrixCCS(*_HplCCS);
 
-  for (OptimizableGraph::Vertex* v : _optimizer->indexMapping()) {
+  for (size_t i = 0; i < _optimizer->indexMapping().size(); ++i) {
+    OptimizableGraph::Vertex* v = _optimizer->indexMapping()[i];
     if (v->marginalized()){
       const HyperGraph::EdgeSet& vedges=v->edges();
       for (HyperGraph::EdgeSet::const_iterator it1=vedges.begin(); it1!=vedges.end(); ++it1){
@@ -313,9 +349,9 @@ bool BlockSolver<Traits>::updateStructure(const std::vector<HyperGraph::Vertex*>
 
 template <typename Traits>
 bool BlockSolver<Traits>::solve(){
-  //cerr << __PRETTY_FUNCTION__ << endl;
+  //std::cerr << __PRETTY_FUNCTION__ << std::endl;
   if (! _doSchur){
-    number_t t=get_monotonic_time();
+    double t=get_monotonic_time();
     bool ok = _linearSolver->solve(*_Hpp, _x, _b);
     G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
     if (globalStats) {
@@ -328,14 +364,14 @@ bool BlockSolver<Traits>::solve(){
   // schur thing
 
   // backup the coefficient matrix
-  number_t t=get_monotonic_time();
+  double t=get_monotonic_time();
 
   // _Hschur = _Hpp, but keeping the pattern of _Hschur
   _Hschur->clear();
-  _Hpp->add(*_Hschur);
+  _Hpp->add(_Hschur);
 
   //_DInvSchur->clear();
-  memset(_coefficients.get(), 0, _sizePoses*sizeof(number_t));
+  memset (_coefficients, 0, _sizePoses*sizeof(double));
 # ifdef G2O_OPENMP
 # pragma omp parallel for default (shared) schedule(dynamic, 10)
 # endif
@@ -391,10 +427,10 @@ bool BlockSolver<Traits>::solve(){
       }
     }
   }
-  //cerr << "Solve [marginalize] = " <<  get_monotonic_time()-t << endl;
+  //std::cerr << "Solve [marginalize] = " <<  get_monotonic_time()-t << std::endl;
 
   // _bschur = _b for calling solver, and not touching _b
-  memcpy(_bschur.get(), _b, _sizePoses * sizeof(number_t));
+  memcpy(_bschur, _b, _sizePoses * sizeof(double));
   for (int i=0; i<_sizePoses; ++i){
     _bschur[i]-=_coefficients[i];
   }
@@ -405,52 +441,52 @@ bool BlockSolver<Traits>::solve(){
   }
 
   t=get_monotonic_time();
-  bool solvedPoses = _linearSolver->solve(*_Hschur, _x, _bschur.get());
+  bool solvedPoses = _linearSolver->solve(*_Hschur, _x, _bschur);
   if (globalStats) {
     globalStats->timeLinearSolver = get_monotonic_time() - t;
     globalStats->hessianPoseDimension = _Hpp->cols();
     globalStats->hessianLandmarkDimension = _Hll->cols();
     globalStats->hessianDimension = globalStats->hessianPoseDimension + globalStats->hessianLandmarkDimension;
   }
-  //cerr << "Solve [decompose and solve] = " <<  get_monotonic_time()-t << endl;
+  //std::cerr << "Solve [decompose and solve] = " <<  get_monotonic_time()-t << std::endl;
 
   if (! solvedPoses)
     return false;
 
   // _x contains the solution for the poses, now applying it to the landmarks to get the new part of the
   // solution;
-  number_t* xp = _x;
-  number_t* cp = _coefficients.get();
+  double* xp = _x;
+  double* cp = _coefficients;
 
-  number_t* xl=_x+_sizePoses;
-  number_t* cl=_coefficients.get() + _sizePoses;
-  number_t* bl=_b+_sizePoses;
+  double* xl=_x+_sizePoses;
+  double* cl=_coefficients + _sizePoses;
+  double* bl=_b+_sizePoses;
 
   // cp = -xp
   for (int i=0; i<_sizePoses; ++i)
     cp[i]=-xp[i];
 
   // cl = bl
-  memcpy(cl,bl,_sizeLandmarks*sizeof(number_t));
+  memcpy(cl,bl,_sizeLandmarks*sizeof(double));
 
   // cl = bl - Bt * xp
   //Bt->multiply(cl, cp);
   _HplCCS->rightMultiply(cl, cp);
 
   // xl = Dinv * cl
-  memset(xl,0, _sizeLandmarks*sizeof(number_t));
+  memset(xl,0, _sizeLandmarks*sizeof(double));
   _DInvSchur->multiply(xl,cl);
   //_DInvSchur->rightMultiply(xl,cl);
-  //cerr << "Solve [landmark delta] = " <<  get_monotonic_time()-t << endl;
+  //std::cerr << "Solve [landmark delta] = " <<  get_monotonic_time()-t << std::endl;
 
   return true;
 }
 
 
 template <typename Traits>
-bool BlockSolver<Traits>::computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices)
+bool BlockSolver<Traits>::computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices)
 {
-  number_t t = get_monotonic_time();
+  double t = get_monotonic_time();
   bool ok = _linearSolver->solvePattern(spinv, blockIndices, *_Hpp);
   G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
   if (globalStats) {
@@ -517,12 +553,12 @@ bool BlockSolver<Traits>::buildSystem()
     v->copyB(_b+iBase);
   }
 
-  return false;
+  return 0;
 }
 
 
 template <typename Traits>
-bool BlockSolver<Traits>::setLambda(number_t lambda, bool backup)
+bool BlockSolver<Traits>::setLambda(double lambda, bool backup)
 {
   if (backup) {
     _diagonalBackupPose.resize(_numPoses);
diff --git a/g2o/core/cache.cpp b/g2o/core/cache.cpp
index 6d543bf7..9e615f7c 100644
--- a/g2o/core/cache.cpp
+++ b/g2o/core/cache.cpp
@@ -31,7 +31,7 @@
 #include <iostream>
 
 namespace g2o {
-  using namespace std;
+  
 
   Cache::CacheKey::CacheKey() :
     _type(), _parameters()
@@ -51,8 +51,6 @@ namespace g2o {
   bool Cache::CacheKey::operator<(const Cache::CacheKey& c) const{
     if (_type < c._type)
       return true;
-    else if (c._type < _type)
-      return false;
     return std::lexicographical_compare (_parameters.begin( ), _parameters.end( ),
            c._parameters.begin( ), c._parameters.end( ) );
   }
@@ -61,13 +59,13 @@ namespace g2o {
   OptimizableGraph::Vertex* Cache::vertex() { 
     if (container() ) 
       return container()->vertex(); 
-    return nullptr;
+    return 0; 
   }
 
   OptimizableGraph* Cache::graph() {
     if (container())
       return container()->graph();
-    return nullptr;
+    return 0;
   }
 
   CacheContainer* Cache::container() {
@@ -87,7 +85,7 @@ namespace g2o {
   void Cache::update(){
     if (! _updateNeeded)
       return;
-    for(std::vector<Cache*>::iterator it=_parentCaches.begin(); it!=_parentCaches.end(); ++it){
+    for(std::vector<Cache*>::iterator it=_parentCaches.begin(); it!=_parentCaches.end(); it++){
       (*it)->update();
     }
     updateImpl();
@@ -98,12 +96,12 @@ namespace g2o {
     ParameterVector pv(parameterIndices.size());
     for (size_t i=0; i<parameterIndices.size(); i++){
       if (parameterIndices[i]<0 || parameterIndices[i] >=(int)_parameters.size())
-  return nullptr;
+  return 0;
       pv[i]=_parameters[ parameterIndices[i] ];
     }
     CacheKey k(type_, pv);
     if (!container())
-      return nullptr;
+      return 0;
     Cache* c=container()->findCache(k);
     if (!c) {
       c = container()->createCache(k);
@@ -117,12 +115,14 @@ namespace g2o {
     return true;
   }
 
-  CacheContainer::CacheContainer(OptimizableGraph::Vertex* vertex_) : _updateNeeded(true) { _vertex = vertex_; }
+  CacheContainer::CacheContainer(OptimizableGraph::Vertex* vertex_) {
+    _vertex = vertex_;
+  }
 
   Cache* CacheContainer::findCache(const Cache::CacheKey& key) {
     iterator it=find(key);
     if (it==end())
-      return nullptr;
+      return 0;
     return it->second;
   }
   
@@ -130,24 +130,24 @@ namespace g2o {
     Factory* f = Factory::instance();
     HyperGraph::HyperGraphElement* e = f->construct(key.type());
     if (!e) {
-      cerr << __PRETTY_FUNCTION__ << endl;
-      cerr << "fatal error in creating cache of type " << key.type() << endl;
-      return nullptr;
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+      std::cerr << "fatal error in creating cache of type " << key.type() << std::endl;
+      return 0;
     }
     Cache* c = dynamic_cast<Cache*>(e);
     if (! c){
-      cerr << __PRETTY_FUNCTION__ << endl;
-      cerr << "fatal error in creating cache of type " << key.type() << endl;
-      return nullptr;
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+      std::cerr << "fatal error in creating cache of type " << key.type() << std::endl;
+      return 0;
     }
     c->_container = this;
     c->_parameters = key._parameters;
     if (c->resolveDependancies()){
-      insert(make_pair(key,c));
+      insert(std::make_pair(key,c));
       c->update();
       return c;
     } 
-    return nullptr;
+    return 0;
   }
   
   OptimizableGraph::Vertex* CacheContainer::vertex() {
@@ -157,11 +157,11 @@ namespace g2o {
   OptimizableGraph* CacheContainer::graph(){
     if (_vertex)
       return _vertex->graph();
-    return nullptr;
+    return 0;
   }
 
   void CacheContainer::update() {
-    for (iterator it=begin(); it!=end(); ++it){
+    for (iterator it=begin(); it!=end(); it++){
       (it->second)->update();
     }
     _updateNeeded=false;
diff --git a/g2o/core/cache.h b/g2o/core/cache.h
index cd29f570..c5b00a49 100644
--- a/g2o/core/cache.h
+++ b/g2o/core/cache.h
@@ -30,17 +30,16 @@
 #include <map>
 
 #include "optimizable_graph.h"
-#include "g2o_core_api.h"
 
 namespace g2o {
 
   class CacheContainer;
   
-  class G2O_CORE_API Cache: public HyperGraph::HyperGraphElement
+  class  Cache: public HyperGraph::HyperGraphElement
   {
     public:
       friend class CacheContainer;
-      class G2O_CORE_API CacheKey
+      class  CacheKey
       {
         public:
           friend class CacheContainer;
@@ -101,7 +100,7 @@ namespace g2o {
       CacheContainer* _container;
   };
 
-  class G2O_CORE_API CacheContainer: public std::map<Cache::CacheKey, Cache*>
+  class  CacheContainer: public std::map<Cache::CacheKey, Cache*>
   {
     public:
       CacheContainer(OptimizableGraph::Vertex* vertex_);
diff --git a/g2o/core/creators.h b/g2o/core/creators.h
index 250849ee..9ca9967c 100644
--- a/g2o/core/creators.h
+++ b/g2o/core/creators.h
@@ -38,7 +38,7 @@ namespace g2o
   /**
    * \brief Abstract interface for allocating HyperGraphElement
    */
-  class G2O_CORE_API AbstractHyperGraphElementCreator
+  class  AbstractHyperGraphElementCreator
   {
     public:
       /**
diff --git a/g2o/core/dynamic_aligned_buffer.hpp b/g2o/core/dynamic_aligned_buffer.hpp
deleted file mode 100644
index 65a1598b..00000000
--- a/g2o/core/dynamic_aligned_buffer.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-#pragma once
-
-#include <cstddef>
-
-#include "Eigen/Core"
-
-namespace g2o
-{
-    // 16 byte aligned allocation functions
-    template<typename Type>
-    Type* allocate_aligned(size_t n)
-    {
-        return (Type*)Eigen::internal::aligned_malloc(n * sizeof(Type));
-    }
-
-    template<typename Type>
-    Type* reallocate_aligned(Type* ptr, size_t newSize, size_t oldSize)
-    {
-        return (Type*)Eigen::internal::aligned_realloc(ptr, newSize * sizeof(Type), oldSize * sizeof(Type));
-    }
-
-    template<typename Type>
-    void free_aligned(Type* block)
-    {
-        Eigen::internal::aligned_free(block);
-    }
-
-    template<typename Type>
-    struct dynamic_aligned_buffer
-    {
-        explicit dynamic_aligned_buffer(size_t size)
-            : m_size{ 0 }, m_ptr{ nullptr }
-        {
-            allocate(size);
-        }
-
-        ~dynamic_aligned_buffer()
-        {
-            free();
-        }
-
-        Type* request(size_t n)
-        {
-            if (n <= m_size)
-                return m_ptr;
-
-            m_ptr = reallocate_aligned<Type>(m_ptr, n, m_size);
-            m_size = m_ptr ? n : 0;
-
-            return m_ptr;
-        }
-
-    private:
-        void allocate(size_t size)
-        {
-            m_ptr = allocate_aligned<Type>(size);
-            if (m_ptr != nullptr)
-                m_size = size;
-        }
-
-        void free()
-        {
-            if (m_ptr != nullptr)
-            {
-                free_aligned<Type>(m_ptr);
-                m_size = 0;
-                m_ptr = nullptr;
-            }
-        }
-
-        std::size_t m_size;
-        Type* m_ptr;
-    };
-
-    template<typename T>
-    struct aligned_deleter
-    {
-        void operator()(T* block)
-        {
-            free_aligned(block);
-        }
-    };
-}
diff --git a/g2o/core/eigen_types.h b/g2o/core/eigen_types.h
index e6bf47d2..f2c68565 100644
--- a/g2o/core/eigen_types.h
+++ b/g2o/core/eigen_types.h
@@ -30,8 +30,6 @@
 #include <Eigen/Core>
 #include <Eigen/Geometry>
 
-#include "g2o/config.h"
-
 namespace g2o {
 
   typedef Eigen::Matrix<int,2,1,Eigen::ColMajor>                                  Vector2I;
@@ -44,14 +42,10 @@ namespace g2o {
   typedef Eigen::Matrix<float,4,1,Eigen::ColMajor>                                Vector4F; 
   typedef Eigen::Matrix<float,Eigen::Dynamic,1,Eigen::ColMajor>                   VectorXF; 
 
-  template<int N>
-  using VectorN = Eigen::Matrix<number_t, N, 1, Eigen::ColMajor>;
-  using Vector2 = VectorN<2>;
-  using Vector3 = VectorN<3>;
-  using Vector4 = VectorN<4>;
-  using Vector6 = VectorN<6>;
-  using Vector7 = VectorN<7>;
-  using VectorX = VectorN<Eigen::Dynamic>;
+  typedef Eigen::Matrix<double,2,1,Eigen::ColMajor>                               Vector2D;
+  typedef Eigen::Matrix<double,3,1,Eigen::ColMajor>                               Vector3D;
+  typedef Eigen::Matrix<double,4,1,Eigen::ColMajor>                               Vector4D;
+  typedef Eigen::Matrix<double,Eigen::Dynamic,1,Eigen::ColMajor>                  VectorXD;
 
   typedef Eigen::Matrix<int,2,2,Eigen::ColMajor>                                  Matrix2I;
   typedef Eigen::Matrix<int,3,3,Eigen::ColMajor>                                  Matrix3I;
@@ -63,24 +57,16 @@ namespace g2o {
   typedef Eigen::Matrix<float,4,4,Eigen::ColMajor>                                Matrix4F;
   typedef Eigen::Matrix<float,Eigen::Dynamic,Eigen::Dynamic,Eigen::ColMajor>      MatrixXF;
 
-  template<int N>
-  using MatrixN = Eigen::Matrix<number_t, N, N, Eigen::ColMajor>;
-  using Matrix2 = MatrixN<2>;
-  using Matrix3 = MatrixN<3>;
-  using Matrix4 = MatrixN<4>;
-  using MatrixX = MatrixN<Eigen::Dynamic>;
-
-  typedef Eigen::Transform<number_t,2,Eigen::Isometry,Eigen::ColMajor>            Isometry2;
-  typedef Eigen::Transform<number_t,3,Eigen::Isometry,Eigen::ColMajor>            Isometry3;
-
-  typedef Eigen::Transform<number_t,2,Eigen::Affine,Eigen::ColMajor>              Affine2;
-  typedef Eigen::Transform<number_t,3,Eigen::Affine,Eigen::ColMajor>              Affine3;
-
-  typedef Eigen::Rotation2D<number_t>                                             Rotation2D;
+  typedef Eigen::Matrix<double,2,2,Eigen::ColMajor>                               Matrix2D;
+  typedef Eigen::Matrix<double,3,3,Eigen::ColMajor>                               Matrix3D;
+  typedef Eigen::Matrix<double,4,4,Eigen::ColMajor>                               Matrix4D;
+  typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic,Eigen::ColMajor>     MatrixXD;
 
-  typedef Eigen::Quaternion<number_t>                                             Quaternion;
+  typedef Eigen::Transform<double,2,Eigen::Isometry,Eigen::ColMajor>              Isometry2D;
+  typedef Eigen::Transform<double,3,Eigen::Isometry,Eigen::ColMajor>              Isometry3D;
 
-  typedef Eigen::AngleAxis<number_t>                                              AngleAxis;
+  typedef Eigen::Transform<double,2,Eigen::Affine,Eigen::ColMajor>                Affine2D;
+  typedef Eigen::Transform<double,3,Eigen::Affine,Eigen::ColMajor>                Affine3D;
 
 } // end namespace g2o
 
diff --git a/g2o/core/estimate_propagator.cpp b/g2o/core/estimate_propagator.cpp
index 0b506df9..52f77e42 100644
--- a/g2o/core/estimate_propagator.cpp
+++ b/g2o/core/estimate_propagator.cpp
@@ -35,7 +35,7 @@
 
 //#define DEBUG_ESTIMATE_PROPAGATOR
 
-using namespace std;
+
 
 namespace g2o {
 
@@ -58,7 +58,7 @@ namespace g2o {
     _child = 0;
     _parent.clear();
     _edge = 0;
-    _distance = numeric_limits<number_t>::max();
+    _distance = std::numeric_limits<double>::max();
     _frontierLevel = -1;
     inQueue = false;
   }
@@ -68,7 +68,7 @@ namespace g2o {
     for (OptimizableGraph::VertexIDMap::const_iterator it=_graph->vertices().begin(); it!=_graph->vertices().end(); ++it){
       AdjacencyMapEntry entry;
       entry._child = static_cast<OptimizableGraph::Vertex*>(it->second);
-      _adjacencyMap.insert(make_pair(entry.child(), entry));
+      _adjacencyMap.insert(std::make_pair(entry.child(), entry));
     }
   }
 
@@ -86,8 +86,8 @@ namespace g2o {
   void EstimatePropagator::propagate(OptimizableGraph::Vertex* v, 
       const EstimatePropagator::PropagateCost& cost, 
        const EstimatePropagator::PropagateAction& action,
-       number_t maxDistance, 
-       number_t maxEdgeCost)
+       double maxDistance, 
+       double maxEdgeCost)
   {
     OptimizableGraph::VertexSet vset;
     vset.insert(v);
@@ -97,8 +97,8 @@ namespace g2o {
   void EstimatePropagator::propagate(OptimizableGraph::VertexSet& vset, 
       const EstimatePropagator::PropagateCost& cost, 
        const EstimatePropagator::PropagateAction& action,
-       number_t maxDistance, 
-       number_t maxEdgeCost)
+       double maxDistance, 
+       double maxEdgeCost)
   {
     reset();
 
@@ -116,8 +116,8 @@ namespace g2o {
     while(! frontier.empty()){
       AdjacencyMapEntry* entry = frontier.pop();
       OptimizableGraph::Vertex* u = entry->child();
-      number_t uDistance = entry->distance();
-      //cerr << "uDistance " << uDistance << endl;
+      double uDistance = entry->distance();
+      //std::cerr << "uDistance " << uDistance << std::endl;
 
       // initialize the vertex
       if (entry->_frontierLevel > 0) {
@@ -134,35 +134,32 @@ namespace g2o {
         OptimizableGraph::VertexSet initializedVertices;
         for (size_t i = 0; i < edge->vertices().size(); ++i) {
           OptimizableGraph::Vertex* z = static_cast<OptimizableGraph::Vertex*>(edge->vertex(i));
-	  if (! z)
-	    continue;
           AdjacencyMap::iterator ot = _adjacencyMap.find(z);
-          if (ot->second._distance != numeric_limits<number_t>::max()) {
+          if (ot->second._distance != std::numeric_limits<double>::max()) {
             initializedVertices.insert(z);
-            maxFrontier = (max)(maxFrontier, ot->second._frontierLevel);
+            maxFrontier = (std::max)(maxFrontier, ot->second._frontierLevel);
           }
         }
         assert(maxFrontier >= 0);
 
         for (size_t i = 0; i < edge->vertices().size(); ++i) {
           OptimizableGraph::Vertex* z = static_cast<OptimizableGraph::Vertex*>(edge->vertex(i));
-	  if (! z)
-	    continue;
           if (z == u)
             continue;
+
           size_t wasInitialized = initializedVertices.erase(z);
 
-          number_t edgeDistance = cost(edge, initializedVertices, z);
-          if (edgeDistance > 0. && edgeDistance != std::numeric_limits<number_t>::max() && edgeDistance < maxEdgeCost) {
-            number_t zDistance = uDistance + edgeDistance;
-            //cerr << z->id() << " " << zDistance << endl;
+          double edgeDistance = cost(edge, initializedVertices, z);
+          if (edgeDistance > 0. && edgeDistance != std::numeric_limits<double>::max() && edgeDistance < maxEdgeCost) {
+            double zDistance = uDistance + edgeDistance;
+            //std::cerr << z->id() << " " << zDistance << std::endl;
 
             AdjacencyMap::iterator ot = _adjacencyMap.find(z);
             assert(ot!=_adjacencyMap.end());
 
             if (zDistance < ot->second.distance() && zDistance < maxDistance){
               //if (ot->second.inQueue)
-                //cerr << "Updating" << endl;
+                //std::cerr << "Updating" << std::endl;
               ot->second._distance = zDistance;
               ot->second._parent = initializedVertices;
               ot->second._edge = edge;
@@ -180,21 +177,21 @@ namespace g2o {
 
     // writing debug information like cost for reaching each vertex and the parent used to initialize
 #ifdef DEBUG_ESTIMATE_PROPAGATOR
-    cerr << "Writing cost.dat" << endl;
+    std::cerr << "Writing cost.dat" << std::endl;
     ofstream costStream("cost.dat");
     for (AdjacencyMap::const_iterator it = _adjacencyMap.begin(); it != _adjacencyMap.end(); ++it) {
       HyperGraph::Vertex* u = it->second.child();
-      costStream << "vertex " << u->id() << "  cost " << it->second._distance << endl;
+      costStream << "vertex " << u->id() << "  cost " << it->second._distance << std::endl;
     }
-    cerr << "Writing init.dat" << endl;
+    std::cerr << "Writing init.dat" << std::endl;
     ofstream initStream("init.dat");
-    vector<AdjacencyMapEntry*> frontierLevels;
+    std::vector<AdjacencyMapEntry*> frontierLevels;
     for (AdjacencyMap::iterator it = _adjacencyMap.begin(); it != _adjacencyMap.end(); ++it) {
       if (it->second._frontierLevel > 0)
         frontierLevels.push_back(&it->second);
     }
     sort(frontierLevels.begin(), frontierLevels.end(), FrontierLevelCmp());
-    for (vector<AdjacencyMapEntry*>::const_iterator it = frontierLevels.begin(); it != frontierLevels.end(); ++it) {
+    for (std::vector<AdjacencyMapEntry*>::const_iterator it = frontierLevels.begin(); it != frontierLevels.end(); ++it) {
       AdjacencyMapEntry* entry       = *it;
       OptimizableGraph::Vertex* to   = entry->child();
 
@@ -202,7 +199,7 @@ namespace g2o {
       for (OptimizableGraph::VertexSet::iterator pit = entry->parent().begin(); pit != entry->parent().end(); ++pit) {
         initStream << " " << (*pit)->id();
       }
-      initStream << " ) -> " << to->id() << endl;
+      initStream << " ) -> " << to->id() << std::endl;
     }
 #endif
 
@@ -210,7 +207,7 @@ namespace g2o {
 
   void EstimatePropagator::PriorityQueue::push(AdjacencyMapEntry* entry)
   {
-    assert(entry != NULL);
+    assert(entry != nullptr);
     if (entry->inQueue) {
       assert(entry->queueIt->second == entry);
       erase(entry->queueIt);
@@ -228,7 +225,7 @@ namespace g2o {
     AdjacencyMapEntry* entry = it->second;
     erase(it);
 
-    assert(entry != NULL);
+    assert(entry != nullptr);
     entry->queueIt = end();
     entry->inQueue = false;
     return entry;
@@ -239,13 +236,13 @@ namespace g2o {
   {
   }
 
-  number_t EstimatePropagatorCost::operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to_) const
+  double EstimatePropagatorCost::operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to_) const
   {
     OptimizableGraph::Edge* e = dynamic_cast<OptimizableGraph::Edge*>(edge);
     OptimizableGraph::Vertex* to = dynamic_cast<OptimizableGraph::Vertex*>(to_);
     SparseOptimizer::EdgeContainer::const_iterator it = _graph->findActiveEdge(e);
     if (it == _graph->activeEdges().end()) // it has to be an active edge
-      return std::numeric_limits<number_t>::max();
+      return std::numeric_limits<double>::max();
     return e->initialEstimatePossible(from, to);
   }
 
@@ -254,16 +251,16 @@ namespace g2o {
   {
   }
 
-  number_t EstimatePropagatorCostOdometry::operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* to_) const
+  double EstimatePropagatorCostOdometry::operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* to_) const
   {
     OptimizableGraph::Edge* e = dynamic_cast<OptimizableGraph::Edge*>(edge);
     OptimizableGraph::Vertex* from = dynamic_cast<OptimizableGraph::Vertex*>(*from_.begin());
     OptimizableGraph::Vertex* to = dynamic_cast<OptimizableGraph::Vertex*>(to_);
     if (std::abs(from->id() - to->id()) != 1) // simple method to identify odometry edges in a pose graph
-      return std::numeric_limits<number_t>::max();
+      return std::numeric_limits<double>::max();
     SparseOptimizer::EdgeContainer::const_iterator it = _graph->findActiveEdge(e);
     if (it == _graph->activeEdges().end()) // it has to be an active edge
-      return std::numeric_limits<number_t>::max();
+      return std::numeric_limits<double>::max();
     return e->initialEstimatePossible(from_, to);
   }
 
diff --git a/g2o/core/estimate_propagator.h b/g2o/core/estimate_propagator.h
index 5e107776..6a16d11d 100644
--- a/g2o/core/estimate_propagator.h
+++ b/g2o/core/estimate_propagator.h
@@ -29,12 +29,16 @@
 
 #include "optimizable_graph.h"
 #include "sparse_optimizer.h"
-#include "g2o_core_api.h"
 
 #include <map>
+#include <set>
 #include <limits>
 
+#ifdef _MSC_VER
 #include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
 
 namespace g2o {
 
@@ -43,10 +47,10 @@ namespace g2o {
    *
    * You may derive an own one, if necessary. The default is to return initialEstimatePossible(from, to) for the edge.
    */
-  class G2O_CORE_API EstimatePropagatorCost {
+  class  EstimatePropagatorCost {
     public:
       EstimatePropagatorCost (SparseOptimizer* graph);
-      virtual number_t operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to_) const;
+      virtual double operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to_) const;
       virtual const char* name() const { return "spanning tree";}
     protected:
       SparseOptimizer* _graph;
@@ -58,17 +62,17 @@ namespace g2o {
    * Initialize your graph along odometry edges. An odometry edge is assumed to connect vertices
    * whose IDs only differs by one.
    */
-  class G2O_CORE_API EstimatePropagatorCostOdometry : public EstimatePropagatorCost {
+  class  EstimatePropagatorCostOdometry : public EstimatePropagatorCost {
     public:
       EstimatePropagatorCostOdometry(SparseOptimizer* graph);
-      virtual number_t operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* to_) const;
+      virtual double operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* to_) const;
       virtual const char* name() const { return "odometry";}
   };
 
   /**
    * \brief propagation of an initial guess
    */
-  class G2O_CORE_API EstimatePropagator {
+  class  EstimatePropagator {
     public:
 
       /**
@@ -91,7 +95,7 @@ namespace g2o {
       /**
        * \brief priority queue for AdjacencyMapEntry
        */
-      class PriorityQueue : public std::multimap<number_t, AdjacencyMapEntry*> {
+      class PriorityQueue : public std::multimap<double, AdjacencyMapEntry*> {
         public:
           void push(AdjacencyMapEntry* entry);
           AdjacencyMapEntry* pop();
@@ -109,14 +113,14 @@ namespace g2o {
           OptimizableGraph::Vertex* child() const {return _child;}
           const OptimizableGraph::VertexSet& parent() const {return _parent;}
           OptimizableGraph::Edge* edge() const {return _edge;}
-          number_t distance() const {return _distance;}
+          double distance() const {return _distance;}
           int frontierLevel() const { return _frontierLevel;}
 
         protected:
           OptimizableGraph::Vertex* _child;
           OptimizableGraph::VertexSet _parent;
           OptimizableGraph::Edge* _edge;
-          number_t _distance;
+          double _distance;
           int _frontierLevel;
         private: // for PriorityQueue
           bool inQueue;
@@ -131,7 +135,7 @@ namespace g2o {
           size_t operator ()(const OptimizableGraph::Vertex* v) const { return v->id();}
       };
 
-      typedef std::unordered_map<OptimizableGraph::Vertex*, AdjacencyMapEntry, VertexIDHashFunction> AdjacencyMap;
+      typedef std::tr1::unordered_map<OptimizableGraph::Vertex*, AdjacencyMapEntry, VertexIDHashFunction> AdjacencyMap;
 
     public:
       EstimatePropagator(OptimizableGraph* g);
@@ -147,8 +151,8 @@ namespace g2o {
       void propagate(OptimizableGraph::Vertex* v, 
           const EstimatePropagator::PropagateCost& cost, 
           const EstimatePropagator::PropagateAction& action = PropagateAction(),
-          number_t maxDistance=std::numeric_limits<number_t>::max(), 
-          number_t maxEdgeCost=std::numeric_limits<number_t>::max());
+          double maxDistance=std::numeric_limits<double>::max(), 
+          double maxEdgeCost=std::numeric_limits<double>::max());
 
       /**
        * same as above but starting to propagate from a set of vertices instead of just a single one.
@@ -156,8 +160,8 @@ namespace g2o {
       void propagate(OptimizableGraph::VertexSet& vset, 
           const EstimatePropagator::PropagateCost& cost, 
           const EstimatePropagator::PropagateAction& action = PropagateAction(),
-          number_t maxDistance=std::numeric_limits<number_t>::max(), 
-          number_t maxEdgeCost=std::numeric_limits<number_t>::max());
+          double maxDistance=std::numeric_limits<double>::max(), 
+          double maxEdgeCost=std::numeric_limits<double>::max());
 
     protected:
       void reset();
diff --git a/g2o/core/factory.cpp b/g2o/core/factory.cpp
index f7a760e2..79123821 100644
--- a/g2o/core/factory.cpp
+++ b/g2o/core/factory.cpp
@@ -30,13 +30,13 @@
 #include "parameter.h"
 #include "cache.h"
 #include "optimizable_graph.h"
-#include "g2o/stuff/color_macros.h"
+#include "../stuff/color_macros.h"
 
 #include <iostream>
 #include <typeinfo>
 #include <cassert>
 
-using namespace std;
+
 
 namespace g2o {
 
@@ -49,7 +49,7 @@ Factory::Factory()
 Factory::~Factory()
 {
 # ifdef G2O_DEBUG_FACTORY
-  cerr << "# Factory destroying " << (void*)this << endl;
+  std::cerr << "# Factory destroying " << (void*)this << std::endl;
 # endif
   for (CreatorMap::iterator it = _creator.begin(); it != _creator.end(); ++it) {
     delete it->second->creator;
@@ -63,7 +63,7 @@ Factory* Factory::instance()
   if (factoryInstance == 0) {
     factoryInstance = new Factory;
 #  ifdef G2O_DEBUG_FACTORY
-    cerr << "# Factory allocated " << (void*)factoryInstance << endl;
+    std::cerr << "# Factory allocated " << (void*)factoryInstance << std::endl;
 #  endif
   }
 
@@ -74,12 +74,12 @@ void Factory::registerType(const std::string& tag, AbstractHyperGraphElementCrea
 {
   CreatorMap::const_iterator foundIt = _creator.find(tag);
   if (foundIt != _creator.end()) {
-    cerr << "FACTORY WARNING: Overwriting Vertex tag " << tag << endl;
+    std::cerr << "FACTORY WARNING: Overwriting Vertex tag " << tag << std::endl;
     assert(0);
   }
   TagLookup::const_iterator tagIt = _tagLookup.find(c->name());
   if (tagIt != _tagLookup.end()) {
-    cerr << "FACTORY WARNING: Registering same class for two tags " << c->name() << endl;
+    std::cerr << "FACTORY WARNING: Registering same class for two tags " << c->name() << std::endl;
     assert(0);
   }
 
@@ -87,37 +87,37 @@ void Factory::registerType(const std::string& tag, AbstractHyperGraphElementCrea
   ci->creator = c;
 
 #ifdef G2O_DEBUG_FACTORY
-  cerr << "# Factory " << (void*)this << " constructing type " << tag << " ";
+  std::cerr << "# Factory " << (void*)this << " constructing type " << tag << " ";
 #endif
   // construct an element once to figure out its type
   HyperGraph::HyperGraphElement* element = c->construct();
   ci->elementTypeBit = element->elementType();
 
 #ifdef G2O_DEBUG_FACTORY
-  cerr << "done." << endl;
-  cerr << "# Factory " << (void*)this << " registering " << tag;
-  cerr << " " << (void*) c << " ";
+  std::cerr << "done." << std::endl;
+  std::cerr << "# Factory " << (void*)this << " registering " << tag;
+  std::cerr << " " << (void*) c << " ";
   switch (element->elementType()) {
     case HyperGraph::HGET_VERTEX:
-      cerr << " -> Vertex";
+      std::cerr << " -> Vertex";
       break;
     case HyperGraph::HGET_EDGE:
-      cerr << " -> Edge";
+      std::cerr << " -> Edge";
       break;
     case HyperGraph::HGET_PARAMETER:
-      cerr << " -> Parameter";
+      std::cerr << " -> Parameter";
       break;
     case HyperGraph::HGET_CACHE:
-      cerr << " -> Cache";
+      std::cerr << " -> Cache";
       break;
     case HyperGraph::HGET_DATA:
-      cerr << " -> Data";
+      std::cerr << " -> Data";
       break;
     default:
       assert(0 && "Unknown element type occured, fix elementTypes");
       break;
   }
-  cerr << endl;
+  std::cerr << std::endl;
 #endif
 
   _creator[tag] = ci;
@@ -148,10 +148,10 @@ HyperGraph::HyperGraphElement* Factory::construct(const std::string& tag) const
 {
   CreatorMap::const_iterator foundIt = _creator.find(tag);
   if (foundIt != _creator.end()) {
-    //cerr << "tag " << tag << " -> " << (void*) foundIt->second->creator << " " << foundIt->second->creator->name() << endl;
+    //std::cerr << "tag " << tag << " -> " << (void*) foundIt->second->creator << " " << foundIt->second->creator->name() << std::endl;
     return foundIt->second->creator->construct();
   }
-  return nullptr;
+  return 0;
 }
 
 const std::string& Factory::tag(const HyperGraph::HyperGraphElement* e) const
@@ -193,11 +193,11 @@ void Factory::printRegisteredTypes(std::ostream& os, bool comment) const
 {
   if (comment)
     os << "# ";
-  os << "types:" << endl;
+  os << "types:" << std::endl;
   for (CreatorMap::const_iterator it = _creator.begin(); it != _creator.end(); ++it) {
     if (comment)
       os << "#";
-    cerr << "\t" << it->first << endl;
+    std::cerr << "\t" << it->first << std::endl;
   }
 }
 
@@ -210,7 +210,7 @@ HyperGraph::HyperGraphElement* Factory::construct(const std::string& tag, const
   if (foundIt != _creator.end() && foundIt->second->elementTypeBit >= 0 && elemsToConstruct.test(foundIt->second->elementTypeBit)) {
     return foundIt->second->creator->construct();
   }
-  return nullptr;
+  return 0;
 }
 
 } // end namespace
diff --git a/g2o/core/factory.h b/g2o/core/factory.h
index bedb5206..2e8f5c89 100644
--- a/g2o/core/factory.h
+++ b/g2o/core/factory.h
@@ -28,6 +28,7 @@
 #define G2O_FACTORY_H
 
 #include "g2o/config.h"
+#include "../stuff/misc.h"
 #include "hyper_graph.h"
 #include "creators.h"
 
@@ -40,11 +41,12 @@
 
 namespace g2o {
 
+  class AbstractHyperGraphElementCreator;
   
   /**
    * \brief create vertices and edges based on TAGs in, for example, a file
    */
-  class G2O_CORE_API Factory
+  class  Factory
   {
     public:
 
@@ -134,8 +136,7 @@ namespace g2o {
 #ifdef G2O_DEBUG_FACTORY
         std::cout << __FUNCTION__ << ": Registering " << _name << " of type " << typeid(T).name() << std::endl;
 #endif
-        _creator = new HyperGraphElementCreator<T>();
-        Factory::instance()->registerType(_name, _creator);
+        Factory::instance()->registerType(_name, new HyperGraphElementCreator<T>());
       }
 
       ~RegisterTypeProxy()
@@ -144,12 +145,10 @@ namespace g2o {
         std::cout << __FUNCTION__ << ": Unregistering " << _name << " of type " << typeid(T).name() << std::endl;
 #endif
         Factory::instance()->unregisterType(_name);
-        delete _creator;
       }
 
     private:
       std::string _name;
-      HyperGraphElementCreator<T>* _creator;
   };
 
 #if defined _MSC_VER && defined G2O_SHARED_LIBS
diff --git a/g2o/core/g2o_core_api.h b/g2o/core/g2o_core_api.h
deleted file mode 100644
index ee93a044..00000000
--- a/g2o/core/g2o_core_api.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_CORE_API_H
-#define G2O_CORE_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef core_EXPORTS
-#define G2O_CORE_API __declspec(dllexport)
-#else
-#define G2O_CORE_API __declspec(dllimport)
-#endif
-#else
-#define G2O_CORE_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_CORE_API
-#endif
-
-#endif // G2O_CORE_API_H
diff --git a/g2o/core/hyper_dijkstra.cpp b/g2o/core/hyper_dijkstra.cpp
index 2453529c..97d47353 100644
--- a/g2o/core/hyper_dijkstra.cpp
+++ b/g2o/core/hyper_dijkstra.cpp
@@ -30,43 +30,48 @@
 #include <assert.h>
 #include <iostream>
 #include "hyper_dijkstra.h"
-#include "g2o/stuff/macros.h"
+#include "../stuff/macros.h"
 
 namespace g2o{
 
-  using namespace std;
   
-  number_t HyperDijkstra::TreeAction::perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e){
+
+  double HyperDijkstra::TreeAction::perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e){
     (void) v;
     (void) vParent;
     (void) e;
-    return std::numeric_limits<number_t>::max();
+    return std::numeric_limits<double>::max();
   }
 
-  number_t HyperDijkstra::TreeAction::perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e, number_t distance){
+  double HyperDijkstra::TreeAction::perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e, double distance){
     if (distance==-1)
       return perform (v,vParent,e);
-    return std::numeric_limits<number_t>::max();
+    return std::numeric_limits<double>::max();
   }
 
   HyperDijkstra::AdjacencyMapEntry::AdjacencyMapEntry(HyperGraph::Vertex* child_, HyperGraph::Vertex* parent_, 
-                                                      HyperGraph::Edge* edge_, number_t distance_)
-      : _child(child_), _parent(parent_), _edge(edge_), _distance(distance_) {}
+      HyperGraph::Edge* edge_, double distance_)
+  {
+    _child=child_;
+    _parent=parent_;
+    _edge=edge_;
+    _distance=distance_;
+  }
 
   HyperDijkstra::HyperDijkstra(HyperGraph* g): _graph(g)
   {
-    for (HyperGraph::VertexIDMap::const_iterator it=_graph->vertices().begin(); it!=_graph->vertices().end(); ++it){
-      AdjacencyMapEntry entry(it->second, 0,0,std::numeric_limits< number_t >::max());
-      _adjacencyMap.insert(make_pair(entry.child(), entry));
+    for (HyperGraph::VertexIDMap::const_iterator it=_graph->vertices().begin(); it!=_graph->vertices().end(); it++){
+      AdjacencyMapEntry entry(it->second, 0,0,std::numeric_limits< double >::max());
+      _adjacencyMap.insert(std::make_pair(entry.child(), entry));
     }
   }
 
   void HyperDijkstra::reset()
   {
-    for (HyperGraph::VertexSet::iterator it=_visited.begin(); it!=_visited.end(); ++it){
+    for (HyperGraph::VertexSet::iterator it=_visited.begin(); it!=_visited.end(); it++){
       AdjacencyMap::iterator at=_adjacencyMap.find(*it);
       assert(at!=_adjacencyMap.end());
-      at->second=AdjacencyMapEntry(at->first,0,0,std::numeric_limits< number_t >::max());
+      at->second=AdjacencyMapEntry(at->first,0,0,std::numeric_limits< double >::max());
     }
     _visited.clear();
   }
@@ -79,7 +84,7 @@ namespace g2o{
 
 
   void HyperDijkstra::shortestPaths(HyperGraph::VertexSet& vset, HyperDijkstra::CostFunction* cost, 
-      number_t maxDistance, number_t comparisonConditioner, bool directed, number_t maxEdgeCost)
+      double maxDistance, double comparisonConditioner, bool directed, double maxEdgeCost)
   {
     reset();
     std::priority_queue< AdjacencyMapEntry > frontier;
@@ -88,7 +93,7 @@ namespace g2o{
       assert(v!=0);
       AdjacencyMap::iterator it=_adjacencyMap.find(v);
       if (it == _adjacencyMap.end()) {
-        cerr << __PRETTY_FUNCTION__ << "Vertex " << v->id() << " is not in the adjacency map" << endl;
+        std::cerr << __PRETTY_FUNCTION__ << "Vertex " << v->id() << " is not in the adjacency map" << std::endl;
       }
       assert(it!=_adjacencyMap.end());
       it->second._distance=0.;
@@ -102,10 +107,10 @@ namespace g2o{
       HyperGraph::Vertex* u=entry.child();
       AdjacencyMap::iterator ut=_adjacencyMap.find(u);
       if (ut == _adjacencyMap.end()) {
-        cerr << __PRETTY_FUNCTION__ << "Vertex " << u->id() << " is not in the adjacency map" << endl;
+        std::cerr << __PRETTY_FUNCTION__ << "Vertex " << u->id() << " is not in the adjacency map" << std::endl;
       }
       assert(ut!=_adjacencyMap.end());
-      number_t uDistance=ut->second.distance();
+      double uDistance=ut->second.distance();
 
       std::pair< HyperGraph::VertexSet::iterator, bool> insertResult=_visited.insert(u); (void) insertResult;
       HyperGraph::EdgeSet::iterator et=u->edges().begin();
@@ -121,11 +126,11 @@ namespace g2o{
           if (z == u)
             continue;
 
-          number_t edgeDistance=(*cost)(edge, u, z);
-          if (edgeDistance==std::numeric_limits< number_t >::max() || edgeDistance > maxEdgeCost)
+          double edgeDistance=(*cost)(edge, u, z);
+          if (edgeDistance==std::numeric_limits< double >::max() || edgeDistance > maxEdgeCost)
             continue;
-          number_t zDistance=uDistance+edgeDistance;
-          //cerr << z->id() << " " << zDistance << endl;
+          double zDistance=uDistance+edgeDistance;
+          //std::cerr << z->id() << " " << zDistance << std::endl;
 
           AdjacencyMap::iterator ot=_adjacencyMap.find(z);
           assert(ot!=_adjacencyMap.end());
@@ -141,8 +146,8 @@ namespace g2o{
     }
   }
 
-  void HyperDijkstra::shortestPaths(HyperGraph::Vertex* v, HyperDijkstra::CostFunction* cost, number_t maxDistance,
-      number_t comparisonConditioner, bool directed, number_t maxEdgeCost)
+  void HyperDijkstra::shortestPaths(HyperGraph::Vertex* v, HyperDijkstra::CostFunction* cost, double maxDistance, 
+      double comparisonConditioner, bool directed, double maxEdgeCost)
   {
     HyperGraph::VertexSet vset;
     vset.insert(v);
@@ -185,7 +190,7 @@ namespace g2o{
       }
     }
 
-    //std::cerr << "q.size()" << q.size() << endl;
+    //std::cerr << "q.size()" << q.size() << std::endl;
     int count=0;
     while (! q.empty()){
       HyperGraph::Vertex* parent=q.front();
@@ -195,11 +200,11 @@ namespace g2o{
       if (parentIt==amap.end()) {
         continue;
       }
-      //cerr << "parent= " << parent << " parent id= " << parent->id() << "\t children id =";
+      //std::cerr << "parent= " << parent << " parent id= " << parent->id() << "\t children id =";
       HyperGraph::VertexSet& childs(parentIt->second.children());
       for (HyperGraph::VertexSet::iterator childsIt=childs.begin(); childsIt!=childs.end(); ++childsIt){
         HyperGraph::Vertex* child=*childsIt;
-        //cerr << child->id();
+        //std::cerr << child->id();
         AdjacencyMap::iterator adjacencyIt=amap.find(child);
         assert (adjacencyIt!=amap.end());
         HyperGraph::Edge* edge=adjacencyIt->second.edge();  
@@ -214,7 +219,7 @@ namespace g2o{
         }
         q.push_back(child);
       }
-      //cerr << endl;
+      //std::cerr << std::endl;
     }
 
   }
@@ -222,8 +227,8 @@ namespace g2o{
   void HyperDijkstra::connectedSubset(HyperGraph::VertexSet& connected, HyperGraph::VertexSet& visited, 
       HyperGraph::VertexSet& startingSet, 
       HyperGraph* g, HyperGraph::Vertex* v,
-      HyperDijkstra::CostFunction* cost, number_t distance,
-      number_t comparisonConditioner, number_t maxEdgeCost)
+      HyperDijkstra::CostFunction* cost, double distance, 
+      double comparisonConditioner, double maxEdgeCost)
   {
     typedef std::queue<HyperGraph::Vertex*> VertexDeque;
     visited.clear();
@@ -248,7 +253,7 @@ namespace g2o{
     }
   }
 
-  number_t UniformCostFunction::operator () (HyperGraph::Edge* /*edge*/, HyperGraph::Vertex* /*from*/, HyperGraph::Vertex* /*to*/)
+  double UniformCostFunction::operator () (HyperGraph::Edge* /*edge*/, HyperGraph::Vertex* /*from*/, HyperGraph::Vertex* /*to*/)
   {
     return 1.;
   }
diff --git a/g2o/core/hyper_dijkstra.h b/g2o/core/hyper_dijkstra.h
index 4c49670c..fe2c2f4b 100644
--- a/g2o/core/hyper_dijkstra.h
+++ b/g2o/core/hyper_dijkstra.h
@@ -35,35 +35,35 @@
 
 namespace g2o{
 
-  struct G2O_CORE_API HyperDijkstra{
-    struct G2O_CORE_API CostFunction {
-      virtual number_t operator() (HyperGraph::Edge* e, HyperGraph::Vertex* from, HyperGraph::Vertex* to)=0;
+  struct  HyperDijkstra{
+    struct  CostFunction {
+      virtual double operator() (HyperGraph::Edge* e, HyperGraph::Vertex* from, HyperGraph::Vertex* to)=0;
       virtual ~CostFunction() { }
     };
 
-    struct G2O_CORE_API TreeAction {
-      virtual number_t perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e);
-      virtual number_t perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e, number_t distance);
+    struct  TreeAction {
+      virtual double perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e);
+      virtual double perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e, double distance);
     };
 
     
-    struct G2O_CORE_API AdjacencyMapEntry{
+    struct  AdjacencyMapEntry{
       friend struct HyperDijkstra;
       AdjacencyMapEntry(HyperGraph::Vertex* _child=0, 
           HyperGraph::Vertex* _parent=0, 
           HyperGraph::Edge* _edge=0, 
-          number_t _distance=std::numeric_limits<number_t>::max());
+          double _distance=std::numeric_limits<double>::max());
       HyperGraph::Vertex* child() const {return _child;}
       HyperGraph::Vertex* parent() const {return _parent;}
       HyperGraph::Edge* edge() const {return _edge;}
-      number_t distance() const {return _distance;}
+      double distance() const {return _distance;}
       HyperGraph::VertexSet& children() {return _children;}
       const HyperGraph::VertexSet& children() const {return _children;}
       protected:
       HyperGraph::Vertex* _child;
       HyperGraph::Vertex* _parent;
       HyperGraph::Edge* _edge;
-      number_t _distance;
+      double _distance;
       HyperGraph::VertexSet _children;
     };
 
@@ -75,17 +75,17 @@ namespace g2o{
 
     void shortestPaths(HyperGraph::Vertex* v, 
            HyperDijkstra::CostFunction* cost, 
-           number_t maxDistance=std::numeric_limits< number_t >::max(), 
-           number_t comparisonConditioner=1e-3, 
+           double maxDistance=std::numeric_limits< double >::max(), 
+           double comparisonConditioner=1e-3, 
            bool directed=false,
-           number_t maxEdgeCost=std::numeric_limits< number_t >::max());
+           double maxEdgeCost=std::numeric_limits< double >::max());
 
     void shortestPaths(HyperGraph::VertexSet& vset, 
            HyperDijkstra::CostFunction* cost, 
-           number_t maxDistance=std::numeric_limits< number_t >::max(), 
-           number_t comparisonConditioner=1e-3, 
+           double maxDistance=std::numeric_limits< double >::max(), 
+           double comparisonConditioner=1e-3, 
            bool directed=false,
-           number_t maxEdgeCost=std::numeric_limits< number_t >::max());
+           double maxEdgeCost=std::numeric_limits< double >::max());
 
 
     static void computeTree(AdjacencyMap& amap);
@@ -93,8 +93,8 @@ namespace g2o{
     static void connectedSubset(HyperGraph::VertexSet& connected, HyperGraph::VertexSet& visited, 
            HyperGraph::VertexSet& startingSet, 
            HyperGraph* g, HyperGraph::Vertex* v,
-           HyperDijkstra::CostFunction* cost, number_t distance, number_t comparisonConditioner,
-           number_t maxEdgeCost=std::numeric_limits< number_t >::max() );
+           HyperDijkstra::CostFunction* cost, double distance, double comparisonConditioner,
+           double maxEdgeCost=std::numeric_limits< double >::max() );
 
   protected:
     void reset();
@@ -104,8 +104,8 @@ namespace g2o{
     HyperGraph* _graph;
   };
 
-  struct G2O_CORE_API UniformCostFunction: public HyperDijkstra::CostFunction {
-    virtual number_t operator ()(HyperGraph::Edge* edge, HyperGraph::Vertex* from, HyperGraph::Vertex* to);
+  struct  UniformCostFunction: public HyperDijkstra::CostFunction {
+    virtual double operator ()(HyperGraph::Edge* edge, HyperGraph::Vertex* from, HyperGraph::Vertex* to);
   };
 
 }
diff --git a/g2o/core/hyper_graph.cpp b/g2o/core/hyper_graph.cpp
index da255328..1e1ea76e 100644
--- a/g2o/core/hyper_graph.cpp
+++ b/g2o/core/hyper_graph.cpp
@@ -26,24 +26,11 @@
 
 #include "hyper_graph.h"
 
-#include "ownership.h"
-
 #include <assert.h>
 #include <queue>
-#include <unordered_set>
-#include <iterator>
 
 namespace g2o {
 
-  HyperGraph::Data::Data() {
-    _next = 0;
-    _dataContainer = 0;
-  }
-
-  HyperGraph::Data::~Data() {
-    delete _next;
-  }
-
   HyperGraph::Vertex::Vertex(int id) : _id(id)
   {
   }
@@ -60,11 +47,6 @@ namespace g2o {
   {
   }
 
-  int HyperGraph::Edge::numUndefinedVertices() const
-  {
-    return std::count_if(_vertices.begin(), _vertices.end(), [](const Vertex* ptr) { return ptr == nullptr; });
-  }
-
   void HyperGraph::Edge::resize(size_t size)
   {
     _vertices.resize(size, 0);
@@ -79,7 +61,7 @@ namespace g2o {
   {
     VertexIDMap::iterator it=_vertices.find(id);
     if (it==_vertices.end())
-      return nullptr;
+      return 0;
     return it->second;
   }
 
@@ -87,14 +69,17 @@ namespace g2o {
   {
     VertexIDMap::const_iterator it=_vertices.find(id);
     if (it==_vertices.end())
-      return nullptr;
+      return 0;
     return it->second;
   }
 
   bool HyperGraph::addVertex(Vertex* v)
   {
-    auto result = _vertices.insert(std::make_pair(v->id(), v));
-    return result.second;
+    Vertex* vn=vertex(v->id());
+    if (vn)
+      return false;
+    _vertices.insert( std::make_pair(v->id(),v) );
+    return true;
   }
 
   /**
@@ -113,100 +98,18 @@ namespace g2o {
 
   bool HyperGraph::addEdge(Edge* e)
   {
-    for (Vertex* v : e->vertices())
-    { // be sure that all vertices are set
-      if (!v)
-        return false;
-    }
-
-    // check for duplicates in the vertices and do not add this edge
-    if (e->vertices().size() == 2) {
-      if (e->vertices()[0] == e->vertices()[1])
-        return false;
-    } else if (e->vertices().size() == 3) {
-      if (e->vertices()[0] == e->vertices()[1]
-       || e->vertices()[0] == e->vertices()[2]
-       || e->vertices()[1] == e->vertices()[2])
-        return false;
-    } else if (e->vertices().size() > 3) {
-      std::unordered_set<Vertex*> vertexPointer;
-      std::copy(e->vertices().begin(), e->vertices().end(), std::inserter(vertexPointer, vertexPointer.begin()));
-      if (vertexPointer.size() != e->vertices().size())
-        return false;
-    }
-
     std::pair<EdgeSet::iterator, bool> result = _edges.insert(e);
-    if (!result.second)
+    if (! result.second)
       return false;
-
-    for (Vertex* v : e->vertices())
-    { // connect the vertices to this edge
-      v->edges().insert(e);
-    }
-
-    return true;
-  }
-
-  bool HyperGraph::setEdgeVertex(HyperGraph::Edge* e, int pos, HyperGraph::Vertex* v)
-  {
-    Vertex* vOld = e->vertex(pos);
-    if (vOld)
-      vOld->edges().erase(e);
-    e->setVertex(pos, v);
-    if (v)
+    for (std::vector<Vertex*>::iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
+      Vertex* v = *it;
       v->edges().insert(e);
-    return true;
-  }
-
-  bool HyperGraph::mergeVertices(Vertex* vBig, Vertex* vSmall, bool erase)
-  {
-    VertexIDMap::iterator it=_vertices.find(vBig->id());
-    if (it==_vertices.end())
-      return false;
-
-    it=_vertices.find(vSmall->id());
-    if (it==_vertices.end())
-      return false;
-
-    EdgeSet tmp(vSmall->edges());
-    bool ok = true;
-    for(EdgeSet::iterator it=tmp.begin(); it!=tmp.end(); ++it){
-      HyperGraph::Edge* e = *it;
-      for (size_t i=0; i<e->vertices().size(); i++){
-        Vertex* v=e->vertex(i);
-        if (v==vSmall)
-          ok &= setEdgeVertex(e,i,vBig);
-      }
-    }
-    if (erase)
-      removeVertex(vSmall);
-    return ok;
-  }
-
-  bool HyperGraph::detachVertex(Vertex* v){
-    VertexIDMap::iterator it=_vertices.find(v->id());
-    if (it==_vertices.end())
-      return false;
-    assert(it->second==v);
-    EdgeSet tmp(v->edges());
-    for (EdgeSet::iterator it=tmp.begin(); it!=tmp.end(); ++it){
-      HyperGraph::Edge* e = *it;
-      for (size_t i = 0 ; i<e->vertices().size(); i++){
-        if (v == e->vertex(i))
-          setEdgeVertex(e,i,0);
-      }
     }
     return true;
   }
 
-  bool HyperGraph::removeVertex(Vertex* v, bool detach)
+  bool HyperGraph::removeVertex(Vertex* v)
   {
-    if (detach){
-      bool result = detachVertex(v);
-      if (! result) {
-        assert (0 && "inconsistency in detaching vertex, ");
-      }
-    }
     VertexIDMap::iterator it=_vertices.find(v->id());
     if (it==_vertices.end())
       return false;
@@ -215,11 +118,11 @@ namespace g2o {
     EdgeSet tmp(v->edges());
     for (EdgeSet::iterator it=tmp.begin(); it!=tmp.end(); ++it){
       if (!removeEdge(*it)){
-        assert(0 && "error in erasing vertex");
+        assert(0);
       }
     }
     _vertices.erase(it);
-    release(v);
+    delete v;
     return true;
   }
 
@@ -229,15 +132,15 @@ namespace g2o {
     if (it == _edges.end())
       return false;
     _edges.erase(it);
+
     for (std::vector<Vertex*>::iterator vit = e->vertices().begin(); vit != e->vertices().end(); ++vit) {
       Vertex* v = *vit;
-      if (!v)
-        continue;
       it = v->edges().find(e);
       assert(it!=v->edges().end());
       v->edges().erase(it);
     }
-    release(e);
+
+    delete e;
     return true;
   }
 
@@ -247,20 +150,17 @@ namespace g2o {
 
   void HyperGraph::clear()
   {
-#if G2O_DELETE_IMPLICITLY_OWNED_OBJECTS
     for (VertexIDMap::iterator it=_vertices.begin(); it!=_vertices.end(); ++it)
       delete (it->second);
     for (EdgeSet::iterator it=_edges.begin(); it!=_edges.end(); ++it)
       delete (*it);
-#endif
-
     _vertices.clear();
     _edges.clear();
   }
 
   HyperGraph::~HyperGraph()
   {
-    HyperGraph::clear();
+    clear();
   }
 
 } // end namespace
diff --git a/g2o/core/hyper_graph.h b/g2o/core/hyper_graph.h
index 2ef11d58..da6bb3d3 100644
--- a/g2o/core/hyper_graph.h
+++ b/g2o/core/hyper_graph.h
@@ -27,15 +27,20 @@
 #ifndef G2O_AIS_HYPER_GRAPH_HH
 #define G2O_AIS_HYPER_GRAPH_HH
 
+#include <map>
 #include <set>
 #include <bitset>
 #include <cassert>
 #include <vector>
+#include <limits>
 #include <cstddef>
 
+#ifdef _MSC_VER
 #include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
 
-#include "g2o_core_api.h"
 
 /** @addtogroup graph */
 //@{
@@ -43,21 +48,21 @@ namespace g2o {
 
   /**
      Class that models a directed  Hyper-Graph. An hyper graph is a graph where an edge
-     can connect one or more nodes. Both Vertices and Edges of an hyper graph
+     can connect one or more nodes. Both Vertices and Edges of an hyoper graph
      derive from the same class HyperGraphElement, thus one can implement generic algorithms
      that operate transparently on edges or vertices (see HyperGraphAction).
 
      The vertices are uniquely identified by an int id, while the edges are
      identfied by their pointers. 
    */
-  class G2O_CORE_API HyperGraph
+  class  HyperGraph
   {
     public:
 
       /**
        * \brief enum of all the types we have in our graphs
        */
-      enum G2O_CORE_API HyperGraphElementType {
+      enum  HyperGraphElementType {
         HGET_VERTEX,
         HGET_EDGE,
         HGET_PARAMETER,
@@ -66,20 +71,15 @@ namespace g2o {
         HGET_NUM_ELEMS // keep as last elem
       };
 
-      static const int UnassignedId = -1;
-      static const int InvalidId = -2;
-
       typedef std::bitset<HyperGraph::HGET_NUM_ELEMS> GraphElemBitset;
 
-      class G2O_CORE_API Data;
-      class G2O_CORE_API DataContainer;
-      class G2O_CORE_API Vertex;
-      class G2O_CORE_API Edge;
+      class  Vertex;
+      class  Edge;
       
       /**
        * base hyper graph element, specialized in vertex and edge
        */
-      struct G2O_CORE_API HyperGraphElement {
+      struct  HyperGraphElement {
         virtual ~HyperGraphElement() {}
         /**
          * returns the type of the graph element, see HyperGraphElementType
@@ -87,63 +87,21 @@ namespace g2o {
         virtual HyperGraphElementType elementType() const = 0;
       };
 
-      /**
-       * \brief data packet for a vertex. Extend this class to store in the vertices
-       * the potential additional information you need (e.g. images, laser scans, ...).
-       */
-      class G2O_CORE_API Data : public HyperGraph::HyperGraphElement {
-        public:
-          Data();
-          ~Data();
-          //! read the data from a stream
-          virtual bool read(std::istream& is) = 0;
-          //! write the data to a stream
-          virtual bool write(std::ostream& os) const = 0;
-          virtual HyperGraph::HyperGraphElementType elementType() const { return HyperGraph::HGET_DATA;}
-          inline const Data* next() const {return _next;}
-          inline Data* next() {return _next;}
-          inline void setNext(Data* next_) { _next = next_; }
-          inline DataContainer* dataContainer() { return _dataContainer;}
-          inline const DataContainer* dataContainer() const { return _dataContainer;}
-          inline void setDataContainer(DataContainer * dataContainer_){ _dataContainer = dataContainer_;}
-        protected:
-          Data* _next; // linked list of multiple data;
-          DataContainer* _dataContainer;
-      };
-
-      /**
-       * \brief Container class that implements an interface for adding/removing Data elements in
-       a linked list
-       */
-      class G2O_CORE_API DataContainer {
-        public:
-          DataContainer() {_userData = 0;}
-          virtual ~DataContainer() { delete _userData;}
-          //! the user data associated with this vertex
-          const Data* userData() const { return _userData; }
-          Data* userData() { return _userData; }
-          void setUserData(Data* obs) { _userData = obs;}
-          void addUserData(Data* obs) { if (obs) { obs->setNext(_userData); _userData=obs; } }
-        protected:
-          Data* _userData;
-      };
-
-
       typedef std::set<Edge*>                           EdgeSet;
       typedef std::set<Vertex*>                         VertexSet;
 
-      typedef std::unordered_map<int, Vertex*>     VertexIDMap;
+      typedef std::tr1::unordered_map<int, Vertex*>     VertexIDMap;
       typedef std::vector<Vertex*>                      VertexContainer;
 
       //! abstract Vertex, your types must derive from that one
-      class G2O_CORE_API Vertex : public HyperGraphElement {
+      class  Vertex : public HyperGraphElement {
         public:
           //! creates a vertex having an ID specified by the argument
-          explicit Vertex(int id=InvalidId);
+          explicit Vertex(int id=-1);
           virtual ~Vertex();
           //! returns the id
           int id() const {return _id;}
-          virtual void setId(int newId) { _id = newId; }
+	  virtual void setId( int newId) { _id=newId; }
           //! returns the set of hyper-edges that are leaving/entering in this vertex
           const EdgeSet& edges() const {return _edges;}
           //! returns the set of hyper-edges that are leaving/entering in this vertex
@@ -154,15 +112,14 @@ namespace g2o {
           EdgeSet _edges;
       };
 
-
       /** 
        * Abstract Edge class. Your nice edge classes should inherit from that one.
        * An hyper-edge has pointers to the vertices it connects and stores them in a vector.
        */
-      class G2O_CORE_API Edge : public HyperGraphElement {
+      class  Edge : public HyperGraphElement {
         public:
           //! creates and empty edge with no vertices
-          explicit Edge(int id = InvalidId);
+          explicit Edge(int id = -1);
           virtual ~Edge();
 
           /**
@@ -193,12 +150,9 @@ namespace g2o {
           int id() const {return _id;}
           void setId(int id);
           virtual HyperGraphElementType elementType() const { return HGET_EDGE;}
-
-          int numUndefinedVertices() const;
-
-         protected:
+        protected:
           VertexContainer _vertices;
-          int _id;  ///< unique id
+          int _id; ///< unique id
       };
 
     public:
@@ -213,7 +167,7 @@ namespace g2o {
       const Vertex* vertex(int id) const;
 
       //! removes a vertex from the graph. Returns true on success (vertex was present)
-      virtual bool removeVertex(Vertex* v, bool detach=false);
+      virtual bool removeVertex(Vertex* v);
       //! removes a vertex from the graph. Returns true on success (edge was present)
       virtual bool removeEdge(Edge* e);
       //! clears the graph and empties all structures.
@@ -238,30 +192,11 @@ namespace g2o {
       virtual bool addVertex(Vertex* v);
 
       /**
-       * Adds an edge to the graph. If the edge is already in the graph, it
+       * Adds an edge  to the graph. If the edge is already in the graph, it
        * does nothing and returns false. Otherwise it returns true.
        */
       virtual bool addEdge(Edge* e);
 
-
-      /**
-       * Sets the vertex in position "pos" within the edge and keeps the bookkeeping consistent.
-       * If v ==0, the vertex is set to "invalid"
-       */
-      virtual bool setEdgeVertex(Edge* e, int pos, Vertex* v);
-
-      /**
-       * merges two (valid) vertices, adjusts the bookkeeping and relabels all edges.
-       * the observations of vSmall are retargeted to vBig. If erase = true, vSmall is deleted from the graph
-       * repeatedly calls setEdgeVertex(...)
-       */
-      virtual bool mergeVertices(Vertex* vBig, Vertex* vSmall, bool erase);
-
-      /**
-       * detaches a vertex from all connected edges
-       */
-      virtual bool detachVertex(Vertex* v);
-
       /**
        * changes the id of a vertex already in the graph, and updates the bookkeeping
        @ returns false if the vertex is not in the graph;
diff --git a/g2o/core/hyper_graph_action.cpp b/g2o/core/hyper_graph_action.cpp
index 08d8f932..c9d83600 100644
--- a/g2o/core/hyper_graph_action.cpp
+++ b/g2o/core/hyper_graph_action.cpp
@@ -26,15 +26,13 @@
 
 #include "hyper_graph_action.h"
 #include "optimizable_graph.h"
-#include "cache.h"
-#include "g2o/stuff/macros.h"
+#include "../stuff/macros.h"
 
 
 #include <iostream>
-#include <list>
 
 namespace g2o {
-  using namespace std;
+  
 
   HyperGraphActionLibrary* HyperGraphActionLibrary::actionLibInstance = 0;
 
@@ -54,14 +52,17 @@ namespace g2o {
 
   HyperGraphAction* HyperGraphAction::operator()(const HyperGraph*, Parameters*)
   {
-    return nullptr;
+    return 0;
   }
 
   HyperGraphElementAction::Parameters::~Parameters()
   {
   }
 
-  HyperGraphElementAction::HyperGraphElementAction(const std::string& typeName_) : _typeName(typeName_) {}
+  HyperGraphElementAction::HyperGraphElementAction(const std::string& typeName_)
+  {
+    _typeName = typeName_;
+  }
 
   void HyperGraphElementAction::setTypeName(const std::string& typeName_)
   {
@@ -71,12 +72,12 @@ namespace g2o {
 
   HyperGraphElementAction* HyperGraphElementAction::operator()(HyperGraph::HyperGraphElement* , HyperGraphElementAction::Parameters* )
   {
-    return nullptr;
+    return 0;
   }
   
   HyperGraphElementAction* HyperGraphElementAction::operator()(const HyperGraph::HyperGraphElement* , HyperGraphElementAction::Parameters* )
   {
-    return nullptr;
+    return 0;
   }
   
   HyperGraphElementAction::~HyperGraphElementAction()
@@ -98,9 +99,9 @@ namespace g2o {
   HyperGraphElementAction* HyperGraphElementActionCollection::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params)
   {
     ActionMap::iterator it=_actionMap.find(typeid(*element).name());
-    //cerr << typeid(*element).name() << endl;
+    //std::cerr << typeid(*element).name() << std::endl;
     if (it==_actionMap.end())
-      return nullptr;
+      return 0;
     HyperGraphElementAction* action=it->second;
     return (*action)(element, params);
   }
@@ -109,7 +110,7 @@ namespace g2o {
   {
     ActionMap::iterator it=_actionMap.find(typeid(*element).name());
     if (it==_actionMap.end())
-      return nullptr;
+      return 0;
     HyperGraphElementAction* action=it->second;
     return (*action)(element, params);
   }
@@ -117,12 +118,12 @@ namespace g2o {
   bool HyperGraphElementActionCollection::registerAction(HyperGraphElementAction* action)
   {
 #  ifdef G2O_DEBUG_ACTIONLIB
-    cerr << __PRETTY_FUNCTION__ << " " << action->name() << " " << action->typeName() << endl;
+    std::cerr << __PRETTY_FUNCTION__ << " " << action->name() << " " << action->typeName() << std::endl;
 #  endif
     if (action->name()!=name()){
-      cerr << __PRETTY_FUNCTION__  << ": invalid attempt to register an action in a collection with a different name " <<  name() << " " << action->name() << endl;
+      std::cerr << __PRETTY_FUNCTION__  << ": invalid attempt to register an action in a collection with a different name " <<  name() << " " << action->name() << std::endl;
     }
-    _actionMap.insert(make_pair ( action->typeName(), action) );
+    _actionMap.insert(std::make_pair ( action->typeName(), action) );
     return true;
   }
 
@@ -157,10 +158,9 @@ namespace g2o {
 
   HyperGraphActionLibrary::~HyperGraphActionLibrary()
   {
-    // memory is freed by Proxy
-    //for (HyperGraphElementAction::ActionMap::iterator it = _actionMap.begin(); it != _actionMap.end(); ++it) {
-      //delete it->second;
-    //}
+    for (HyperGraphElementAction::ActionMap::iterator it = _actionMap.begin(); it != _actionMap.end(); ++it) {
+      delete it->second;
+    }
   }
   
   HyperGraphElementAction* HyperGraphActionLibrary::actionByName(const std::string& name)
@@ -168,7 +168,7 @@ namespace g2o {
     HyperGraphElementAction::ActionMap::iterator it=_actionMap.find(name);
     if (it!=_actionMap.end())
       return it->second;
-    return nullptr;
+    return 0;
   }
 
   bool HyperGraphActionLibrary::registerAction(HyperGraphElementAction* action)
@@ -178,23 +178,23 @@ namespace g2o {
     if (oldAction) {
       collection = dynamic_cast<HyperGraphElementActionCollection*>(oldAction);
       if (! collection) {
-        cerr << __PRETTY_FUNCTION__ << ": fatal error, a collection is not at the first level in the library" << endl;
-        return false;
+        std::cerr << __PRETTY_FUNCTION__ << ": fatal error, a collection is not at the first level in the library" << std::endl;
+        return 0;
       }
     }
     if (! collection) {
 #ifdef G2O_DEBUG_ACTIONLIB
-      cerr << __PRETTY_FUNCTION__ << ": creating collection for \"" << action->name() << "\"" << endl;
+      std::cerr << __PRETTY_FUNCTION__ << ": creating collection for \"" << action->name() << "\"" << std::endl;
 #endif
       collection = new HyperGraphElementActionCollection(action->name());
-      _actionMap.insert(make_pair(action->name(), collection));
+      _actionMap.insert(std::make_pair(action->name(), collection));
     }
     return collection->registerAction(action);
   }
   
   bool HyperGraphActionLibrary::unregisterAction(HyperGraphElementAction* action)
   {
-    list<HyperGraphElementActionCollection*> collectionDeleteList;
+    std::list<HyperGraphElementActionCollection*> collectionDeleteList;
 
     // Search all the collections and delete the registered actions; if a collection becomes empty, schedule it for deletion; note that we can't delete the collections as we go because this will screw up the state of the iterators
     for (HyperGraphElementAction::ActionMap::iterator it=_actionMap.begin(); it != _actionMap.end(); ++it) {
@@ -208,8 +208,8 @@ namespace g2o {
     }
 
     // Delete any empty action collections
-    for (list<HyperGraphElementActionCollection*>::iterator itc = collectionDeleteList.begin(); itc != collectionDeleteList.end(); ++itc) {
-      //cout << "Deleting collection " << (*itc)->name() << endl;
+    for (std::list<HyperGraphElementActionCollection*>::iterator itc = collectionDeleteList.begin(); itc != collectionDeleteList.end(); ++itc) {
+      //std::cout << "Deleting collection " << (*itc)->name() << std::endl;
       _actionMap.erase((*itc)->name());
     }
 
@@ -232,7 +232,6 @@ namespace g2o {
     _name="draw";
     _previousParams = (Parameters*)0x42;
     refreshPropertyPtrs(0);
-    _cacheDrawActions = 0;
   }
 
   bool DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
@@ -251,41 +250,17 @@ namespace g2o {
     return true;
   }
 
-  void DrawAction::initializeDrawActionsCache() {
-    if (! _cacheDrawActions){
-      _cacheDrawActions = HyperGraphActionLibrary::instance()->actionByName("draw");
-    }
-  }
-
-  void DrawAction::drawCache(CacheContainer* caches, HyperGraphElementAction::Parameters* params_) {
-    if (caches){
-      for (CacheContainer::iterator it=caches->begin(); it!=caches->end(); ++it){
-        Cache* c = it->second;
-        (*_cacheDrawActions)(c, params_);
-      }
-    }
-  }
-
-  void DrawAction::drawUserData(HyperGraph::Data* data, HyperGraphElementAction::Parameters* params_){
-    while (data && _cacheDrawActions ){
-      (*_cacheDrawActions)(data, params_);
-      data=data->next();
-    }
-  }
-
   void applyAction(HyperGraph* graph, HyperGraphElementAction* action, HyperGraphElementAction::Parameters* params, const std::string& typeName)
   {
     for (HyperGraph::VertexIDMap::iterator it=graph->vertices().begin(); 
         it!=graph->vertices().end(); ++it){
-      auto& aux = *it->second;
-      if ( typeName.empty() || typeid(aux).name()==typeName){
+      if ( typeName.empty() || typeid(std::remove_pointer_t<decltype(it->second)>).name()==typeName){
         (*action)(it->second, params);
       }
     }
     for (HyperGraph::EdgeSet::iterator it=graph->edges().begin(); 
         it!=graph->edges().end(); ++it){
-      auto& aux = **it;
-      if ( typeName.empty() || typeid(aux).name()==typeName)
+      if ( typeName.empty() || typeid(std::remove_pointer_t<decltype(*it)>).name()==typeName)
         (*action)(*it, params);
     }
   }
diff --git a/g2o/core/hyper_graph_action.h b/g2o/core/hyper_graph_action.h
index 8c9702b3..21417c9b 100644
--- a/g2o/core/hyper_graph_action.h
+++ b/g2o/core/hyper_graph_action.h
@@ -28,32 +28,31 @@
 #define G2O_HYPER_GRAPH_ACTION_H
 
 #include "hyper_graph.h"
-#include "g2o/stuff/property.h"
+#include "../stuff/property.h"
 
 #include <typeinfo>
 #include <iosfwd>
+#include <set>
 #include <string>
 #include <iostream>
 
-#include "g2o_core_api.h"
 
 // define to get verbose output
 //#define G2O_DEBUG_ACTIONLIB
 
 namespace g2o {
 
-  class CacheContainer;
   /**
    * \brief Abstract action that operates on an entire graph
    */
-  class G2O_CORE_API HyperGraphAction {
+  class  HyperGraphAction {
     public:
-      class G2O_CORE_API Parameters {
+      class  Parameters {
         public:
           virtual ~Parameters();
       };
 
-      class G2O_CORE_API ParametersIteration : public Parameters {
+      class  ParametersIteration : public Parameters {
         public:
           explicit ParametersIteration(int iter);
           int iteration;
@@ -70,9 +69,9 @@ namespace g2o {
   /**
    * \brief Abstract action that operates on a graph entity
    */
-  class G2O_CORE_API HyperGraphElementAction{
+  class  HyperGraphElementAction{
     public:
-      struct G2O_CORE_API Parameters{
+      struct  Parameters{
         virtual ~Parameters();
       };
       typedef std::map<std::string, HyperGraphElementAction*> ActionMap;
@@ -109,7 +108,7 @@ namespace g2o {
    * collection of actions calls contains homogeneous actions operating on different types
    * all collected actions have the same name and should have the same functionality
    */
-  class G2O_CORE_API HyperGraphElementActionCollection: public HyperGraphElementAction{
+  class  HyperGraphElementActionCollection: public HyperGraphElementAction{
     public:
       //! constructor. name_ is the name of the action e.g.draw).
       HyperGraphElementActionCollection(const std::string& name_);
@@ -134,7 +133,7 @@ namespace g2o {
    * library of actions, indexed by the action name;
    * one can use ti to register a collection of actions
    */
-  class G2O_CORE_API HyperGraphActionLibrary{
+  class  HyperGraphActionLibrary{
     public:
       //! return the single instance of the HyperGraphActionLibrary
       static HyperGraphActionLibrary* instance();
@@ -159,14 +158,14 @@ namespace g2o {
   /**
    * apply an action to all the elements of the graph.
    */
-  void G2O_CORE_API applyAction(HyperGraph* graph, HyperGraphElementAction* action, HyperGraphElementAction::Parameters* parameters=0, const std::string& typeName="");
+  void  applyAction(HyperGraph* graph, HyperGraphElementAction* action, HyperGraphElementAction::Parameters* parameters=0, const std::string& typeName="");
 
   /**
    * brief write into gnuplot
    */
-  class G2O_CORE_API WriteGnuplotAction: public HyperGraphElementAction{
+  class  WriteGnuplotAction: public HyperGraphElementAction{
     public:
-      struct G2O_CORE_API Parameters: public HyperGraphElementAction::Parameters{
+      struct  Parameters: public HyperGraphElementAction::Parameters{
         std::ostream* os;
       };
       WriteGnuplotAction(const std::string& typeName_);
@@ -176,22 +175,18 @@ namespace g2o {
    * \brief draw actions
    */
 
-  class G2O_CORE_API DrawAction : public HyperGraphElementAction{
+  class  DrawAction : public HyperGraphElementAction{
   public:
-    class G2O_CORE_API Parameters: public HyperGraphElementAction::Parameters,  public PropertyMap{
+    class  Parameters: public HyperGraphElementAction::Parameters,  public PropertyMap{
     public:
       Parameters();
     };
     DrawAction(const std::string& typeName_);
   protected:
     virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    void initializeDrawActionsCache() ;
-    void drawCache(CacheContainer* caches, HyperGraphElementAction::Parameters* params_);
-    void drawUserData(HyperGraph::Data* data, HyperGraphElementAction::Parameters* params_);
     Parameters* _previousParams;
     BoolProperty* _show;
     BoolProperty* _showId;
-    HyperGraphElementAction* _cacheDrawActions;
   };
 
   template<typename T> class RegisterActionProxy
diff --git a/g2o/core/io_helper.h b/g2o/core/io_helper.h
deleted file mode 100644
index 9e561202..00000000
--- a/g2o/core/io_helper.h
+++ /dev/null
@@ -1,48 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2014 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_CORE_IO_HELPER_H
-#define G2O_CORE_IO_HELPER_H
-
-#include <iosfwd>
-
-namespace g2o {
-namespace internal {
-template <typename Derived>
-bool writeVector(std::ostream& os, const Eigen::DenseBase<Derived>& b) {
-  for (int i = 0; i < b.size(); i++) os << b(i) << " ";
-  return os.good();
-}
-
-template <typename Derived>
-bool readVector(std::istream& is, Eigen::DenseBase<Derived>& b) {
-  for (int i = 0; i < b.size() && is.good(); i++) is >> b(i);
-  return is.good() || is.eof();
-}
-}  // namespace internal
-}  // namespace g2o
-
-#endif
diff --git a/g2o/core/jacobian_workspace.cpp b/g2o/core/jacobian_workspace.cpp
index 28ab94e5..21f0338e 100644
--- a/g2o/core/jacobian_workspace.cpp
+++ b/g2o/core/jacobian_workspace.cpp
@@ -30,76 +30,60 @@
 
 #include "optimizable_graph.h"
 
-using namespace std;
 
-namespace g2o {
-
-  JacobianWorkspace::JacobianWorkspace() :
-    _maxNumVertices(-1), _maxDimension(-1)
-  {
-  }
 
-  JacobianWorkspace::~JacobianWorkspace()
-  {
-  }
+namespace g2o {
 
-  bool JacobianWorkspace::allocate()
-  {
-    //cerr << __PRETTY_FUNCTION__ << " " << PVAR(this) << " " << PVAR(_maxNumVertices) << " " << PVAR(_maxDimension) << endl;
-    if (_maxNumVertices <=0 || _maxDimension <= 0)
-      return false;
-    _workspace.resize(_maxNumVertices);
-    for (WorkspaceVector::iterator it = _workspace.begin(); it != _workspace.end(); ++it) {
-      it->resize(_maxDimension);
-      it->setZero();
-    }
-    return true;
+JacobianWorkspace::JacobianWorkspace() :
+  _maxNumVertices(-1), _maxDimension(-1)
+{
+}
+
+JacobianWorkspace::~JacobianWorkspace()
+{
+}
+
+bool JacobianWorkspace::allocate()
+{
+  //std::cerr << __PRETTY_FUNCTION__ << " " << PVAR(this) << " " << PVAR(_maxNumVertices) << " " << PVAR(_maxDimension) << std::endl;
+  if (_maxNumVertices <=0 || _maxDimension <= 0)
+    return false;
+  _workspace.resize(_maxNumVertices);
+  for (WorkspaceVector::iterator it = _workspace.begin(); it != _workspace.end(); ++it) {
+    it->resize(_maxDimension);
+    it->setZero();
   }
-  
-  void JacobianWorkspace::updateSize(const HyperGraph::Edge* e_, bool reset)
-  {
-    if (reset) {
-      _maxNumVertices = -1;
-      _maxDimension = -1;
-    }
-      
-    const OptimizableGraph::Edge* e = static_cast<const OptimizableGraph::Edge*>(e_);
-    int errorDimension = e->dimension();
-    int numVertices = e->vertices().size();
-    int maxDimensionForEdge = -1;
-    
-    for (int i = 0; i < numVertices; ++i) {
-      const OptimizableGraph::Vertex* v = static_cast<const OptimizableGraph::Vertex*>(e->vertex(i));
-      assert(v && "Edge has no vertex assigned");
-      maxDimensionForEdge = max(v->dimension() * errorDimension, maxDimensionForEdge);
-    }
-    _maxNumVertices = max(numVertices, _maxNumVertices);
-    _maxDimension = max(maxDimensionForEdge, _maxDimension);
-    //cerr << __PRETTY_FUNCTION__ << " " << PVAR(this) << " " << PVAR(_maxNumVertices) << " " << PVAR(_maxDimension) << endl;
+  return true;
+}
+
+void JacobianWorkspace::updateSize(const HyperGraph::Edge* e_)
+{
+  const OptimizableGraph::Edge* e = static_cast<const OptimizableGraph::Edge*>(e_);
+  int errorDimension = e->dimension();
+  int numVertices = e->vertices().size();
+  int maxDimensionForEdge = -1;
+  for (int i = 0; i < numVertices; ++i) {
+    const OptimizableGraph::Vertex* v = static_cast<const OptimizableGraph::Vertex*>(e->vertex(i));
+    assert(v && "Edge has no vertex assigned");
+    maxDimensionForEdge = std::max(v->dimension() * errorDimension, maxDimensionForEdge);
   }
-
-  void JacobianWorkspace::updateSize(const OptimizableGraph& graph, bool reset)
-  {
-    if (reset) {
-      _maxNumVertices = -1;
-      _maxDimension = -1;
-    }
-    
-    for (OptimizableGraph::EdgeSet::const_iterator it = graph.edges().begin(); it != graph.edges().end(); ++it) {
-      const OptimizableGraph::Edge* e = static_cast<const OptimizableGraph::Edge*>(*it);
-      updateSize(e);
-    }
+  _maxNumVertices = std::max(numVertices, _maxNumVertices);
+  _maxDimension = std::max(maxDimensionForEdge, _maxDimension);
+  //std::cerr << __PRETTY_FUNCTION__ << " " << PVAR(this) << " " << PVAR(_maxNumVertices) << " " << PVAR(_maxDimension) << std::endl;
+}
+
+void JacobianWorkspace::updateSize(const OptimizableGraph& graph)
+{
+  for (OptimizableGraph::EdgeSet::const_iterator it = graph.edges().begin(); it != graph.edges().end(); ++it) {
+    const OptimizableGraph::Edge* e = static_cast<const OptimizableGraph::Edge*>(*it);
+    updateSize(e);
   }
+}
 
-  void JacobianWorkspace::updateSize(int numVertices, int dimension, bool reset)
-  {
-    if (reset) {
-      _maxNumVertices = -1;
-      _maxDimension = -1;
-    }
-    
-    _maxNumVertices = max(numVertices, _maxNumVertices);
-    _maxDimension = max(dimension, _maxDimension);
-  }
+void JacobianWorkspace::updateSize(int numVertices, int dimension)
+{
+  _maxNumVertices = std::max(numVertices, _maxNumVertices);
+  _maxDimension = std::max(dimension, _maxDimension);
+}
 
 } // end namespace
diff --git a/g2o/core/jacobian_workspace.h b/g2o/core/jacobian_workspace.h
index 50c4e472..e1f16026 100644
--- a/g2o/core/jacobian_workspace.h
+++ b/g2o/core/jacobian_workspace.h
@@ -28,12 +28,11 @@
 #define JACOBIAN_WORKSPACE_H
 
 #include <Eigen/Core>
+#include <Eigen/StdVector>
 
 #include <vector>
 #include <cassert>
 
-#include "g2o/config.h"
-#include "g2o_core_api.h"
 #include "hyper_graph.h"
 
 namespace g2o {
@@ -47,14 +46,11 @@ namespace g2o {
    * for computing the Jacobian of the error functions.
    * Before calling linearizeOplus on an edge, the workspace needs to be allocated
    * by calling allocate().
-   *
-   * By default, the sizes are updated incrementally with each call. If the reset flag is set to true,
-   * the counts are set back to 
    */
-  class G2O_CORE_API JacobianWorkspace
+  class  JacobianWorkspace
   {
     public:
-      typedef std::vector<VectorX, Eigen::aligned_allocator<VectorX> >      WorkspaceVector;
+      typedef std::vector<Eigen::VectorXd, Eigen::aligned_allocator<Eigen::VectorXd> >      WorkspaceVector;
 
     public:
       JacobianWorkspace();
@@ -68,22 +64,22 @@ namespace g2o {
       /**
        * update the maximum required workspace needed by taking into account this edge
        */
-      void updateSize(const HyperGraph::Edge* e, bool reset = false);
+      void updateSize(const HyperGraph::Edge* e);
 
       /**
        * update the required workspace by looking at a full graph
        */
-      void updateSize(const OptimizableGraph& graph, bool reset = false);
+      void updateSize(const OptimizableGraph& graph);
 
       /**
        * manually update with the given parameters
        */
-      void updateSize(int numVertices, int dimension, bool reset = false);
+      void updateSize(int numVertices, int dimension);
 
       /**
        * return the workspace for a vertex in an edge
        */
-      number_t* workspaceForVertex(int vertexIndex)
+      double* workspaceForVertex(int vertexIndex)
       {
         assert(vertexIndex >= 0 && (size_t)vertexIndex < _workspace.size() && "Index out of bounds");
         return _workspace[vertexIndex].data();
diff --git a/g2o/core/linear_solver.h b/g2o/core/linear_solver.h
index 71f196a9..e78eac13 100644
--- a/g2o/core/linear_solver.h
+++ b/g2o/core/linear_solver.h
@@ -26,10 +26,6 @@
 
 #ifndef G2O_LINEAR_SOLVER_H
 #define G2O_LINEAR_SOLVER_H
-
-#include <functional>
-
-#include "g2o/core/marginal_covariance_cholesky.h"
 #include "sparse_block_matrix.h"
 #include "sparse_block_matrix_ccs.h"
 
@@ -42,142 +38,72 @@ namespace g2o {
  * A is assumed to be symmetric (only upper triangular block is stored) and positive-semi-definit.
  */
 template <typename MatrixType>
-class LinearSolver {
- public:
-  LinearSolver() : _writeDebug(true){};
-  virtual ~LinearSolver() {}
-
-  /**
-   * init for operating on matrices with a different non-zero pattern like before
-   */
-  virtual bool init() = 0;
-
-  /**
-   * Assumes that A is the same matrix for several calls.
-   * Among other assumptions, the non-zero pattern does not change!
-   * If the matrix changes call init() before.
-   * solve system Ax = b, x and b have to allocated beforehand!!
-   */
-  virtual bool solve(const SparseBlockMatrix<MatrixType>& A, number_t* x, number_t* b) = 0;
-
-  /**
-   * Inverts the diagonal blocks of A
-   * @returns false if not defined.
-   */
-  virtual bool solveBlocks(number_t**& blocks, const SparseBlockMatrix<MatrixType>& A) {
-    (void)blocks;
-    (void)A;
-    return false;
-  }
-
-  /**
-   * Inverts the a block pattern of A in spinv
-   * @returns false if not defined.
-   */
-  virtual bool solvePattern(SparseBlockMatrix<MatrixX>& spinv,
-                            const std::vector<std::pair<int, int> >& blockIndices,
-                            const SparseBlockMatrix<MatrixType>& A) {
-    (void)spinv;
-    (void)blockIndices;
-    (void)A;
-    return false;
-  }
-
-  //! write a debug dump of the system matrix if it is not PSD in solve
-  bool writeDebug() const { return _writeDebug; }
-  void setWriteDebug(bool b) { _writeDebug = b; }
-
-  //! allocate block memory structure
-  static void allocateBlocks(const SparseBlockMatrix<MatrixType>& A, number_t**& blocks) {
-    blocks = new number_t*[A.rows()];
-    number_t** block = blocks;
-    for (size_t i = 0; i < A.rowBlockIndices().size(); ++i) {
-      int dim = A.rowsOfBlock(i) * A.colsOfBlock(i);
-      *block = new number_t[dim];
-      block++;
-    }
-  }
-
-  //! de-allocate the block structure
-  static void deallocateBlocks(const SparseBlockMatrix<MatrixType>& A, number_t**& blocks) {
-    for (size_t i = 0; i < A.rowBlockIndices().size(); ++i) {
-      delete[] blocks[i];
+class LinearSolver
+{
+  public:
+    LinearSolver() {};
+    virtual ~LinearSolver() {}
+
+    /**
+     * init for operating on matrices with a different non-zero pattern like before
+     */
+    virtual bool init() = 0;
+
+    /**
+     * Assumes that A is the same matrix for several calls.
+     * Among other assumptions, the non-zero pattern does not change!
+     * If the matrix changes call init() before.
+     * solve system Ax = b, x and b have to allocated beforehand!!
+     */
+    virtual bool solve(const SparseBlockMatrix<MatrixType>& A, double* x, double* b) = 0;
+
+    /**
+     * Inverts the diagonal blocks of A
+     * @returns false if not defined.
+     */
+    virtual bool solveBlocks(double**&blocks, const SparseBlockMatrix<MatrixType>& A) { (void)blocks; (void) A; return false; }
+
+
+    /**
+     * Inverts the a block pattern of A in spinv
+     * @returns false if not defined.
+     */
+    virtual bool solvePattern(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices, const SparseBlockMatrix<MatrixType>& A){
+      (void) spinv;
+      (void) blockIndices;
+      (void) A;
+      return false;
     }
-    delete[] blocks;
-    blocks = nullptr;
-  }
 
-  /**
-   * Convert a block permutation matrix to a scalar permutation
-   */
-  template <typename BlockDerived, typename ScalarDerived>
-  static void blockToScalarPermutation(
-      const SparseBlockMatrix<MatrixType>& A, const Eigen::MatrixBase<BlockDerived>& p,
-      const Eigen::MatrixBase<ScalarDerived>& scalar /* output */) {
-    int n = A.cols();
-    Eigen::MatrixBase<ScalarDerived>& scalarPermutation =
-        const_cast<Eigen::MatrixBase<ScalarDerived>&>(scalar);
-    if (scalarPermutation.size() == 0) scalarPermutation.derived().resize(n);
-    if (scalarPermutation.size() < n) scalarPermutation.derived().resize(2 * n);
-    size_t scalarIdx = 0;
-    for (size_t i = 0; i < A.colBlockIndices().size(); ++i) {
-      int base = A.colBaseOfBlock(p(i));
-      int nCols = A.colsOfBlock(p(i));
-      for (int j = 0; j < nCols; ++j) {
-        scalarPermutation(scalarIdx++) = base++;
-      }
-    }
-    assert((int)scalarIdx == n);
-  }
-
-  protected:
-   bool _writeDebug;
+    //! write a debug dump of the system matrix if it is not PSD in solve
+    virtual bool writeDebug() const { return false;}
+    virtual void setWriteDebug(bool) {}
 };
 
 /**
  * \brief Solver with faster iterating structure for the linear matrix
  */
 template <typename MatrixType>
-class LinearSolverCCS : public LinearSolver<MatrixType> {
- public:
-  LinearSolverCCS() : LinearSolver<MatrixType>(), _ccsMatrix(0), _blockOrdering(true) {}
-  ~LinearSolverCCS() { delete _ccsMatrix; }
-
-  virtual bool solveBlocks(number_t**& blocks, const SparseBlockMatrix<MatrixType>& A) {
-    auto compute = [&](MarginalCovarianceCholesky& mcc) {
-      if (!blocks) LinearSolverCCS<MatrixType>::allocateBlocks(A, blocks);
-      mcc.computeCovariance(blocks, A.rowBlockIndices());
-    };
-    return solveBlocks_impl(A, compute);
-  }
-
-  virtual bool solvePattern(SparseBlockMatrix<MatrixX>& spinv,
-                            const std::vector<std::pair<int, int> >& blockIndices,
-                            const SparseBlockMatrix<MatrixType>& A) {
-    auto compute = [&](MarginalCovarianceCholesky& mcc) {
-      mcc.computeCovariance(spinv, A.rowBlockIndices(), blockIndices);
-    };
-    return solveBlocks_impl(A, compute);
-  }
-
-  //! do the AMD ordering on the blocks or on the scalar matrix
-  bool blockOrdering() const { return _blockOrdering; }
-  void setBlockOrdering(bool blockOrdering) { _blockOrdering = blockOrdering; }
-
- protected:
-  SparseBlockMatrixCCS<MatrixType>* _ccsMatrix;
-  bool _blockOrdering;
+class LinearSolverCCS : public LinearSolver<MatrixType>
+{
+  public:
+    LinearSolverCCS() : LinearSolver<MatrixType>(), _ccsMatrix(0) {}
+    ~LinearSolverCCS()
+    {
+      delete _ccsMatrix;
+    }
 
-  void initMatrixStructure(const SparseBlockMatrix<MatrixType>& A) {
-    delete _ccsMatrix;
-    _ccsMatrix = new SparseBlockMatrixCCS<MatrixType>(A.rowBlockIndices(), A.colBlockIndices());
-    A.fillSparseBlockMatrixCCS(*_ccsMatrix);
-  }
+  protected:
+    SparseBlockMatrixCCS<MatrixType>* _ccsMatrix;
 
-  virtual bool solveBlocks_impl(const SparseBlockMatrix<MatrixType>& A,
-                                std::function<void(MarginalCovarianceCholesky&)> compute) = 0;
+    void initMatrixStructure(const SparseBlockMatrix<MatrixType>& A)
+    {
+      delete _ccsMatrix;
+      _ccsMatrix = new SparseBlockMatrixCCS<MatrixType>(A.rowBlockIndices(), A.colBlockIndices());
+      A.fillSparseBlockMatrixCCS(*_ccsMatrix);
+    }
 };
 
-}  // namespace g2o
+} // end namespace
 
 #endif
diff --git a/g2o/core/marginal_covariance_cholesky.cpp b/g2o/core/marginal_covariance_cholesky.cpp
index ea0297bd..ea01bd2d 100644
--- a/g2o/core/marginal_covariance_cholesky.cpp
+++ b/g2o/core/marginal_covariance_cholesky.cpp
@@ -28,7 +28,7 @@
 
 #include <algorithm>
 #include <cassert>
-using namespace std;
+
 
 namespace g2o {
 
@@ -51,7 +51,7 @@ MarginalCovarianceCholesky::~MarginalCovarianceCholesky()
 {
 }
 
-void MarginalCovarianceCholesky::setCholeskyFactor(int n, int* Lp, int* Li, number_t* Lx, int* permInv)
+void MarginalCovarianceCholesky::setCholeskyFactor(int n, int* Lp, int* Li, double* Lx, int* permInv)
 {
   _n = n;
   _Ap = Lp;
@@ -68,7 +68,7 @@ void MarginalCovarianceCholesky::setCholeskyFactor(int n, int* Lp, int* Li, numb
   }
 }
 
-number_t MarginalCovarianceCholesky::computeEntry(int r, int c)
+double MarginalCovarianceCholesky::computeEntry(int r, int c)
 {
   assert(r <= c);
   int idx = computeIndex(r, c);
@@ -79,18 +79,18 @@ number_t MarginalCovarianceCholesky::computeEntry(int r, int c)
   }
 
   // compute the summation over column r
-  number_t s = 0.;
+  double s = 0.;
   const int& sc = _Ap[r];
   const int& ec = _Ap[r+1];
   for (int j = sc+1; j < ec; ++j) { // sum over row r while skipping the element on the diagonal
     const int& rr = _Ai[j];
-    number_t val = rr < c ? computeEntry(rr, c) : computeEntry(c, rr);
+    double val = rr < c ? computeEntry(rr, c) : computeEntry(c, rr);
     s += val * _Ax[j];
   }
 
-  number_t result;
+  double result;
   if (r == c) {
-    const number_t& diagElem = _diag[r];
+    const double& diagElem = _diag[r];
     result = diagElem * (diagElem - s);
   } else {
     result = -s * _diag[r];
@@ -99,11 +99,11 @@ number_t MarginalCovarianceCholesky::computeEntry(int r, int c)
   return result;
 }
 
-void MarginalCovarianceCholesky::computeCovariance(number_t** covBlocks, const std::vector<int>& blockIndices)
+void MarginalCovarianceCholesky::computeCovariance(double** covBlocks, const std::vector<int>& blockIndices)
 {
   _map.clear();
   int base = 0;
-  vector<MatrixElem> elemsToCompute;
+  std::vector<MatrixElem> elemsToCompute;
   for (size_t i = 0; i < blockIndices.size(); ++i) {
     int nbase = blockIndices[i];
     int vdim = nbase - base;
@@ -112,7 +112,7 @@ void MarginalCovarianceCholesky::computeCovariance(number_t** covBlocks, const s
         int r = _perm ? _perm[rr + base] : rr + base; // apply permutation
         int c = _perm ? _perm[cc + base] : cc + base;
         if (r > c) // make sure it's still upper triangular after applying the permutation
-          swap(r, c);
+          std::swap(r, c);
         elemsToCompute.push_back(MatrixElem(r, c));
       }
     base = nbase;
@@ -132,13 +132,13 @@ void MarginalCovarianceCholesky::computeCovariance(number_t** covBlocks, const s
   for (size_t i = 0; i < blockIndices.size(); ++i) {
     int nbase = blockIndices[i];
     int vdim = nbase - base;
-    number_t* cov = covBlocks[i];
+    double* cov = covBlocks[i];
     for (int rr = 0; rr < vdim; ++rr)
       for (int cc = rr; cc < vdim; ++cc) {
         int r = _perm ? _perm[rr + base] : rr + base; // apply permutation
         int c = _perm ? _perm[cc + base] : cc + base;
         if (r > c) // upper triangle
-          swap(r, c);
+          std::swap(r, c);
         int idx = computeIndex(r, c);
         LookupMap::const_iterator foundIt = _map.find(idx);
         assert(foundIt != _map.end());
@@ -151,15 +151,15 @@ void MarginalCovarianceCholesky::computeCovariance(number_t** covBlocks, const s
 }
 
 
-void MarginalCovarianceCholesky::computeCovariance(SparseBlockMatrix<MatrixX>& spinv, const std::vector<int>& rowBlockIndices, const std::vector< std::pair<int, int> >& blockIndices)
+void MarginalCovarianceCholesky::computeCovariance(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<int>& rowBlockIndices, const std::vector< std::pair<int, int> >& blockIndices)
 {
   // allocate the sparse
-  spinv = SparseBlockMatrix<MatrixX>(&rowBlockIndices[0], 
+  spinv = SparseBlockMatrix<Eigen::MatrixXd>(&rowBlockIndices[0], 
               &rowBlockIndices[0], 
               rowBlockIndices.size(),
               rowBlockIndices.size(), true);
   _map.clear();
-  vector<MatrixElem> elemsToCompute;
+  std::vector<MatrixElem> elemsToCompute;
   for (size_t i = 0; i < blockIndices.size(); ++i) {
     int blockRow=blockIndices[i].first;    
     int blockCol=blockIndices[i].second;
@@ -171,16 +171,16 @@ void MarginalCovarianceCholesky::computeCovariance(SparseBlockMatrix<MatrixX>& s
     int rowBase=spinv.rowBaseOfBlock(blockRow);
     int colBase=spinv.colBaseOfBlock(blockCol);
     
-    MatrixX *block=spinv.block(blockRow, blockCol, true);
+    Eigen::MatrixXd *block=spinv.block(blockRow, blockCol, true);
     assert(block);
     for (int iRow=0; iRow<block->rows(); ++iRow)
       for (int iCol=0; iCol<block->cols(); ++iCol){
-        int rr=rowBase+iRow;
-        int cc=colBase+iCol;
+  int rr=rowBase+iRow;
+  int cc=colBase+iCol;
         int r = _perm ? _perm[rr] : rr; // apply permutation
         int c = _perm ? _perm[cc] : cc;
         if (r > c)
-          swap(r, c);
+          std::swap(r, c);
         elemsToCompute.push_back(MatrixElem(r, c));
       }
   }
@@ -201,20 +201,20 @@ void MarginalCovarianceCholesky::computeCovariance(SparseBlockMatrix<MatrixX>& s
     int rowBase=spinv.rowBaseOfBlock(blockRow);
     int colBase=spinv.colBaseOfBlock(blockCol);
     
-    MatrixX *block=spinv.block(blockRow, blockCol);
+    Eigen::MatrixXd *block=spinv.block(blockRow, blockCol);
     assert(block);
     for (int iRow=0; iRow<block->rows(); ++iRow)
       for (int iCol=0; iCol<block->cols(); ++iCol){
-        int rr=rowBase+iRow;
-        int cc=colBase+iCol;
+  int rr=rowBase+iRow;
+  int cc=colBase+iCol;
         int r = _perm ? _perm[rr] : rr; // apply permutation
         int c = _perm ? _perm[cc] : cc;
         if (r > c)
-          swap(r, c);
+          std::swap(r, c);
         int idx = computeIndex(r, c);
         LookupMap::const_iterator foundIt = _map.find(idx);
         assert(foundIt != _map.end());
-        (*block)(iRow, iCol) = foundIt->second;
+  (*block)(iRow, iCol) = foundIt->second;
       }
   }
 }
diff --git a/g2o/core/marginal_covariance_cholesky.h b/g2o/core/marginal_covariance_cholesky.h
index 0c20c473..a80c9258 100644
--- a/g2o/core/marginal_covariance_cholesky.h
+++ b/g2o/core/marginal_covariance_cholesky.h
@@ -27,25 +27,30 @@
 #ifndef G2O_MARGINAL_COVARIANCE_CHOLESKY_H
 #define G2O_MARGINAL_COVARIANCE_CHOLESKY_H
 
+#include "optimizable_graph.h"
 #include "sparse_block_matrix.h"
 
+#include <cassert>
 #include <vector>
 
+#ifdef _MSC_VER
 #include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
 
-#include "g2o_core_api.h"
 
 namespace g2o {
 
   /**
    * \brief computing the marginal covariance given a cholesky factor (lower triangle of the factor)
    */
-  class G2O_CORE_API MarginalCovarianceCholesky {
+  class  MarginalCovarianceCholesky {
     protected:
       /**
        * hash struct for storing the matrix elements needed to compute the covariance
        */
-      typedef std::unordered_map<int, number_t>     LookupMap;
+      typedef std::tr1::unordered_map<int, double>     LookupMap;
     
     public:
       MarginalCovarianceCholesky();
@@ -55,13 +60,13 @@ namespace g2o {
        * compute the marginal cov for the given block indices, write the result to the covBlocks memory (which has to
        * be provided by the caller).
        */
-      void computeCovariance(number_t** covBlocks, const std::vector<int>& blockIndices);
+      void computeCovariance(double** covBlocks, const std::vector<int>& blockIndices);
 
 
       /**
        * compute the marginal cov for the given block indices, write the result in spinv).
        */
-      void computeCovariance(SparseBlockMatrix<MatrixX>& spinv, const std::vector<int>& rowBlockIndices, const std::vector< std::pair<int, int> >& blockIndices);
+      void computeCovariance(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<int>& rowBlockIndices, const std::vector< std::pair<int, int> >& blockIndices);
 
 
       /**
@@ -71,18 +76,18 @@ namespace g2o {
        * The pointers provided by the user need to be still valid when calling computeCovariance(). The pointers
        * are owned by the caller, MarginalCovarianceCholesky does not free the pointers.
        */
-      void setCholeskyFactor(int n, int* Lp, int* Li, number_t* Lx, int* permInv);
+      void setCholeskyFactor(int n, int* Lp, int* Li, double* Lx, int* permInv);
 
     protected:
       // information about the cholesky factor (lower triangle)
       int _n;           ///< L is an n X n matrix
       int* _Ap;         ///< column pointer of the CCS storage
       int* _Ai;         ///< row indices of the CCS storage
-      number_t* _Ax;      ///< values of the cholesky factor
+      double* _Ax;      ///< values of the cholesky factor
       int* _perm;       ///< permutation of the cholesky factor. Variable re-ordering for better fill-in
 
       LookupMap _map;             ///< hash look up table for the already computed entries
-      std::vector<number_t> _diag;  ///< cache 1 / H_ii to avoid recalculations
+      std::vector<double> _diag;  ///< cache 1 / H_ii to avoid recalculations
 
       //! compute the index used for hashing
       int computeIndex(int r, int c) const { /*assert(r <= c);*/ return r*_n + c;}
@@ -90,7 +95,7 @@ namespace g2o {
        * compute one entry in the covariance, r and c are values after applying the permutation, and upper triangular.
        * May issue recursive calls to itself to compute the missing values.
        */
-      number_t computeEntry(int r, int c);
+      double computeEntry(int r, int c);
   };
 
 }
diff --git a/g2o/core/matrix_operations.h b/g2o/core/matrix_operations.h
index 78eac886..28e6fbef 100644
--- a/g2o/core/matrix_operations.h
+++ b/g2o/core/matrix_operations.h
@@ -33,37 +33,37 @@ namespace g2o {
   namespace internal {
 
     template<typename MatrixType>
-    inline void axpy(const MatrixType& A, const Eigen::Map<const VectorX>& x, int xoff, Eigen::Map<VectorX>& y, int yoff)
+    inline void axpy(const MatrixType& A, const Eigen::Map<const Eigen::VectorXd>& x, int xoff, Eigen::Map<Eigen::VectorXd>& y, int yoff)
     {
       y.segment<MatrixType::RowsAtCompileTime>(yoff) += A * x.segment<MatrixType::ColsAtCompileTime>(xoff);
     }
 
     template<int t>
-    inline void axpy(const Eigen::Matrix<number_t, Eigen::Dynamic, t>& A, const Eigen::Map<const VectorX>& x, int xoff, Eigen::Map<VectorX>& y, int yoff)
+    inline void axpy(const Eigen::Matrix<double, Eigen::Dynamic, t>& A, const Eigen::Map<const Eigen::VectorXd>& x, int xoff, Eigen::Map<Eigen::VectorXd>& y, int yoff)
     {
-      y.segment(yoff, A.rows()) += A * x.segment<Eigen::Matrix<number_t, Eigen::Dynamic, t>::ColsAtCompileTime>(xoff);
+      y.segment(yoff, A.rows()) += A * x.segment<Eigen::Matrix<double, Eigen::Dynamic, t>::ColsAtCompileTime>(xoff);
     }
 
     template<>
-    inline void axpy<MatrixX>(const MatrixX& A, const Eigen::Map<const VectorX>& x, int xoff, Eigen::Map<VectorX>& y, int yoff)
+    inline void axpy(const Eigen::MatrixXd& A, const Eigen::Map<const Eigen::VectorXd>& x, int xoff, Eigen::Map<Eigen::VectorXd>& y, int yoff)
     {
       y.segment(yoff, A.rows()) += A * x.segment(xoff, A.cols());
     }
 
     template<typename MatrixType>
-    inline void atxpy(const MatrixType& A, const Eigen::Map<const VectorX>& x, int xoff, Eigen::Map<VectorX>& y, int yoff)
+    inline void atxpy(const MatrixType& A, const Eigen::Map<const Eigen::VectorXd>& x, int xoff, Eigen::Map<Eigen::VectorXd>& y, int yoff)
     {
       y.segment<MatrixType::ColsAtCompileTime>(yoff) += A.transpose() * x.segment<MatrixType::RowsAtCompileTime>(xoff);
     }
 
     template<int t>
-    inline void atxpy(const Eigen::Matrix<number_t, Eigen::Dynamic, t>& A, const Eigen::Map<const VectorX>& x, int xoff, Eigen::Map<VectorX>& y, int yoff)
+    inline void atxpy(const Eigen::Matrix<double, Eigen::Dynamic, t>& A, const Eigen::Map<const Eigen::VectorXd>& x, int xoff, Eigen::Map<Eigen::VectorXd>& y, int yoff)
     {
-      y.segment<Eigen::Matrix<number_t, Eigen::Dynamic, t>::ColsAtCompileTime>(yoff) += A.transpose() * x.segment(xoff, A.rows());
+      y.segment<Eigen::Matrix<double, Eigen::Dynamic, t>::ColsAtCompileTime>(yoff) += A.transpose() * x.segment(xoff, A.rows());
     }
 
     template<>
-    inline void atxpy<MatrixX>(const MatrixX& A, const Eigen::Map<const VectorX>& x, int xoff, Eigen::Map<VectorX>& y, int yoff)
+    inline void atxpy(const Eigen::MatrixXd& A, const Eigen::Map<const Eigen::VectorXd>& x, int xoff, Eigen::Map<Eigen::VectorXd>& y, int yoff)
     {
       y.segment(yoff, A.cols()) += A.transpose() * x.segment(xoff, A.rows());
     }
diff --git a/g2o/core/matrix_structure.cpp b/g2o/core/matrix_structure.cpp
index 3152195a..10841a07 100644
--- a/g2o/core/matrix_structure.cpp
+++ b/g2o/core/matrix_structure.cpp
@@ -30,13 +30,13 @@
 #include <vector>
 #include <fstream>
 #include <algorithm>
-using namespace std;
+
 
 namespace g2o {
 
 struct ColSort
 {
-  bool operator()(const pair<int, int>& e1, const pair<int, int>& e2) const
+  bool operator()(const std::pair<int, int>& e1, const std::pair<int, int>& e2) const
   {
     return e1.second < e2.second || (e1.second == e2.second && e1.first < e2.first);
   }
@@ -90,19 +90,19 @@ bool MatrixStructure::write(const char* filename) const
   const int& cols = n;
   const int& rows = m;
 
-  string name = filename;
+  std::string name = filename;
   std::string::size_type lastDot = name.find_last_of('.');
   if (lastDot != std::string::npos) 
     name = name.substr(0, lastDot);
 
-  vector<pair<int, int> > entries;
+  std::vector<std::pair<int, int> > entries;
   for (int i=0; i < cols; ++i) {
     const int& rbeg = Ap[i];
     const int& rend = Ap[i+1];
     for (int j = rbeg; j < rend; ++j) {
-      entries.push_back(make_pair(Aii[j], i));
+      entries.push_back(std::make_pair(Aii[j], i));
       if (Aii[j] != i)
-        entries.push_back(make_pair(i, Aii[j]));
+        entries.push_back(std::make_pair(i, Aii[j]));
     }
   }
 
@@ -114,8 +114,8 @@ bool MatrixStructure::write(const char* filename) const
   fout << "# nnz: " << entries.size() << std::endl;
   fout << "# rows: " << rows << std::endl;
   fout << "# columns: " << cols << std::endl;
-  for (vector<pair<int, int> >::const_iterator it = entries.begin(); it != entries.end(); ++it) {
-    const pair<int, int>& entry = *it;
+  for (std::vector<std::pair<int, int> >::const_iterator it = entries.begin(); it != entries.end(); ++it) {
+    const std::pair<int, int>& entry = *it;
     fout << entry.first << " " << entry.second << " 0" << std::endl; // write a constant value of 0
   }
 
diff --git a/g2o/core/matrix_structure.h b/g2o/core/matrix_structure.h
index c34d2202..fd70e531 100644
--- a/g2o/core/matrix_structure.h
+++ b/g2o/core/matrix_structure.h
@@ -27,21 +27,20 @@
 #ifndef G2O_MATRIX_STRUCTURE_H
 #define G2O_MATRIX_STRUCTURE_H
 
-#include "g2o_core_api.h"
 
 namespace g2o {
 
 /**
  * \brief representing the structure of a matrix in column compressed structure (only the upper triangular part of the matrix)
  */
-class G2O_CORE_API MatrixStructure
+class MatrixStructure
 {
   public:
     MatrixStructure();
     ~MatrixStructure();
     /**
      * allocate space for the Matrix Structure. You may call this on an already allocated struct, it will
-     * then reallocate the memory + additional space (number_t the required space).
+     * then reallocate the memory + additional space (double the required space).
      */
     void alloc(int n_, int nz);
 
diff --git a/g2o/core/optimizable_graph.cpp b/g2o/core/optimizable_graph.cpp
index 70aba199..4f729693 100644
--- a/g2o/core/optimizable_graph.cpp
+++ b/g2o/core/optimizable_graph.cpp
@@ -40,26 +40,25 @@
 #include "hyper_graph_action.h"
 #include "cache.h"
 #include "robust_kernel.h"
-#include "ownership.h"
 
-#include "g2o/stuff/macros.h"
-#include "g2o/stuff/color_macros.h"
-#include "g2o/stuff/string_tools.h"
-#include "g2o/stuff/misc.h"
+#include "../stuff/macros.h"
+#include "../stuff/color_macros.h"
+#include "../stuff/string_tools.h"
+#include "../stuff/misc.h"
 
 namespace g2o {
 
-  using namespace std;
   
-  namespace {
-  std::ostream& printIdChain(std::ostream& os, const std::vector<int>& ids) {
-    for (size_t l = 0; l < ids.size(); ++l) {
-      if (l > 0) cerr << " <->";
-      cerr << " " << ids[l];
-    }
-    return os;
+
+  OptimizableGraph::Data::Data(){
+    _next = 0;
   }
-  }  // namespace
+  
+  OptimizableGraph::Data::~Data(){
+    if (_next)
+      delete _next;
+  }
+  
 
   OptimizableGraph::Vertex::Vertex() :
     HyperGraph::Vertex(),
@@ -84,18 +83,25 @@ namespace g2o {
 
   OptimizableGraph::Vertex::~Vertex()
   {
-    delete _cacheContainer;
-    delete _userData;
+    if (_cacheContainer)
+      delete (_cacheContainer);
+    if (_userData)
+      delete _userData;
   }
   
-  bool OptimizableGraph::Vertex::setEstimateData(const number_t* v)
+  OptimizableGraph::Vertex* OptimizableGraph::Vertex::clone() const
+  {
+    return 0;
+  }
+
+  bool OptimizableGraph::Vertex::setEstimateData(const double* v)
   {
     bool ret = setEstimateDataImpl(v);
     updateCache();
     return ret;
   }
 
-  bool OptimizableGraph::Vertex::getEstimateData(number_t *) const
+  bool OptimizableGraph::Vertex::getEstimateData(double *) const
   {
     return false;
   }
@@ -105,14 +111,14 @@ namespace g2o {
     return -1;
   }
 
-  bool OptimizableGraph::Vertex::setMinimalEstimateData(const number_t* v)
+  bool OptimizableGraph::Vertex::setMinimalEstimateData(const double* v)
   {
     bool ret = setMinimalEstimateDataImpl(v);
     updateCache();
     return ret;
   }
 
-  bool OptimizableGraph::Vertex::getMinimalEstimateData(number_t *) const
+  bool OptimizableGraph::Vertex::getMinimalEstimateData(double *) const
   {
     return false;
   }
@@ -125,30 +131,30 @@ namespace g2o {
 
   OptimizableGraph::Edge::Edge() :
     HyperGraph::Edge(),
-    _dimension(-1), _level(0), _robustKernel(nullptr)
+    _dimension(-1), _level(0), _robustKernel(0)
   {
   }
 
   OptimizableGraph::Edge::~Edge()
   {
-    release(_robustKernel);
+    delete _robustKernel;
   }
 
   OptimizableGraph* OptimizableGraph::Edge::graph(){
     if (! _vertices.size())
-      return nullptr;
+      return 0;
     OptimizableGraph::Vertex* v=(OptimizableGraph::Vertex*)_vertices[0];
     if (!v)
-      return nullptr;
+      return 0;
     return v->graph();
   }
   
   const OptimizableGraph* OptimizableGraph::Edge::graph() const{
     if (! _vertices.size())
-      return nullptr;
+      return 0;
     const OptimizableGraph::Vertex* v=(const OptimizableGraph::Vertex*) _vertices[0];
     if (!v)
-      return nullptr;
+      return 0;
     return v->graph();
   }
 
@@ -164,21 +170,20 @@ namespace g2o {
 
   bool OptimizableGraph::Edge::resolveParameters() {
     if (!graph()) {
-      cerr << __PRETTY_FUNCTION__ << ": edge not registered with a graph" << endl;
+      std::cerr << __PRETTY_FUNCTION__ << ": edge not registered with a graph" << std::endl;
       return false;
     }
     
     assert (_parameters.size() == _parameterIds.size());
-    //cerr << __PRETTY_FUNCTION__ << ": encountered " << _parameters.size() << " parameters" << endl;
+    //std::cerr << __PRETTY_FUNCTION__ << ": encountered " << _parameters.size() << " parameters" << std::endl;
     for (size_t i=0; i<_parameters.size(); i++){
       int index = _parameterIds[i];
       *_parameters[i] = graph()->parameter(index);
-      auto& aux = **_parameters[i];
-      if (typeid(aux).name()!=_parameterTypes[i]){
-        cerr << __PRETTY_FUNCTION__ << ": FATAL, parameter type mismatch - encountered " << typeid(aux).name() << "; should be " << _parameterTypes[i] << endl;
+      if (typeid(std::remove_pointer_t<decltype(*_parameters[i])>).name()!=_parameterTypes[i]){
+        std::cerr << __PRETTY_FUNCTION__ << ": FATAL, parameter type mismatch - encountered " << typeid(std::remove_pointer_t<decltype(*_parameters[i])>).name() << "; should be " << _parameterTypes[i] << std::endl;
       }
       if (!*_parameters[i]) {
-        cerr << __PRETTY_FUNCTION__ << ": FATAL, *_parameters[i] == 0" << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": FATAL, *_parameters[i] == 0" << std::endl;
         return false;
       }
     }
@@ -188,8 +193,7 @@ namespace g2o {
   void OptimizableGraph::Edge::setRobustKernel(RobustKernel* ptr)
   {
     if (_robustKernel)
-      release(_robustKernel);
-
+      delete _robustKernel;
     _robustKernel = ptr;
   }
 
@@ -197,12 +201,12 @@ namespace g2o {
     return true;
   }
 
-  bool OptimizableGraph::Edge::setMeasurementData(const number_t *)
+  bool OptimizableGraph::Edge::setMeasurementData(const double *)
   {
     return false;
   }
 
-  bool OptimizableGraph::Edge::getMeasurementData(number_t *) const
+  bool OptimizableGraph::Edge::getMeasurementData(double *) const
   {
     return false;
   }
@@ -216,9 +220,17 @@ namespace g2o {
     return false;
   }
 
+
+  OptimizableGraph::Edge* OptimizableGraph::Edge::clone() const
+  {
+    // TODO
+    return 0;
+  }
+
+
   OptimizableGraph::OptimizableGraph()
   {
-    _nextEdgeId = 0;
+    _nextEdgeId = 0; _edge_has_id = false;
     _graphActions.resize(AT_NUM_ELEMENTS);
   }
 
@@ -228,105 +240,55 @@ namespace g2o {
     clearParameters();
   }
 
-  bool OptimizableGraph::addVertex(OptimizableGraph::Vertex* ov, Data* userData)
+  bool OptimizableGraph::addVertex(HyperGraph::Vertex* v, Data* userData)
   {
-    if (ov->id() <0){
-      cerr << __FUNCTION__ << ": FATAL, a vertex with (negative) ID " << ov->id() << " cannot be inserted in the graph" << endl;
-      assert(0 && "Invalid vertex id");
-      return false;
-    }
-    Vertex* inserted = vertex(ov->id());
+    Vertex* inserted = vertex(v->id());
     if (inserted) {
-      cerr << __FUNCTION__ << ": FATAL, a vertex with ID " << ov->id() << " has already been registered with this graph" << endl;
+      std::cerr << __FUNCTION__ << ": FATAL, a vertex with ID " << v->id() << " has already been registered with this graph" << std::endl;
       assert(0 && "Vertex with this ID already contained in the graph");
       return false;
     }
-    if (ov->_graph != nullptr && ov->_graph != this) {
-      cerr << __FUNCTION__ << ": FATAL, vertex with ID " << ov->id() << " has already registered with another graph " << ov->_graph << endl;
+    OptimizableGraph::Vertex* ov=dynamic_cast<OptimizableGraph::Vertex*>(v);
+    assert(ov && "Vertex does not inherit from OptimizableGraph::Vertex");
+    if (ov->_graph != 0 && ov->_graph != this) {
+      std::cerr << __FUNCTION__ << ": FATAL, vertex with ID " << v->id() << " has already registered with another graph " << ov->_graph << std::endl;
       assert(0 && "Vertex already registered with another graph");
       return false;
     }
     if (userData)
       ov->setUserData(userData);
     ov->_graph=this;
-    return HyperGraph::addVertex(ov);
-  }
-
-  bool OptimizableGraph::addVertex(HyperGraph::Vertex* v, Data* userData) {
-    OptimizableGraph::Vertex* ov = dynamic_cast<OptimizableGraph::Vertex*>(v);
-    assert(ov && "Vertex does not inherit from OptimizableGraph::Vertex");
-    if (!ov) return false;
-
-    return addVertex(ov, userData);
+    return HyperGraph::addVertex(v);
   }
 
-  bool OptimizableGraph::addEdge(OptimizableGraph::Edge* e) {
-    OptimizableGraph* g = e->graph();
-
-    if (g != nullptr && g != this) {
-      cerr << __FUNCTION__ << ": FATAL, edge with ID " << e->id()
-           << " has already registered with another graph " << g << endl;
-      assert(0 && "Edge already registered with another graph");
+  bool OptimizableGraph::addEdge(HyperGraph::Edge* e_)
+  {
+    OptimizableGraph::Edge* e = dynamic_cast<OptimizableGraph::Edge*>(e_);
+    assert(e && "Edge does not inherit from OptimizableGraph::Edge");
+    if (! e)
       return false;
-    }
-
     bool eresult = HyperGraph::addEdge(e);
-    if (!eresult) return false;
-
+    if (! eresult)
+      return false;
     e->_internalId = _nextEdgeId++;
-    if (e->numUndefinedVertices()) return true;
-    if (!e->resolveParameters()) {
-      cerr << __FUNCTION__ << ": FATAL, cannot resolve parameters for edge " << e << endl;
+    if (! e->resolveParameters()){
+      std::cerr << __FUNCTION__ << ": FATAL, cannot resolve parameters for edge " << e << std::endl;
       return false;
     }
-    if (!e->resolveCaches()) {
-      cerr << __FUNCTION__ << ": FATAL, cannot resolve caches for edge " << e << endl;
+    if (! e->resolveCaches()){
+      std::cerr << __FUNCTION__ << ": FATAL, cannot resolve caches for edge " << e << std::endl;
       return false;
     } 
-
     _jacobianWorkspace.updateSize(e);
 
     return true;
   }
 
-  bool OptimizableGraph::addEdge(HyperGraph::Edge* e_)
-  {
-    OptimizableGraph::Edge* e = dynamic_cast<OptimizableGraph::Edge*>(e_);
-    assert(e && "Edge does not inherit from OptimizableGraph::Edge");
-    if (!e)
-      return false;
-    return addEdge(e);
-  }
-
-  bool OptimizableGraph::setEdgeVertex(HyperGraph::Edge* e, int pos, HyperGraph::Vertex* v) {
-    if (!HyperGraph::setEdgeVertex(e, pos, v)) {
-      return false;
-    }
-    if (!e->numUndefinedVertices()) {
-#ifndef NDEBUG
-      OptimizableGraph::Edge* ee = dynamic_cast<OptimizableGraph::Edge*>(e);
-      assert(ee && "Edge is not a OptimizableGraph::Edge");
-#else
-      OptimizableGraph::Edge* ee = static_cast<OptimizableGraph::Edge*>(e);
-#endif
-      if (!ee->resolveParameters()) {
-        cerr << __FUNCTION__ << ": FATAL, cannot resolve parameters for edge " << e << endl;
-        return false;
-      }
-      if (!ee->resolveCaches()) {
-        cerr << __FUNCTION__ << ": FATAL, cannot resolve caches for edge " << e << endl;
-        return false;
-      }
-      _jacobianWorkspace.updateSize(e);
-    }
-    return true;
-  }
-
   int OptimizableGraph::optimize(int /*iterations*/, bool /*online*/) {return 0;}
 
-number_t OptimizableGraph::chi2() const
+double OptimizableGraph::chi2() const
 {
-  number_t chi = 0.0;
+  double chi = 0.0;
   for (OptimizableGraph::EdgeSet::const_iterator it = this->edges().begin(); it != this->edges().end(); ++it) {
     const OptimizableGraph::Edge* e = static_cast<const OptimizableGraph::Edge*>(*it);
     chi += e->chi2();
@@ -334,296 +296,355 @@ number_t OptimizableGraph::chi2() const
   return chi;
 }
 
-void OptimizableGraph::push() {
-  forEachVertex([](OptimizableGraph::Vertex* v) { v->push(); });
-}
-
-void OptimizableGraph::pop() {
-  forEachVertex([](OptimizableGraph::Vertex* v) { v->pop(); });
-}
-
-void OptimizableGraph::discardTop() {
-  forEachVertex([](OptimizableGraph::Vertex* v) { v->discardTop(); });
+void OptimizableGraph::push()
+{
+  for (OptimizableGraph::VertexIDMap::iterator it=_vertices.begin(); it!=_vertices.end(); ++it) {
+    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(it->second);
+    v->push();
+  }
 }
 
-void OptimizableGraph::push(HyperGraph::VertexSet& vset) {
-  forEachVertex(vset, [](OptimizableGraph::Vertex* v) { v->push(); });
+void OptimizableGraph::pop()
+{
+  for (OptimizableGraph::VertexIDMap::iterator it=_vertices.begin(); it!=_vertices.end(); ++it) {
+    OptimizableGraph::Vertex* v= static_cast<OptimizableGraph::Vertex*>(it->second);
+    v->pop();
+  }
 }
 
-void OptimizableGraph::pop(HyperGraph::VertexSet& vset) {
-  forEachVertex(vset, [](OptimizableGraph::Vertex* v) { v->pop(); });
+void OptimizableGraph::discardTop()
+{
+  for (OptimizableGraph::VertexIDMap::iterator it=_vertices.begin(); it!=_vertices.end(); ++it) {
+    OptimizableGraph::Vertex* v= static_cast<OptimizableGraph::Vertex*>(it->second);
+    v->discardTop();
+  }
 }
 
-void OptimizableGraph::discardTop(HyperGraph::VertexSet& vset) {
-  forEachVertex(vset, [](OptimizableGraph::Vertex* v) { v->discardTop(); });
+void OptimizableGraph::push(HyperGraph::VertexSet& vset)
+{
+  for (HyperGraph::VertexSet::iterator it=vset.begin(); it!=vset.end(); ++it) {
+    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(*it);
+    v->push();
+  }
 }
 
-void OptimizableGraph::setFixed(HyperGraph::VertexSet& vset, bool fixed) {
-  forEachVertex(vset, [fixed](OptimizableGraph::Vertex* v) { v->setFixed(fixed); });
+void OptimizableGraph::pop(HyperGraph::VertexSet& vset)
+{
+  for (HyperGraph::VertexSet::iterator it=vset.begin(); it!=vset.end(); ++it) {
+    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(*it);
+    v->pop();
+  }
 }
 
-void OptimizableGraph::forEachVertex(std::function<void(OptimizableGraph::Vertex*)> fn) {
-  for (auto it = _vertices.begin(); it != _vertices.end(); ++it) {
-    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(it->second);
-    fn(v);
+void OptimizableGraph::discardTop(HyperGraph::VertexSet& vset)
+{
+  for (HyperGraph::VertexSet::iterator it=vset.begin(); it!=vset.end(); ++it) {
+    OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(*it);
+    v->discardTop();
   }
 }
 
-void OptimizableGraph::forEachVertex(HyperGraph::VertexSet& vset,
-                                     std::function<void(OptimizableGraph::Vertex*)> fn) {
-  for (auto it = vset.begin(); it != vset.end(); ++it) {
+  void OptimizableGraph::setFixed(HyperGraph::VertexSet& vset, bool fixed)
+{
+  for (HyperGraph::VertexSet::iterator it=vset.begin(); it!=vset.end(); ++it) {
     OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(*it);
-    fn(v);
+    v->setFixed(fixed);
   }
 }
 
-bool OptimizableGraph::load(istream& is)
+
+bool OptimizableGraph::load(std::istream& is, bool createEdges)
 {
-  set<string> warnedUnknownTypes;
-  stringstream currentLine;
-  string token;
+  // scna for the paramers in the whole file
+  if (!_parameters.read(is,&_renamedTypesLookup))
+    return false;
+#ifndef NDEBUG
+  std::cerr << "Loaded " << _parameters.size() << " parameters" << std::endl;
+#endif
+  is.clear();
+  is.seekg(std::ios_base::beg);
+  std::set<std::string> warnedUnknownTypes;
+  std::stringstream currentLine;
+  std::string token;
 
   Factory* factory = Factory::instance();
   HyperGraph::GraphElemBitset elemBitset;
   elemBitset[HyperGraph::HGET_PARAMETER] = 1;
   elemBitset.flip();
 
-  HyperGraph::GraphElemBitset elemParamBitset;
-  elemParamBitset[HyperGraph::HGET_PARAMETER] = 1;
-
-  HyperGraph::DataContainer* previousDataContainer = 0;
+  Vertex* previousVertex = 0;
   Data* previousData = 0;
 
-  int lineNumber = 0;
   while (1) {
     int bytesRead = readLine(is, currentLine);
-    lineNumber++;
-    if (bytesRead == -1) break;
+    if (bytesRead == -1)
+      break;
     currentLine >> token;
-    // cerr << "Token=" << token << endl;
-    if (bytesRead == 0 || token.size() == 0 || token[0] == '#') continue;
+    //std::cerr << "Token=" << token << std::endl;
+    if (bytesRead == 0 || token.size() == 0 || token[0] == '#')
+      continue;
 
     // handle commands encoded in the file
+    bool handledCommand = false;
+    
     if (token == "FIX") {
+      handledCommand = true;
       int id;
       while (currentLine >> id) {
         OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(vertex(id));
         if (v) {
-#ifndef NDEBUG
-          cerr << "Fixing vertex " << v->id() << endl;
-#endif
+#        ifndef NDEBUG
+          std::cerr << "Fixing vertex " << v->id() << std::endl;
+#        endif
           v->setFixed(true);
         } else {
-          cerr << "Warning: Unable to fix vertex with id " << id << ". Not found in the graph."
-               << endl;
+          std::cerr << "Warning: Unable to fix vertex with id " << id << ". Not found in the graph." << std::endl;
         }
       }
-      continue;
     }
 
+    if (handledCommand)
+      continue;
+     
     // do the mapping to an internal type if it matches
     if (_renamedTypesLookup.size() > 0) {
-      map<string, string>::const_iterator foundIt = _renamedTypesLookup.find(token);
+      std::map<std::string, std::string>::const_iterator foundIt = _renamedTypesLookup.find(token);
       if (foundIt != _renamedTypesLookup.end()) {
         token = foundIt->second;
       }
     }
 
-    if (!factory->knowsTag(token)) {
+    if (! factory->knowsTag(token)) {
       if (warnedUnknownTypes.count(token) != 1) {
         warnedUnknownTypes.insert(token);
-        cerr << CL_RED(__PRETTY_FUNCTION__ << " unknown type: " << token) << endl;
-      }
-      continue;
-    }
-
-    // first handle the parameters
-    HyperGraph::HyperGraphElement* pelement = factory->construct(token, elemParamBitset);
-    if (pelement) {  // not a parameter or otherwise unknown tag
-      assert(pelement->elementType() == HyperGraph::HGET_PARAMETER && "Should be a param");
-      Parameter* p = static_cast<Parameter*>(pelement);
-      int pid;
-      currentLine >> pid;
-      p->setId(pid);
-      bool r = p->read(currentLine);
-      if (!r) {
-        cerr << __PRETTY_FUNCTION__ << ": Error reading data " << token << " for parameter " << pid
-             << " at line " << lineNumber << endl;
-        delete p;
-      } else {
-        if (!_parameters.addParameter(p)) {
-          cerr << __PRETTY_FUNCTION__ << ": Parameter of type:" << token << " id:" << pid
-               << " already defined"
-               << " at line " << lineNumber << endl;
-        }
+        std::cerr << CL_RED(__PRETTY_FUNCTION__ << " unknown type: " << token) << std::endl;
       }
       continue;
     }
 
     HyperGraph::HyperGraphElement* element = factory->construct(token, elemBitset);
-    if (dynamic_cast<Vertex*>(element)) {  // it's a vertex type
+    if (dynamic_cast<Vertex*>(element)) { // it's a vertex type
+      //std::cerr << "it is a vertex" << std::endl;
       previousData = 0;
       Vertex* v = static_cast<Vertex*>(element);
       int id;
       currentLine >> id;
       bool r = v->read(currentLine);
-      if (!r)
-        cerr << __PRETTY_FUNCTION__ << ": Error reading vertex " << token << " " << id
-             << " at line " << lineNumber << endl;
+      if (! r)
+        std::cerr << __PRETTY_FUNCTION__ << ": Error reading vertex " << token << " " << id << std::endl;
       v->setId(id);
       if (!addVertex(v)) {
-        cerr << __PRETTY_FUNCTION__ << ": Failure adding Vertex, " << token << " " << id
-             << " at line " << lineNumber << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": Failure adding Vertex, " << token << " " << id << std::endl;
         delete v;
       } else {
-        previousDataContainer = v;
+        previousVertex = v;
       }
-    } else if (dynamic_cast<Edge*>(element)) {
-      // cerr << "it is an edge" << endl;
+    }
+    else if (dynamic_cast<Edge*>(element)) {
+      //std::cerr << "it is an edge" << std::endl;
       previousData = 0;
       Edge* e = static_cast<Edge*>(element);
       int numV = e->vertices().size();
-
-      vector<int> ids;
-      if (e->vertices().size() != 0) {
-        ids.resize(e->vertices().size());
-        for (int l = 0; l < numV; ++l) currentLine >> ids[l];
-      } else {
-        string buff;  // reading the IDs of a dynamically sized edge
-        while (currentLine >> buff) {
-          if (buff == "||") break;
-          ids.push_back(atoi(buff.c_str()));
-          currentLine >> buff;
+      if (_edge_has_id){
+        int id;
+        currentLine >> id;
+        e->setId(id);
+      }
+      //std::cerr << PVAR(token) << " " << PVAR(numV) << std::endl;
+      if (numV == 2) { // it's a pairwise / binary edge type which we handle in a special way
+        int id1, id2;
+        currentLine >> id1 >> id2;
+        Vertex* from = vertex(id1);
+        Vertex* to = vertex(id2);
+        int doInit=0;
+        if ((!from || !to) ) {
+          if (! createEdges) {
+            std::cerr << __PRETTY_FUNCTION__ << ": Unable to find vertices for edge " << token << " " << id1 << " <-> " << id2 << std::endl;
+            delete e;
+          } else {
+            if (! from) {
+              from=e->createFrom();
+              from->setId(id1);
+              addVertex(from);
+              doInit=2;
+            }
+            if (! to) {
+              to=e->createTo();
+              to->setId(id2);
+              addVertex(to);
+              doInit=1;
+            }
+          }
+        }
+        if (from && to) {
+          e->setVertex(0, from);
+          e->setVertex(1, to);
+          e->read(currentLine);
+          if (!addEdge(e)) {
+            std::cerr << __PRETTY_FUNCTION__ << ": Unable to add edge " << token << " " << id1 << " <-> " << id2 << std::endl;
+            delete e;
+          } else {
+            switch (doInit){
+              case 1: 
+                {
+                  HyperGraph::VertexSet fromSet;
+                  fromSet.insert(from);
+                  e->initialEstimate(fromSet, to);
+                  break;
+                }
+              case 2:
+                {
+                  HyperGraph::VertexSet toSet;
+                  toSet.insert(to);
+                  e->initialEstimate(toSet, from);
+                  break;
+                }
+              default:;
+            }
+          }
         }
-        e->resize(numV);
       }
-      bool vertsOkay = true;
-      for (size_t l = 0; l < ids.size(); ++l) {
-        int vertexId = ids[l];
-        if (vertexId != HyperGraph::UnassignedId) {
-          HyperGraph::Vertex* v = vertex(vertexId);
-          if (!v) {
+      else {
+        std::vector<int> ids;
+        ids.resize(numV);
+        for (int l = 0; l < numV; ++l)
+          currentLine >> ids[l];
+        bool vertsOkay = true;
+        for (int l = 0; l < numV; ++l) {
+          e->setVertex(l, vertex(ids[l]));
+          if (e->vertex(l) == 0) {
             vertsOkay = false;
             break;
           }
-          e->setVertex(l, v);
         }
-      }
-      if (!vertsOkay) {
-        cerr << __PRETTY_FUNCTION__ << ": Unable to find vertices for edge " << token << " at line "
-             << lineNumber << " IDs: ";
-        printIdChain(cerr, ids) << std::endl;
-        delete e;
-        e = nullptr;
-      } else {
-        bool r = e->read(currentLine);
-        if (!r || !addEdge(e)) {
-          cerr << __PRETTY_FUNCTION__ << ": Unable to add edge " << token << " at line "
-               << lineNumber << " IDs: ";
-          printIdChain(cerr, ids) << std::endl;
+        if (! vertsOkay) {
+          std::cerr << __PRETTY_FUNCTION__ << ": Unable to find vertices for edge " << token;
+          for (int l = 0; l < numV; ++l) {
+            if (l > 0)
+              std::cerr << " <->";
+            std::cerr << " " << ids[l];
+          }
           delete e;
-          e = nullptr;
+        } else {
+          bool r = e->read(currentLine);
+          if (!r || !addEdge(e)) {
+            std::cerr << __PRETTY_FUNCTION__ << ": Unable to add edge " << token; 
+            for (int l = 0; l < numV; ++l) {
+              if (l > 0)
+                std::cerr << " <->";
+              std::cerr << " " << ids[l];
+            }
+            delete e;
+          }
         }
       }
-
-      previousDataContainer = e;
-    } else if (dynamic_cast<Data*>(element)) {  // reading in the data packet for the vertex
-      // cerr << "read data packet " << token << " vertex " << previousVertex->id() << endl;
+    } else if (dynamic_cast<Data*>(element)) { // reading in the data packet for the vertex
+      //std::cerr << "read data packet " << token << " vertex " << previousVertex->id() << std::endl;
       Data* d = static_cast<Data*>(element);
       bool r = d->read(currentLine);
-      if (!r) {
-        cerr << __PRETTY_FUNCTION__ << ": Error reading data " << token << " at line " << lineNumber
-             << " IDs: " << endl;
-        delete d;
-        previousData = 0;
-      } else if (previousData) {
-        previousData->setNext(d);
-        d->setDataContainer(previousData->dataContainer());
+      if (! r) {
+	std::cerr << __PRETTY_FUNCTION__ << ": Error reading data " << token << " for vertex " << previousVertex->id() << std::endl;
+	delete d;
+	previousData = 0;
+      } else if (previousData){
+	//std::cerr << "chaining" << std::endl;
+	previousData->setNext(d);
         previousData = d;
-      } else if (previousDataContainer) {
-        previousDataContainer->setUserData(d);
-        d->setDataContainer(previousDataContainer);
-        previousData = d;
-        previousDataContainer = 0;
+	//std::cerr << "done" << std::endl;
+      } else if (previousVertex){
+	//std::cerr << "embedding in vertex" << std::endl;
+	previousVertex->setUserData(d);
+	previousData = d;
+	previousVertex = 0;
+	//std::cerr << "done" << std::endl;
       } else {
-        cerr << __PRETTY_FUNCTION__ << ": got data element, but no data container available"
-             << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": got data element, but no vertex available" << std::endl;
         delete d;
-        previousData = 0;
+	previousData = 0;
       }
     }
-  }  // while read line
-
-#ifndef NDEBUG
-  cerr << "Loaded " << _parameters.size() << " parameters" << endl;
-#endif
+  } // while read line
   
   return true;
 }
 
-bool OptimizableGraph::load(const char* filename)
+bool OptimizableGraph::load(const char* filename, bool createEdges)
 {
-  ifstream ifs(filename);
+  std::ifstream ifs(filename);
   if (!ifs) {
-    cerr << __PRETTY_FUNCTION__ << " unable to open file " << filename << endl;
+    std::cerr << __PRETTY_FUNCTION__ << " unable to open file " << filename << std::endl;
     return false;
   }
-  return load(ifs);
+  return load(ifs, createEdges);
 }
 
 bool OptimizableGraph::save(const char* filename, int level) const
 {
-  ofstream ofs(filename);
+  std::ofstream ofs(filename);
   if (!ofs)
     return false;
   return save(ofs, level);
 }
 
-bool OptimizableGraph::save(ostream& os, int level) const
+bool OptimizableGraph::save(std::ostream& os, int level) const
 {
-  // write the parameters to the top of the file
-  if (!_parameters.write(os)) return false;
-  set<Vertex*, VertexIDCompare> verticesToSave; // set sorted by ID
+  if (! _parameters.write(os))
+    return false;
+  std::set<Vertex*, VertexIDCompare> verticesToSave;
   for (HyperGraph::EdgeSet::const_iterator it = edges().begin(); it != edges().end(); ++it) {
     OptimizableGraph::Edge* e = static_cast<OptimizableGraph::Edge*>(*it);
     if (e->level() == level) {
-      for (auto it = e->vertices().begin(); it != e->vertices().end(); ++it) {
-        if (*it) verticesToSave.insert(static_cast<OptimizableGraph::Vertex*>(*it));
+      for (std::vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
+        verticesToSave.insert(static_cast<OptimizableGraph::Vertex*>(*it));
       }
     }
   }
 
-  for (auto v : verticesToSave) saveVertex(os, v);
+  for (std::set<Vertex*, VertexIDCompare>::const_iterator it = verticesToSave.begin(); it != verticesToSave.end(); ++it){
+    OptimizableGraph::Vertex* v = *it;
+    saveVertex(os, v);
+  }
 
-  std::vector<HyperGraph::Edge*> edgesToSave;
-  std::copy_if(edges().begin(), edges().end(), std::back_inserter(edgesToSave),
-               [level](const HyperGraph::Edge* ee) {
-                 const OptimizableGraph::Edge* e = dynamic_cast<const OptimizableGraph::Edge*>(ee);
-                 return (e->level() == level);
-               });
+  EdgeContainer edgesToSave;
+  for (HyperGraph::EdgeSet::const_iterator it = edges().begin(); it != edges().end(); ++it) {
+    const OptimizableGraph::Edge* e = dynamic_cast<const OptimizableGraph::Edge*>(*it);
+    if (e->level() == level)
+      edgesToSave.push_back(const_cast<Edge*>(e));
+  }
   sort(edgesToSave.begin(), edgesToSave.end(), EdgeIDCompare());
-  for (auto e : edgesToSave) saveEdge(os, static_cast<Edge*>(e));
+
+  for (EdgeContainer::const_iterator it = edgesToSave.begin(); it != edgesToSave.end(); ++it) {
+    OptimizableGraph::Edge* e = *it;
+    saveEdge(os, e);
+  }
 
   return os.good();
 }
 
-bool OptimizableGraph::saveSubset(ostream& os, HyperGraph::VertexSet& vset, int level) {
-  if (!_parameters.write(os)) return false;
 
-  for (auto v : vset) saveVertex(os, static_cast<Vertex*>(v));
+bool OptimizableGraph::saveSubset(std::ostream& os, HyperGraph::VertexSet& vset, int level)
+{
+  if (! _parameters.write(os))
+    return false;
 
+  for (HyperGraph::VertexSet::const_iterator it=vset.begin(); it!=vset.end(); it++){
+    OptimizableGraph::Vertex* v = dynamic_cast<OptimizableGraph::Vertex*>(*it);
+    saveVertex(os, v);
+  }
   for (HyperGraph::EdgeSet::const_iterator it = edges().begin(); it != edges().end(); ++it) {
-    OptimizableGraph::Edge* e = dynamic_cast<OptimizableGraph::Edge*>(*it);
-    if (e->level() != level) continue;
+    OptimizableGraph::Edge* e = dynamic_cast< OptimizableGraph::Edge*>(*it);
+    if (e->level() != level)
+      continue;
 
     bool verticesInEdge = true;
-    for (vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
+    for (std::vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
       if (vset.find(*it) == vset.end()) {
         verticesInEdge = false;
         break;
       }
     }
-    if (!verticesInEdge) continue;
+    if (! verticesInEdge)
+      continue;
 
     saveEdge(os, e);
   }
@@ -631,18 +652,56 @@ bool OptimizableGraph::saveSubset(ostream& os, HyperGraph::VertexSet& vset, int
   return os.good();
 }
 
-bool OptimizableGraph::saveSubset(ostream& os, HyperGraph::EdgeSet& eset) {
-  if (!_parameters.write(os)) return false;
-  HyperGraph::VertexSet vset;
-  for (auto e : eset)
-    for (auto v : e->vertices())
-      if (v) vset.insert(v);
+bool OptimizableGraph::saveSubset(std::ostream& os, HyperGraph::EdgeSet& eset)
+{
+  if (!_parameters.write(os))
+    return false;
+  std::set<OptimizableGraph::Vertex*> vset;
+  for (HyperGraph::EdgeSet::const_iterator it = eset.begin(); it != eset.end(); ++it) {
+    HyperGraph::Edge* e = *it;
+    for (std::vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
+      OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(*it);
+      vset.insert(v);
+    }
+  }
+
+  for (std::set<OptimizableGraph::Vertex*>::const_iterator it=vset.begin(); it!=vset.end(); ++it){
+    OptimizableGraph::Vertex* v = dynamic_cast<OptimizableGraph::Vertex*>(*it);
+    saveVertex(os, v);
+  }
+
+  for (HyperGraph::EdgeSet::const_iterator it = eset.begin(); it != eset.end(); ++it) {
+    OptimizableGraph::Edge* e = dynamic_cast< OptimizableGraph::Edge*>(*it);
+    saveEdge(os, e);
+  }
 
-  for (auto v : vset) saveVertex(os, static_cast<Vertex*>(v));
-  for (auto e : eset) saveEdge(os, static_cast<Edge*>(e));
   return os.good();
 }
   
+void OptimizableGraph::addGraph(OptimizableGraph* g){
+  for (HyperGraph::VertexIDMap::iterator it=g->vertices().begin(); it!=g->vertices().end(); ++it){
+    OptimizableGraph::Vertex* v= (OptimizableGraph::Vertex*)(it->second);
+    if (vertex(v->id()))
+      continue;
+    OptimizableGraph::Vertex* v2=v->clone();
+    v2->edges().clear();
+    v2->setHessianIndex(-1);
+    addVertex(v2);
+  }
+  for (HyperGraph::EdgeSet::iterator it=g->edges().begin(); it!=g->edges().end(); ++it){
+    OptimizableGraph::Edge* e = (OptimizableGraph::Edge*)(*it);
+    OptimizableGraph::Edge* en = e->clone();
+    en->resize(e->vertices().size());
+    int cnt = 0;
+    for (std::vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
+      OptimizableGraph::Vertex* v = (OptimizableGraph::Vertex*) vertex((*it)->id());
+      assert(v);
+      en->setVertex(cnt++, v);
+    }
+    addEdge(en);
+  }
+}
+
 int OptimizableGraph::maxDimension() const{
   int maxDim=0;
   for (HyperGraph::VertexIDMap::const_iterator it=vertices().begin(); it!=vertices().end(); ++it){
@@ -655,26 +714,26 @@ int OptimizableGraph::maxDimension() const{
 void OptimizableGraph::setRenamedTypesFromString(const std::string& types)
 {
   Factory* factory = Factory::instance();
-  vector<string> typesMap = strSplit(types, ",");
+  std::vector<std::string> typesMap = strSplit(types, ",");
   for (size_t i = 0; i < typesMap.size(); ++i) {
-    vector<string> m = strSplit(typesMap[i], "=");
+    std::vector<std::string> m = strSplit(typesMap[i], "=");
     if (m.size() != 2) {
-      cerr << __PRETTY_FUNCTION__ << ": unable to extract type map from " << typesMap[i] << endl;
+      std::cerr << __PRETTY_FUNCTION__ << ": unable to extract type map from " << typesMap[i] << std::endl;
       continue;
     }
-    string typeInFile = trim(m[0]);
-    string loadedType = trim(m[1]);
+    std::string typeInFile = trim(m[0]);
+    std::string loadedType = trim(m[1]);
     if (! factory->knowsTag(loadedType)) {
-      cerr << __PRETTY_FUNCTION__ << ": unknown type " << loadedType << endl;
+      std::cerr << __PRETTY_FUNCTION__ << ": unknown type " << loadedType << std::endl;
       continue;
     }
 
     _renamedTypesLookup[typeInFile] = loadedType;
   }
 
-  cerr << "# load look up table" << endl;
+  std::cerr << "# load look up table" << std::endl;
   for (std::map<std::string, std::string>::const_iterator it = _renamedTypesLookup.begin(); it != _renamedTypesLookup.end(); ++it) {
-    cerr << "#\t" << it->first << " -> " << it->second << endl;
+    std::cerr << "#\t" << it->first << " -> " << it->second << std::endl;
   }
 }
 
@@ -684,7 +743,7 @@ bool OptimizableGraph::isSolverSuitable(const OptimizationAlgorithmProperty& sol
   if (vertDims_.size() == 0) {
     auxDims = dimensions();
   }
-  const set<int>& vertDims = vertDims_.size() == 0 ? auxDims : vertDims_;
+  const std::set<int>& vertDims = vertDims_.size() == 0 ? auxDims : vertDims_;
   bool suitableSolver = true;
   if (vertDims.size() == 2) {
     if (solverProperty.requiresMarginalize) {
@@ -711,8 +770,9 @@ std::set<int> OptimizableGraph::dimensions() const
   return auxDims;
 }
 
-void OptimizableGraph::performActions(int iter, HyperGraphActionSet& actions)
+void OptimizableGraph::preIteration(int iter)
 {
+  HyperGraphActionSet& actions = _graphActions[AT_PREITERATION];
   if (actions.size() > 0) {
     HyperGraphAction::ParametersIteration params(iter);
     for (HyperGraphActionSet::iterator it = actions.begin(); it != actions.end(); ++it) {
@@ -721,14 +781,15 @@ void OptimizableGraph::performActions(int iter, HyperGraphActionSet& actions)
   }
 }
 
-void OptimizableGraph::preIteration(int iter)
-{
-  performActions(iter, _graphActions[AT_PREITERATION]);
-}
-
 void OptimizableGraph::postIteration(int iter)
 {
-  performActions(iter, _graphActions[AT_POSTITERATION]);
+  HyperGraphActionSet& actions = _graphActions[AT_POSTITERATION];
+  if (actions.size() > 0) {
+    HyperGraphAction::ParametersIteration params(iter);
+    for (HyperGraphActionSet::iterator it = actions.begin(); it != actions.end(); ++it) {
+      (*(*it))(this, &params);
+    }
+  }
 }
 
 bool OptimizableGraph::addPostIterationAction(HyperGraphAction* action)
@@ -753,62 +814,46 @@ bool OptimizableGraph::removePostIterationAction(HyperGraphAction* action)
   return _graphActions[AT_POSTITERATION].erase(action) > 0;
 }
 
-bool OptimizableGraph::saveUserData(std::ostream& os, HyperGraph::Data* d) const {
-  Factory* factory = Factory::instance();
-  while (d) {  // write the data packet for the vertex
-    string tag = factory->tag(d);
-    if (tag.size() > 0) {
-      os << tag << " ";
-      d->write(os);
-      os << endl;
-    }
-    d = d->next();
-  }
-  return os.good();
-}
-
 bool OptimizableGraph::saveVertex(std::ostream& os, OptimizableGraph::Vertex* v) const
 {
   Factory* factory = Factory::instance();
-  string tag = factory->tag(v);
+  std::string tag = factory->tag(v);
   if (tag.size() > 0) {
     os << tag << " " << v->id() << " ";
     v->write(os);
-    os << endl;
-    saveUserData(os, v->userData());
+    os << std::endl;
+    Data* d=v->userData();
+    while (d) { // write the data packet for the vertex
+      tag = factory->tag(d);
+      if (tag.size() > 0) {
+        os << tag << " ";
+        d->write(os);
+        os << std::endl;
+      }
+      d=d->next();
+    }
     if (v->fixed()) {
-      os << "FIX " << v->id() << endl;
+      os << "FIX " << v->id() << std::endl;
     }
     return os.good();
   }
   return false;
 }
 
-bool OptimizableGraph::saveParameter(std::ostream& os, Parameter* p) const
-{
-  Factory* factory = Factory::instance();
-  string tag = factory->tag(p);
-  if (tag.size() > 0) {
-    os << tag << " " << p->id() << " ";
-    p->write(os);
-    os << endl;
-  }
-  return os.good();
-}
-
 bool OptimizableGraph::saveEdge(std::ostream& os, OptimizableGraph::Edge* e) const
 {
   Factory* factory = Factory::instance();
-  string tag = factory->tag(e);
+  std::string tag = factory->tag(e);
   if (tag.size() > 0) {
     os << tag << " ";
-    for (vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
-      int vertexId = (*it) ? (*it)->id() : HyperGraph::UnassignedId;
-      os << vertexId << " ";
+    if (_edge_has_id)
+      os << e->id() << " ";
+    for (std::vector<HyperGraph::Vertex*>::const_iterator it = e->vertices().begin(); it != e->vertices().end(); ++it) {
+      OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(*it);
+      os << v->id() << " ";
     }
     e->write(os);
-    os << endl;
-    saveUserData(os, e->userData());
+    os << std::endl;
     return os.good();
   }
   return false;
@@ -816,17 +861,16 @@ bool OptimizableGraph::saveEdge(std::ostream& os, OptimizableGraph::Edge* e) con
 
 void OptimizableGraph::clearParameters()
 {
-  HyperGraph::clear();
   _parameters.clear();
 }
 
 bool OptimizableGraph::verifyInformationMatrices(bool verbose) const
 {
   bool allEdgeOk = true;
-  Eigen::SelfAdjointEigenSolver<MatrixX> eigenSolver;
+  Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> eigenSolver;
   for (OptimizableGraph::EdgeSet::const_iterator it = edges().begin(); it != edges().end(); ++it) {
     OptimizableGraph::Edge* e = static_cast<OptimizableGraph::Edge*>(*it);
-    MatrixX::MapType information(e->informationData(), e->dimension(), e->dimension());
+    Eigen::MatrixXd::MapType information(e->informationData(), e->dimension(), e->dimension());
     // test on symmetry
     bool isSymmetric = information.transpose() == information;
     bool okay = isSymmetric;
@@ -840,14 +884,14 @@ bool OptimizableGraph::verifyInformationMatrices(bool verbose) const
     if (! okay) {
       if (verbose) {
         if (! isSymmetric)
-          cerr << "Information Matrix for an edge is not symmetric:";
+          std::cerr << "Information Matrix for an edge is not symmetric:";
         else
-          cerr << "Information Matrix for an edge is not SPD:";
+          std::cerr << "Information Matrix for an edge is not SPD:";
         for (size_t i = 0; i < e->vertices().size(); ++i)
-          cerr << " " << e->vertex(i)->id();
+          std::cerr << " " << e->vertex(i)->id();
         if (isSymmetric)
-          cerr << "\teigenvalues: " << eigenSolver.eigenvalues().transpose();
-        cerr << endl;
+          std::cerr << "\teigenvalues: " << eigenSolver.eigenvalues().transpose();
+        std::cerr << std::endl;
       }
     }
   }
diff --git a/g2o/core/optimizable_graph.h b/g2o/core/optimizable_graph.h
index c007c83f..75ea38f0 100644
--- a/g2o/core/optimizable_graph.h
+++ b/g2o/core/optimizable_graph.h
@@ -27,24 +27,26 @@
 #ifndef G2O_AIS_OPTIMIZABLE_GRAPH_HH_
 #define G2O_AIS_OPTIMIZABLE_GRAPH_HH_
 
-#include <functional>
-#include <iostream>
 #include <set>
+#include <iostream>
+#include <list>
+#include <limits>
+#include <cmath>
 #include <typeinfo>
 
-#include "g2o/stuff/macros.h"
-#include "g2o_core_api.h"
-#include "hyper_graph.h"
-#include "io_helper.h"
-#include "jacobian_workspace.h"
 #include "openmp_mutex.h"
+#include "hyper_graph.h"
 #include "parameter.h"
 #include "parameter_container.h"
+#include "jacobian_workspace.h"
+
+#include "../stuff/macros.h"
 
 namespace g2o {
 
   class HyperGraphAction;
   struct OptimizationAlgorithmProperty;
+  class Cache;
   class CacheContainer;
   class RobustKernel;
 
@@ -59,7 +61,7 @@ namespace g2o {
      also provides basic functionalities to handle the backup/restore
      of portions of the vertices.
    */
-  struct G2O_CORE_API OptimizableGraph : public HyperGraph {
+  struct  OptimizableGraph : public HyperGraph {
 
     enum ActionType {
       AT_PREITERATION, AT_POSTITERATION,
@@ -69,14 +71,35 @@ namespace g2o {
     typedef std::set<HyperGraphAction*>    HyperGraphActionSet;
 
     // forward declarations
-    class G2O_CORE_API Vertex;
-    class G2O_CORE_API Edge;
+    class  Vertex;
+    class  Edge;
 
+    /**
+     * \brief data packet for a vertex. Extend this class to store in the vertices
+     * the potential additional information you need (e.g. images, laser scans, ...).
+     */
+    class  Data : public HyperGraph::HyperGraphElement
+    {
+      friend struct OptimizableGraph;
+      public:
+        virtual ~Data();
+        Data();
+        //! read the data from a stream
+        virtual bool read(std::istream& is) = 0;
+        //! write the data to a stream
+        virtual bool write(std::ostream& os) const = 0;
+        virtual HyperGraph::HyperGraphElementType elementType() const { return HyperGraph::HGET_DATA;}
+        const Data* next() const {return _next;}
+        Data* next() {return _next;}
+        void setNext(Data* next_) { _next = next_; }
+      protected:
+        Data* _next; // linked list of multiple data;
+    };
 
     /**
      * \brief order vertices based on their ID
      */
-    struct G2O_CORE_API VertexIDCompare {
+    struct  VertexIDCompare {
       bool operator() (const Vertex* v1, const Vertex* v2) const
       {
         return v1->id() < v2->id();
@@ -86,15 +109,11 @@ namespace g2o {
     /**
      * \brief order edges based on the internal ID, which is assigned to the edge in addEdge()
      */
-    struct G2O_CORE_API EdgeIDCompare {
+    struct  EdgeIDCompare {
       bool operator() (const Edge* e1, const Edge* e2) const
       {
         return e1->internalId() < e2->internalId();
       }
-      bool operator() (const HyperGraph::Edge* e1, const HyperGraph::Edge* e2) const
-      {
-        return operator()(static_cast<const Edge*>(e1), static_cast<const Edge*>(e2));
-      }
     };
 
     //! vector container for vertices
@@ -105,36 +124,52 @@ namespace g2o {
     /**
      * \brief A general case Vertex for optimization
      */
-    class G2O_CORE_API Vertex : public HyperGraph::Vertex, public HyperGraph::DataContainer {
+    class  Vertex : public HyperGraph::Vertex {
       private:
         friend struct OptimizableGraph;
       public:
         Vertex();
+
+        //! returns a deep copy of the current vertex
+        virtual Vertex* clone() const ;
+
+        //! the user data associated with this vertex
+        const Data* userData() const { return _userData; }
+        Data* userData() { return _userData; }
+
+        void setUserData(Data* obs) { _userData = obs;}
+	void addUserData(Data* obs) { 
+	  if (obs) {
+	    obs->setNext(_userData);
+	    _userData=obs;
+	  }
+	}
+	
         virtual ~Vertex();
 
         //! sets the node to the origin (used in the multilevel stuff)
         void setToOrigin() { setToOriginImpl(); updateCache();}
 
         //! get the element from the hessian matrix
-        virtual const number_t& hessian(int i, int j) const = 0;
-        virtual number_t& hessian(int i, int j) = 0;
-        virtual number_t hessianDeterminant() const = 0;
-        virtual number_t* hessianData() = 0;
+        virtual const double& hessian(int i, int j) const = 0;
+        virtual double& hessian(int i, int j) = 0;
+        virtual double hessianDeterminant() const = 0;
+        virtual double* hessianData() = 0;
 
         /** maps the internal matrix to some external memory location */
-        virtual void mapHessianMemory(number_t* d) = 0;
+        virtual void mapHessianMemory(double* d) = 0;
 
         /**
          * copies the b vector in the array b_
          * @return the number of elements copied
          */
-        virtual int copyB(number_t* b_) const = 0;
+        virtual int copyB(double* b_) const = 0;
 
         //! get the b vector element
-        virtual const number_t& b(int i) const = 0;
-        virtual number_t& b(int i) = 0;
+        virtual const double& b(int i) const = 0;
+        virtual double& b(int i) = 0;
         //! return a pointer to the b vector associated with this vertex
-        virtual number_t* bData() = 0;
+        virtual double* bData() = 0;
 
         /**
          * set the b vector part of this vertex to zero
@@ -145,21 +180,21 @@ namespace g2o {
          * updates the current vertex with the direct solution x += H_ii\b_ii
          * @return the determinant of the inverted hessian
          */
-        virtual number_t solveDirect(number_t lambda=0) = 0;
+        virtual double solveDirect(double lambda=0) = 0;
 
         /**
-         * sets the initial estimate from an array of number_t
+         * sets the initial estimate from an array of double
          * Implement setEstimateDataImpl()
          * @return true on success
          */
-        bool setEstimateData(const number_t* estimate);
+        bool setEstimateData(const double* estimate);
 
         /**
-         * sets the initial estimate from an array of number_t
+         * sets the initial estimate from an array of double
          * Implement setEstimateDataImpl()
          * @return true on success
          */
-        bool setEstimateData(const std::vector<number_t>& estimate) {
+        bool setEstimateData(const std::vector<double>& estimate) { 
 #ifndef NDEBUG
           int dim = estimateDimension();
           assert((dim == -1) || (estimate.size() == std::size_t(dim)));
@@ -168,16 +203,16 @@ namespace g2o {
         };
 
         /**
-         * writes the estimater to an array of number_t
+         * writes the estimater to an array of double
          * @returns true on success
          */
-        virtual bool getEstimateData(number_t* estimate) const;
+        virtual bool getEstimateData(double* estimate) const;
 
         /**
-         * writes the estimater to an array of number_t
+         * writes the estimater to an array of double
          * @returns true on success
          */
-        virtual bool getEstimateData(std::vector<number_t>& estimate) const {
+        virtual bool getEstimateData(std::vector<double>& estimate) const {
           int dim = estimateDimension();
           if (dim < 0)
             return false;
@@ -186,24 +221,24 @@ namespace g2o {
         };
 
         /**
-         * returns the dimension of the extended representation used by get/setEstimate(number_t*)
+         * returns the dimension of the extended representation used by get/setEstimate(double*)
          * -1 if it is not supported
          */
         virtual int estimateDimension() const;
 
         /**
-         * sets the initial estimate from an array of number_t.
+         * sets the initial estimate from an array of double.
          * Implement setMinimalEstimateDataImpl()
          * @return true on success
          */
-        bool setMinimalEstimateData(const number_t* estimate);
+        bool setMinimalEstimateData(const double* estimate);
 
         /**
-         * sets the initial estimate from an array of number_t.
+         * sets the initial estimate from an array of double.
          * Implement setMinimalEstimateDataImpl()
          * @return true on success
          */
-        bool setMinimalEstimateData(const std::vector<number_t>& estimate) {
+        bool setMinimalEstimateData(const std::vector<double>& estimate) {
 #ifndef NDEBUG
           int dim = minimalEstimateDimension();
           assert((dim == -1) || (estimate.size() == std::size_t(dim)));
@@ -212,16 +247,16 @@ namespace g2o {
         };
 
         /**
-         * writes the estimate to an array of number_t
+         * writes the estimate to an array of double
          * @returns true on success
          */
-        virtual bool getMinimalEstimateData(number_t* estimate) const ;
+        virtual bool getMinimalEstimateData(double* estimate) const ;
 
         /**
-         * writes the estimate to an array of number_t
+         * writes the estimate to an array of double
          * @returns true on success
          */
-        virtual bool getMinimalEstimateData(std::vector<number_t>& estimate) const {
+        virtual bool getMinimalEstimateData(std::vector<double>& estimate) const {
           int dim = minimalEstimateDimension();
           if (dim < 0)
             return false;
@@ -230,7 +265,7 @@ namespace g2o {
         };
 
         /**
-         * returns the dimension of the extended representation used by get/setEstimate(number_t*)
+         * returns the dimension of the extended representation used by get/setEstimate(double*)
          * -1 if it is not supported
          */
         virtual int minimalEstimateDimension() const;
@@ -253,7 +288,7 @@ namespace g2o {
          * out the update.
          * Will also call updateCache() to update the caches of depending on the vertex.
          */
-        void oplus(const number_t* v)
+        void oplus(const double* v)
         {
           oplusImpl(v);
           updateCache();
@@ -288,6 +323,7 @@ namespace g2o {
         int colInHessian() const {return _colInHessian;}
 
         const OptimizableGraph* graph() const {return _graph;}
+
         OptimizableGraph* graph() {return _graph;}
 
         /**
@@ -324,32 +360,32 @@ namespace g2o {
          * update the position of the node from the parameters in v.
          * Implement in your class!
          */
-        virtual void oplusImpl(const number_t* v) = 0;
+        virtual void oplusImpl(const double* v) = 0;
 
         //! sets the node to the origin (used in the multilevel stuff)
         virtual void setToOriginImpl() = 0;
 
         /**
-         * writes the estimater to an array of number_t
+         * writes the estimater to an array of double
          * @returns true on success
          */
-        virtual bool setEstimateDataImpl(const number_t* ) { return false;}
+        virtual bool setEstimateDataImpl(const double* ) { return false;}
 
         /**
-         * sets the initial estimate from an array of number_t
+         * sets the initial estimate from an array of double
          * @return true on success
          */
-        virtual bool setMinimalEstimateDataImpl(const number_t* ) { return false;}
+        virtual bool setMinimalEstimateDataImpl(const double* ) { return false;}
 
     };
     
-    class G2O_CORE_API Edge: public HyperGraph::Edge, public HyperGraph::DataContainer {
+    class  Edge: public HyperGraph::Edge {
       private:
         friend struct OptimizableGraph;
-
-    public:
+      public:
         Edge();
         virtual ~Edge();
+        virtual Edge* clone() const;
 
         // indicates if all vertices are fixed
         virtual bool allVerticesFixed() const = 0;
@@ -357,13 +393,13 @@ namespace g2o {
         // computes the error of the edge and stores it in an internal structure
         virtual void computeError() = 0;
 
-        //! sets the measurement from an array of number_t
+        //! sets the measurement from an array of double
         //! @returns true on success
-        virtual bool setMeasurementData(const number_t* m);
+        virtual bool setMeasurementData(const double* m);
 
-        //! writes the measurement to an array of number_t
+        //! writes the measurement to an array of double
         //! @returns true on success
-        virtual bool getMeasurementData(number_t* m) const;
+        virtual bool getMeasurementData(double* m) const;
 
         //! returns the dimension of the measurement in the extended representation which is used
         //! by get/setMeasurement;
@@ -375,7 +411,7 @@ namespace g2o {
          */
         virtual bool setMeasurementFromState();
 
-        //! if NOT NULL, error of this edge will be robustifed with the kernel
+        //! if NOT nullptr, error of this edge will be robustifed with the kernel
         RobustKernel* robustKernel() const { return _robustKernel;}
         /**
          * specify the robust kernel to be used in this edge
@@ -383,15 +419,15 @@ namespace g2o {
         void setRobustKernel(RobustKernel* ptr);
 
         //! returns the error vector cached after calling the computeError;
-        virtual const number_t* errorData() const = 0;
-        virtual number_t* errorData() = 0;
+        virtual const double* errorData() const = 0;
+        virtual double* errorData() = 0;
 
-        //! returns the memory of the information matrix, usable for example with a Eigen::Map<MatrixX>
-        virtual const number_t* informationData() const = 0;
-        virtual number_t* informationData() = 0;
+        //! returns the memory of the information matrix, usable for example with a Eigen::Map<MatrixXd>
+        virtual const double* informationData() const = 0;
+        virtual double* informationData() = 0;
 
         //! computes the chi2 based on the cached error value, only valid after computeError has been called.
-        virtual number_t chi2() const = 0;
+        virtual double chi2() const = 0;
 
         /**
          * Linearizes the constraint in the edge.
@@ -409,7 +445,7 @@ namespace g2o {
          * @param j index of the vertex j (j > i, upper triangular fashion)
          * @param rowMajor if true, will write in rowMajor order to the block. Since EIGEN is columnMajor by default, this results in writing the transposed
          */
-        virtual void mapHessianMemory(number_t* d, int i, int j, bool rowMajor) = 0;
+        virtual void mapHessianMemory(double* d, int i, int j, bool rowMajor) = 0;
 
         /**
          * Linearizes the constraint in the edge in the manifold space, and store
@@ -425,7 +461,7 @@ namespace g2o {
          * The return value may correspond to the cost for initiliaizng the vertex but should be positive if
          * the initialization is possible and negative if not possible.
          */
-        virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) { (void) from; (void) to; return -1.;}
+        virtual double initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) { (void) from; (void) to; return -1.;}
 
         //! returns the level of the edge
         int level() const { return _level;}
@@ -435,9 +471,8 @@ namespace g2o {
         //! returns the dimensions of the error function
         int dimension() const { return _dimension;}
 
-        G2O_ATTRIBUTE_DEPRECATED(virtual Vertex* createFrom()) { return nullptr; }
-        G2O_ATTRIBUTE_DEPRECATED(virtual Vertex* createTo()) { return nullptr; }
-        virtual Vertex* createVertex(int) { return nullptr; }
+        virtual Vertex* createFrom() {return 0;}
+        virtual Vertex* createTo()   {return 0;}
 
         //! read the vertex from a stream, i.e., the internal state of the vertex
         virtual bool read(std::istream& is) = 0;
@@ -459,31 +494,34 @@ namespace g2o {
           _parameterTypes.resize(newSize, typeid(void*).name());
         }
       protected:
-       int _dimension;
-       int _level;
-       RobustKernel* _robustKernel;
-       long long _internalId;
-       std::vector<int> _cacheIds;
-
-       template <typename ParameterType>
-       bool installParameter(ParameterType*& p, size_t argNo, int paramId = -1) {
-         if (argNo >= _parameters.size()) return false;
-         _parameterIds[argNo] = paramId;
-         _parameters[argNo] = (Parameter**)&p;
-         _parameterTypes[argNo] = typeid(ParameterType).name();
-         return true;
-       }
-
-       template <typename CacheType>
-       void resolveCache(CacheType*& cache, OptimizableGraph::Vertex*, const std::string& _type,
-                         const ParameterVector& parameters);
-
-       bool resolveParameters();
-       virtual bool resolveCaches();
-
-       std::vector<std::string> _parameterTypes;
-       std::vector<Parameter**> _parameters;
-       std::vector<int> _parameterIds;
+        int _dimension;
+        int _level;
+        RobustKernel* _robustKernel;
+        long long _internalId;
+
+        std::vector<int> _cacheIds;
+
+        template <typename ParameterType>
+          bool installParameter(ParameterType*& p, size_t argNo, int paramId=-1){
+            if (argNo>=_parameters.size())
+              return false;
+            _parameterIds[argNo] = paramId;
+            _parameters[argNo] = (Parameter**)&p;
+            _parameterTypes[argNo] = typeid(ParameterType).name();
+            return true;
+          }
+
+        template <typename CacheType>
+          void resolveCache(CacheType*& cache, OptimizableGraph::Vertex*, 
+              const std::string& _type, 
+              const ParameterVector& parameters);
+
+        bool resolveParameters();
+        virtual bool resolveCaches();
+
+        std::vector<std::string> _parameterTypes;
+        std::vector<Parameter**> _parameters;
+        std::vector<int> _parameterIds;
     };
 
     //! returns the vertex number <i>id</i> appropriately casted
@@ -496,14 +534,15 @@ namespace g2o {
     OptimizableGraph();
     virtual ~OptimizableGraph();
 
+    //! adds all edges and vertices of the graph <i>g</i> to this graph.
+    void addGraph(OptimizableGraph* g);
+ 
     /**
      * adds a new vertex. The new vertex is then "taken".
      * @return false if a vertex with the same id as v is already in the graph, true otherwise.
      */
     virtual bool addVertex(HyperGraph::Vertex* v, Data* userData);
     virtual bool addVertex(HyperGraph::Vertex* v) { return addVertex(v, 0);}
-    bool addVertex(OptimizableGraph::Vertex* v, Data* userData);
-    bool addVertex(OptimizableGraph::Vertex* v) { return addVertex(v, 0); }
 
     /**
      * adds a new edge.
@@ -511,27 +550,13 @@ namespace g2o {
      * @return false if the insertion does not work (incompatible types of the vertices/missing vertex). true otherwise.
      */
     virtual bool addEdge(HyperGraph::Edge* e);
-    bool addEdge(OptimizableGraph::Edge* e);
-
-    /**
-     * overridden from HyperGraph, to mantain the bookkeeping of the caches/parameters and jacobian workspaces consistent upon a change in the veretx.
-     * @return false if something goes wriong.
-     */
-    virtual bool setEdgeVertex(HyperGraph::Edge* e, int pos, HyperGraph::Vertex* v);
 
     //! returns the chi2 of the current configuration
-    number_t chi2() const;
+    double chi2() const;
 
     //! return the maximum dimension of all vertices in the graph
     int maxDimension() const;
 
-    //! Recompute the size of the Jacobian workspace from all the
-    //! edges in the graph.
-    void recomputeJacobianWorkspaceSize()
-    {
-      _jacobianWorkspace.updateSize(*this, true);
-    }
-
     /**
      * iterates over all vertices and returns a set of all the vertex dimensions in the graph
      */
@@ -565,11 +590,9 @@ namespace g2o {
     //! discard the last backup of the estimate for all variables by removing it from the stack
     virtual void discardTop();
 
-
-
     //! load the graph from a stream. Uses the Factory singleton for creating the vertices and edges.
-    virtual bool load(std::istream& is);
-    bool load(const char* filename);
+    virtual bool load(std::istream& is, bool createEdges=true);
+    bool load(const char* filename, bool createEdges=true);
     //! save the graph to a stream. Again uses the Factory system.
     virtual bool save(std::ostream& os, int level = 0) const;
     //! function provided for convenience, see save() above
@@ -593,7 +616,7 @@ namespace g2o {
     virtual void setFixed(HyperGraph::VertexSet& vset, bool fixed);
 
     /**
-     * set the renamed types lookup from a string, format is for example:
+     * set the renamed types lookup from a std::string, format is for example:
      * VERTEX_CAM=VERTEX_SE3:EXPMAP,EDGE_PROJECT_P2MC=EDGE_PROJECT_XYZ:EXPMAP
      * This will change the occurance of VERTEX_CAM in the file to VERTEX_SE3:EXPMAP
      */
@@ -622,7 +645,7 @@ namespace g2o {
     /**
      * verify that all the information of the edges are semi positive definite, i.e.,
      * all Eigenvalues are >= 0.
-     * @param verbose output edges with not PSD information matrix on cerr
+     * @param verbose output edges with not PSD information matrix on std::cerr
      * @return true if all edges have PSD information matrix
      */
     bool verifyInformationMatrices(bool verbose = false) const;
@@ -630,15 +653,8 @@ namespace g2o {
     // helper functions to save an individual vertex
     bool saveVertex(std::ostream& os, Vertex* v) const;
 
-    // helper function to save an individual parameter
-    bool saveParameter(std::ostream& os, Parameter* v) const;
-
     // helper functions to save an individual edge
     bool saveEdge(std::ostream& os, Edge* e) const;
-
-    // helper functions to save the data packets
-    bool saveUserData(std::ostream& os, HyperGraph::Data* v) const;
-
     //! the workspace for storing the Jacobians of the graph
     JacobianWorkspace& jacobianWorkspace() { return _jacobianWorkspace;}
     const JacobianWorkspace& jacobianWorkspace() const { return _jacobianWorkspace;}
@@ -651,23 +667,16 @@ namespace g2o {
      */
     static bool initMultiThreading();
 
-    inline ParameterContainer& parameters() {return _parameters;}
-    inline const ParameterContainer& parameters() const {return _parameters;}
-
-    //! apply a unary function to all vertices
-    void forEachVertex(std::function<void(OptimizableGraph::Vertex*)> fn);
-    //! apply a unary function to the vertices in vset
-    void forEachVertex(HyperGraph::VertexSet& vset, std::function<void(OptimizableGraph::Vertex*)> fn);
-
   protected:
     std::map<std::string, std::string> _renamedTypesLookup;
     long long _nextEdgeId;
     std::vector<HyperGraphActionSet> _graphActions;
 
+    // do not watch this. To be removed soon, or integrated in a nice way
+    bool _edge_has_id;
+
     ParameterContainer _parameters;
     JacobianWorkspace _jacobianWorkspace;
-
-    void performActions(int iter, HyperGraphActionSet& actions);
   };
   
   /**
diff --git a/g2o/core/optimization_algorithm.cpp b/g2o/core/optimization_algorithm.cpp
index ee1b230e..ca72de7e 100644
--- a/g2o/core/optimization_algorithm.cpp
+++ b/g2o/core/optimization_algorithm.cpp
@@ -26,25 +26,27 @@
 
 #include "optimization_algorithm.h"
 
-using namespace std;
+
 
 namespace g2o {
 
-OptimizationAlgorithm::OptimizationAlgorithm()
-  : _optimizer(nullptr)
-{}
+OptimizationAlgorithm::OptimizationAlgorithm() :
+  _optimizer(0)
+{
+}
 
 OptimizationAlgorithm::~OptimizationAlgorithm()
-{}
+{
+}
 
 void OptimizationAlgorithm::printProperties(std::ostream& os) const
 {
-  os << "------------- Algorithm Properties -------------"  << endl;
+  os << "------------- Algorithm Properties -------------"  << std::endl;
   for (PropertyMap::const_iterator it = _properties.begin(); it != _properties.end(); ++it) {
     BaseProperty* p = it->second;
-    os << it->first << "\t" << p->toString() << endl;
+    os << it->first << "\t" << p->toString() << std::endl;
   }
-  os << "------------------------------------------------" << endl;
+  os << "------------------------------------------------" << std::endl;
 }
 
 bool OptimizationAlgorithm::updatePropertiesFromString(const std::string& propString)
diff --git a/g2o/core/optimization_algorithm.h b/g2o/core/optimization_algorithm.h
index 9dcb7e45..4b1e64f5 100644
--- a/g2o/core/optimization_algorithm.h
+++ b/g2o/core/optimization_algorithm.h
@@ -31,11 +31,10 @@
 #include <utility>
 #include <iosfwd>
 
-#include "g2o/stuff/property.h"
+#include "../stuff/property.h"
 
 #include "hyper_graph.h"
 #include "sparse_block_matrix.h"
-#include "g2o_core_api.h"
 
 namespace g2o {
 
@@ -44,10 +43,10 @@ namespace g2o {
   /**
    * \brief Generic interface for a non-linear solver operating on a graph
    */
-  class G2O_CORE_API OptimizationAlgorithm
+  class  OptimizationAlgorithm
   {
     public:
-      enum G2O_CORE_API SolverResult {Terminate=2, OK=1, Fail=-1};
+      enum  SolverResult {Terminate=2, OK=1, Fail=-1};
       OptimizationAlgorithm();
       virtual ~OptimizationAlgorithm();
 
@@ -68,7 +67,7 @@ namespace g2o {
        * and stores them in given SparseBlockMatrix.
        * If your solver does not support computing the marginals, return false.
        */
-      virtual bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices) = 0;
+      virtual bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices) = 0;
 
       /**
        * update the structures for online processing
diff --git a/g2o/core/optimization_algorithm_dogleg.cpp b/g2o/core/optimization_algorithm_dogleg.cpp
index 6bc15e84..4fb3d54d 100644
--- a/g2o/core/optimization_algorithm_dogleg.cpp
+++ b/g2o/core/optimization_algorithm_dogleg.cpp
@@ -28,59 +28,57 @@
 
 #include <iostream>
 
-#include "g2o/stuff/timeutil.h"
+#include "../stuff/timeutil.h"
 
 #include "block_solver.h"
 #include "sparse_optimizer.h"
 #include "solver.h"
 #include "batch_stats.h"
-using namespace std;
+
 
 namespace g2o {
 
-  OptimizationAlgorithmDogleg::OptimizationAlgorithmDogleg(std::unique_ptr<BlockSolverBase> solver)
-      : OptimizationAlgorithmWithHessian(*solver.get()),
-        m_solver{ std::move(solver) }
+  OptimizationAlgorithmDogleg::OptimizationAlgorithmDogleg(BlockSolverBase* solver) :
+    OptimizationAlgorithmWithHessian(solver)
   {
-    _userDeltaInit = _properties.makeProperty<Property<number_t>>("initialDelta", (number_t)1e4);
-    _maxTrialsAfterFailure = _properties.makeProperty<Property<int>>("maxTrialsAfterFailure", 100);
-    _initialLambda = _properties.makeProperty<Property<number_t>>("initialLambda", (number_t)1e-7);
-    _lamdbaFactor = _properties.makeProperty<Property<number_t>>("lambdaFactor", 10.);
+    _userDeltaInit = _properties.makeProperty<Property<double> >("initialDelta", 1e4);
+    _maxTrialsAfterFailure = _properties.makeProperty<Property<int> >("maxTrialsAfterFailure", 100);
+    _initialLambda = _properties.makeProperty<Property<double> >("initialLambda", 1e-7);
+    _lamdbaFactor = _properties.makeProperty<Property<double> >("lambdaFactor", 10.);
     _delta = _userDeltaInit->value();
     _lastStep = STEP_UNDEFINED;
     _wasPDInAllIterations = true;
-    _lastNumTries = 0;
-    _currentLambda = 0.;
   }
 
   OptimizationAlgorithmDogleg::~OptimizationAlgorithmDogleg()
-  {}
+  {
+  }
 
   OptimizationAlgorithm::SolverResult OptimizationAlgorithmDogleg::solve(int iteration, bool online)
   {
     assert(_optimizer && "_optimizer not set");
-    assert(_solver.optimizer() == _optimizer && "underlying linear solver operates on different graph");
+    assert(_solver->optimizer() == _optimizer && "underlying linear solver operates on different graph");
+    assert(dynamic_cast<BlockSolverBase*>(_solver) && "underlying linear solver is not a block solver");
 
-    BlockSolverBase& blockSolver = static_cast<BlockSolverBase&>(_solver);
+    BlockSolverBase* blockSolver = static_cast<BlockSolverBase*>(_solver);
 
-    if (iteration == 0 && !online)
-    { // built up the CCS structure, here due to easy time measure
-      bool ok = _solver.buildStructure();
+    if (iteration == 0 && !online) { // built up the CCS structure, here due to easy time measure
+      bool ok = _solver->buildStructure();
       if (! ok) {
-        cerr << __PRETTY_FUNCTION__ << ": Failure while building CCS structure" << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": Failure while building CCS structure" << std::endl;
         return OptimizationAlgorithm::Fail;
       }
 
       // init some members to the current size of the problem
-      _hsd.resize(_solver.vectorSize());
-      _hdl.resize(_solver.vectorSize());
-      _auxVector.resize(_solver.vectorSize());
+      _hsd.resize(_solver->vectorSize());
+      _hdl.resize(_solver->vectorSize());
+      _auxVector.resize(_solver->vectorSize());
       _delta = _userDeltaInit->value();
       _currentLambda = _initialLambda->value();
       _wasPDInAllIterations = true;
     }
 
-    number_t t=get_monotonic_time();
+    double t=get_monotonic_time();
     _optimizer->computeActiveErrors();
     G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
     if (globalStats) {
@@ -88,24 +86,24 @@ namespace g2o {
       t=get_monotonic_time();
     }
 
-    number_t currentChi = _optimizer->activeRobustChi2();
+    double currentChi = _optimizer->activeRobustChi2();
 
-    _solver.buildSystem();
+    _solver->buildSystem();
     if (globalStats) {
       globalStats->timeQuadraticForm = get_monotonic_time()-t;
     }
 
-    VectorX::ConstMapType b(_solver.b(), _solver.vectorSize());
+    Eigen::VectorXd::ConstMapType b(_solver->b(), _solver->vectorSize());
 
     // compute alpha
     _auxVector.setZero();
-    blockSolver.multiplyHessian(_auxVector.data(), _solver.b());
-    number_t bNormSquared = b.squaredNorm();
-    number_t alpha = bNormSquared / _auxVector.dot(b);
+    blockSolver->multiplyHessian(_auxVector.data(), _solver->b());
+    double bNormSquared = b.squaredNorm();
+    double alpha = bNormSquared / _auxVector.dot(b);
 
     _hsd = alpha * b;
-    number_t hsdNorm = _hsd.norm();
-    number_t hgnNorm = -1.;
+    double hsdNorm = _hsd.norm();
+    double hgnNorm = -1.;
 
     bool solvedGaussNewton = false;
     bool goodStep = false;
@@ -115,25 +113,24 @@ namespace g2o {
       ++numTries;
 
       if (! solvedGaussNewton) {
-        const number_t minLambda = cst(1e-12);
-        const number_t maxLambda = cst(1e3);
+        const double minLambda = 1e-12;
+        const double maxLambda = 1e3;
         solvedGaussNewton = true;
         // apply a damping factor to enforce positive definite Hessian, if the matrix appeared
         // to be not positive definite in at least one iteration before.
         // We apply a damping factor to obtain a PD matrix.
         bool solverOk = false;
-        while(!solverOk)
-        {
+        while(!solverOk) {
           if (! _wasPDInAllIterations)
-            _solver.setLambda(_currentLambda, true);   // add _currentLambda to the diagonal
-          solverOk = _solver.solve();
+            _solver->setLambda(_currentLambda, true);   // add _currentLambda to the diagonal
+          solverOk = _solver->solve();
           if (! _wasPDInAllIterations)
-            _solver.restoreDiagonal();
+            _solver->restoreDiagonal();
           _wasPDInAllIterations = _wasPDInAllIterations && solverOk;
           if (! _wasPDInAllIterations) {
             // simple strategy to control the damping factor
             if (solverOk) {
-              _currentLambda = std::max(minLambda, _currentLambda / (cst(0.5) * _lamdbaFactor->value()));
+              _currentLambda = std::max(minLambda, _currentLambda / (0.5 * _lamdbaFactor->value()));
             } else {
               _currentLambda *= _lamdbaFactor->value();
               if (_currentLambda > maxLambda) {
@@ -143,10 +140,13 @@ namespace g2o {
             }
           }
         }
-        hgnNorm = VectorX::ConstMapType(_solver.x(), _solver.vectorSize()).norm();
+        if (!solverOk) {
+          return Fail;
+        }
+        hgnNorm = Eigen::VectorXd::ConstMapType(_solver->x(), _solver->vectorSize()).norm();
       }
 
-      VectorX::ConstMapType hgn(_solver.x(), _solver.vectorSize());
+      Eigen::VectorXd::ConstMapType hgn(_solver->x(), _solver->vectorSize());
       assert(hgnNorm >= 0. && "Norm of the GN step is not computed");
 
       if (hgnNorm < _delta) {
@@ -158,13 +158,13 @@ namespace g2o {
         _lastStep = STEP_SD;
       } else {
         _auxVector = hgn - _hsd;  // b - a
-        number_t c = _hsd.dot(_auxVector);
-        number_t bmaSquaredNorm = _auxVector.squaredNorm();
-        number_t beta;
+        double c = _hsd.dot(_auxVector);
+        double bmaSquaredNorm = _auxVector.squaredNorm();
+        double beta;
         if (c <= 0.)
           beta = (-c + sqrt(c*c + bmaSquaredNorm * (_delta*_delta - _hsd.squaredNorm()))) / bmaSquaredNorm;
         else {
-          number_t hsdSqrNorm = _hsd.squaredNorm();
+          double hsdSqrNorm = _hsd.squaredNorm();
           beta = (_delta*_delta - hsdSqrNorm) / (c + sqrt(c*c + bmaSquaredNorm * (_delta*_delta - hsdSqrNorm)));
         }
         assert(beta > 0. && beta < 1 && "Error while computing beta");
@@ -175,19 +175,19 @@ namespace g2o {
 
       // compute the linear gain
       _auxVector.setZero();
-      blockSolver.multiplyHessian(_auxVector.data(), _hdl.data());
-      number_t linearGain = -1 * (_auxVector.dot(_hdl)) + 2 * (b.dot(_hdl));
+      blockSolver->multiplyHessian(_auxVector.data(), _hdl.data());
+      double linearGain = -1 * (_auxVector.dot(_hdl)) + 2 * (b.dot(_hdl));
 
       // apply the update and see what happens
       _optimizer->push();
       _optimizer->update(_hdl.data());
       _optimizer->computeActiveErrors();
-      number_t newChi = _optimizer-> activeRobustChi2();
-      number_t nonLinearGain = currentChi - newChi;
+      double newChi = _optimizer-> activeRobustChi2();
+      double nonLinearGain = currentChi - newChi;
       if (fabs(linearGain) < 1e-12)
-        linearGain = cst(1e-12);
-      number_t rho = nonLinearGain / linearGain;
-      //cerr << PVAR(nonLinearGain) << " " << PVAR(linearGain) << " " << PVAR(rho) << endl;
+        linearGain = 1e-12;
+      double rho = nonLinearGain / linearGain;
+      //std::cerr << PVAR(nonLinearGain) << " " << PVAR(linearGain) << " " << PVAR(rho) << std::endl;
       if (rho > 0) { // step is good and will be accepted
         _optimizer->discardTop();
         goodStep = true;
@@ -197,7 +197,7 @@ namespace g2o {
 
       // update trust region based on the step quality
       if (rho > 0.75)
-          _delta = std::max<number_t>(_delta, 3 * _hdl.norm());
+        _delta = std::max(_delta, 3. * _hdl.norm());
       else if (rho < 0.25)
         _delta *= 0.5;
     } while (!goodStep && numTries < _maxTrialsAfterFailure->value());
diff --git a/g2o/core/optimization_algorithm_dogleg.h b/g2o/core/optimization_algorithm_dogleg.h
index 68622964..e49761ca 100644
--- a/g2o/core/optimization_algorithm_dogleg.h
+++ b/g2o/core/optimization_algorithm_dogleg.h
@@ -28,9 +28,6 @@
 #define G2O_OPTIMIZATION_ALGORITHM_DOGLEG_H
 
 #include "optimization_algorithm_with_hessian.h"
-#include "g2o_core_api.h"
-
-#include <memory>
 
 namespace g2o {
 
@@ -39,7 +36,7 @@ namespace g2o {
   /**
    * \brief Implementation of Powell's Dogleg Algorithm
    */
-  class G2O_CORE_API OptimizationAlgorithmDogleg : public OptimizationAlgorithmWithHessian
+  class  OptimizationAlgorithmDogleg : public OptimizationAlgorithmWithHessian
   {
     public:
       /** \brief type of the step to take */
@@ -53,7 +50,7 @@ namespace g2o {
        * construct the Dogleg algorithm, which will use the given Solver for solving the
        * linearized system.
        */
-      explicit OptimizationAlgorithmDogleg(std::unique_ptr<BlockSolverBase> solver);
+      explicit OptimizationAlgorithmDogleg(BlockSolverBase* solver);
       virtual ~OptimizationAlgorithmDogleg();
 
       virtual SolverResult solve(int iteration, bool online = false);
@@ -63,7 +60,7 @@ namespace g2o {
       //! return the type of the last step taken by the algorithm
       int lastStep() const { return _lastStep;}
       //! return the diameter of the trust region
-      number_t trustRegion() const { return _delta;}
+      double trustRegion() const { return _delta;}
 
       //! convert the type into an integer
       static const char* stepType2Str(int stepType);
@@ -71,24 +68,20 @@ namespace g2o {
     protected:
       // parameters
       Property<int>* _maxTrialsAfterFailure;
-      Property<number_t>* _userDeltaInit;
+      Property<double>* _userDeltaInit;
       // damping to enforce positive definite matrix
-      Property<number_t>* _initialLambda;
-      Property<number_t>* _lamdbaFactor;
+      Property<double>* _initialLambda;
+      Property<double>* _lamdbaFactor;
 
-      VectorX _hsd;        ///< steepest decent step
-      VectorX _hdl;        ///< final dogleg step
-      VectorX _auxVector;  ///< auxilary vector used to perform multiplications or other stuff
+      Eigen::VectorXd _hsd;         ///< steepest decent step
+      Eigen::VectorXd _hdl;         ///< final dogleg step
+      Eigen::VectorXd _auxVector;   ///< auxilary vector used to perform multiplications or other stuff
 
-      number_t _currentLambda;     ///< the damping factor to force positive definite matrix
-      number_t _delta;             ///< trust region
-      int _lastStep;               ///< type of the step taken by the algorithm
-      bool _wasPDInAllIterations;  ///< the matrix we solve was positive definite in all iterations -> if not apply
-                                   ///< damping
+      double _currentLambda;        ///< the damping factor to force positive definite matrix
+      double _delta;                ///< trust region
+      int _lastStep;                ///< type of the step taken by the algorithm
+      bool _wasPDInAllIterations;   ///< the matrix we solve was positive definite in all iterations -> if not apply damping
       int _lastNumTries;
-
-     private:
-      std::unique_ptr<BlockSolverBase> m_solver;
   };
 
 } // end namespace
diff --git a/g2o/core/optimization_algorithm_factory.cpp b/g2o/core/optimization_algorithm_factory.cpp
index 4555f5cd..e2e97e7b 100644
--- a/g2o/core/optimization_algorithm_factory.cpp
+++ b/g2o/core/optimization_algorithm_factory.cpp
@@ -30,7 +30,7 @@
 #include <typeinfo>
 #include <cassert>
 
-using namespace std;
+
 
 namespace g2o {
 
@@ -61,11 +61,11 @@ namespace g2o {
 
   void OptimizationAlgorithmFactory::registerSolver(AbstractOptimizationAlgorithmCreator* c)
   {
-    const string& name = c->property().name;
+    const std::string& name = c->property().name;
     CreatorList::iterator foundIt = findSolver(name);
     if (foundIt != _creator.end()) {
       _creator.erase(foundIt);
-      cerr << "SOLVER FACTORY WARNING: Overwriting Solver creator " << name << endl;
+      std::cerr << "SOLVER FACTORY WARNING: Overwriting Solver creator " << name << std::endl;
       assert(0);
     }
     _creator.push_back(c);
@@ -73,7 +73,7 @@ namespace g2o {
 
   void OptimizationAlgorithmFactory::unregisterSolver(AbstractOptimizationAlgorithmCreator* c)
   {
-    const string& name = c->property().name;
+    const std::string& name = c->property().name;
     CreatorList::iterator foundIt = findSolver(name);
     if (foundIt != _creator.end()) {
       delete *foundIt;
@@ -88,14 +88,14 @@ namespace g2o {
       solverProperty = (*foundIt)->property();
       return (*foundIt)->construct();
     }
-    cerr << "SOLVER FACTORY WARNING: Unable to create solver " << name << endl;
-    return nullptr;
+    std::cerr << "SOLVER FACTORY WARNING: Unable to create solver " << name << std::endl;
+    return 0;
   }
 
   void OptimizationAlgorithmFactory::destroy()
   {
     delete factoryInstance;
-    factoryInstance = nullptr;
+    factoryInstance = 0;
   }
 
   void OptimizationAlgorithmFactory::listSolvers(std::ostream& os) const
@@ -110,7 +110,7 @@ namespace g2o {
       os << sp.name;
       for (size_t i = sp.name.size(); i < solverNameColumnLength; ++i)
         os << ' ';
-      os << sp.type << " \t" << sp.desc << endl;
+      os << sp.desc << std::endl;
     }
   }
 
diff --git a/g2o/core/optimization_algorithm_factory.h b/g2o/core/optimization_algorithm_factory.h
index 7ee06dc8..97e8c420 100644
--- a/g2o/core/optimization_algorithm_factory.h
+++ b/g2o/core/optimization_algorithm_factory.h
@@ -28,12 +28,13 @@
 #define G2O_OPTMIZATION_ALGORITHM_PROPERTY_H
 
 #include "g2o/config.h"
+#include "../stuff/misc.h"
 #include "optimization_algorithm_property.h"
 
 #include <list>
 #include <iostream>
+#include <typeinfo>
 
-#include "g2o_core_api.h"
 
 // define to get some verbose output
 //#define G2O_DEBUG_OPTIMIZATION_ALGORITHM_FACTORY
@@ -41,7 +42,8 @@
 namespace g2o {
 
   // forward decl
-  class G2O_CORE_API OptimizationAlgorithm;
+  class  OptimizationAlgorithm;
+  class  SparseOptimizer;
 
   /**
    * \brief base for allocating an optimization algorithm
@@ -49,7 +51,7 @@ namespace g2o {
    * Allocating a solver for a given optimizer. The method construct() has to be
    * implemented in your derived class to allocate the desired solver.
    */
-  class G2O_CORE_API AbstractOptimizationAlgorithmCreator
+  class  AbstractOptimizationAlgorithmCreator
   {
     public:
       AbstractOptimizationAlgorithmCreator(const OptimizationAlgorithmProperty& p);
@@ -69,7 +71,7 @@ namespace g2o {
    * The Factory is implemented as a sigleton and the single
    * instance can be accessed via the instance() function.
    */
-  class G2O_CORE_API OptimizationAlgorithmFactory
+  class  OptimizationAlgorithmFactory
   {
     public:
       typedef std::list<AbstractOptimizationAlgorithmCreator*>      CreatorList;
@@ -147,44 +149,17 @@ namespace g2o {
 #  define G2O_OAF_IMPORT
 #endif
 
-/**
- * Use the following macro to register a whole library of
- * algorithms to the factory, e.g.,
- * G2O_REGISTER_OPTIMIZATION_LIBRARY(csparse)
- * In another programm that links to your library or loads
- * it via dlopen() (or similar functions) you should indicate
- * the desired usage of the solver by using the
- * G2O_REGISTER_OPTIMIZATION_LIBRARY() macro. Here, you
- * should then provide the same name as to the macro before.
- */
 #define G2O_REGISTER_OPTIMIZATION_LIBRARY(libraryname) \
     extern "C" void G2O_OAF_EXPORT g2o_optimization_library_##libraryname(void) {}
 
-/**
- * see the documentation to G2O_OAF_EXPORT() above.
- * You should but this into your code, if you expect the factory
- * to be able to allocate a solver but it fails. It enforces linking
- * to the library containing the solver. Hence, the usage of the macro
- * should enforce that the library is actually linked with the binary.
- */
 #define G2O_USE_OPTIMIZATION_LIBRARY(libraryname) \
     extern "C" void G2O_OAF_IMPORT g2o_optimization_library_##libraryname(void); \
     static g2o::ForceLinker g2o_force_optimization_algorithm_library_##libraryname(g2o_optimization_library_##libraryname);
 
-/**
- * Similarly to G2O_OAF_IMPORT this macro allows to register a singla
- * more specific algorithm to the library, i.e., gn_var, where gn_var
- * corresponds to a specific instance of csparse based solver for example
- */
 #define G2O_REGISTER_OPTIMIZATION_ALGORITHM(optimizername, instance) \
     extern "C" void G2O_OAF_EXPORT g2o_optimization_algorithm_##optimizername(void) {} \
     static g2o::RegisterOptimizationAlgorithmProxy g_optimization_algorithm_proxy_##optimizername(instance);
 
-/**
- * see the documentation of the macros above.
- * It allows to enforce linking to library that contains a specific
- * solver instance and guarantees its usage with the factory
- */
 #define G2O_USE_OPTIMIZATION_ALGORITHM(optimizername) \
     extern "C" void G2O_OAF_IMPORT g2o_optimization_algorithm_##optimizername(void); \
     static g2o::ForceLinker g2o_force_optimization_algorithm_link_##optimizername(g2o_optimization_algorithm_##optimizername);
diff --git a/g2o/core/optimization_algorithm_gauss_newton.cpp b/g2o/core/optimization_algorithm_gauss_newton.cpp
index acb9bb1c..20e41e01 100644
--- a/g2o/core/optimization_algorithm_gauss_newton.cpp
+++ b/g2o/core/optimization_algorithm_gauss_newton.cpp
@@ -28,32 +28,33 @@
 
 #include <iostream>
 
-#include "g2o/stuff/timeutil.h"
-#include "g2o/stuff/macros.h"
+#include "../stuff/timeutil.h"
+#include "../stuff/macros.h"
 
 #include "solver.h"
 #include "batch_stats.h"
 #include "sparse_optimizer.h"
 
-using namespace std;
 
 namespace g2o {
 
-  OptimizationAlgorithmGaussNewton::OptimizationAlgorithmGaussNewton(std::unique_ptr<Solver> solver)
-    : OptimizationAlgorithmWithHessian(*solver.get()),
-      m_solver{ std::move(solver) }
-  {}
+  OptimizationAlgorithmGaussNewton::OptimizationAlgorithmGaussNewton(Solver* solver) :
+    OptimizationAlgorithmWithHessian(solver)
+  {
+  }
 
   OptimizationAlgorithmGaussNewton::~OptimizationAlgorithmGaussNewton()
-  {}
+  {
+  }
 
   OptimizationAlgorithm::SolverResult OptimizationAlgorithmGaussNewton::solve(int iteration, bool online)
   {
-    assert(_solver.optimizer() == _optimizer && "underlying linear solver operates on different graph");
+    assert(_optimizer && "_optimizer not set");
+    assert(_solver->optimizer() == _optimizer && "underlying linear solver operates on different graph");
     bool ok = true;
     
     //here so that correct component for max-mixtures can be computed before the build structure
-    number_t t=get_monotonic_time();
+    double t=get_monotonic_time();
     _optimizer->computeActiveErrors();
     G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
     if (globalStats) {
@@ -61,27 +62,27 @@ namespace g2o {
     }
     
     if (iteration == 0 && !online) { // built up the CCS structure, here due to easy time measure
-      ok = _solver.buildStructure();
+      ok = _solver->buildStructure();
       if (! ok) {
-        cerr << __PRETTY_FUNCTION__ << ": Failure while building CCS structure" << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": Failure while building CCS structure" << std::endl;
         return OptimizationAlgorithm::Fail;
       }
     }
 
     t=get_monotonic_time();
-    _solver.buildSystem();
+    _solver->buildSystem();
     if (globalStats) {
       globalStats->timeQuadraticForm = get_monotonic_time()-t;
       t=get_monotonic_time();
     }
 
-    ok = _solver.solve();
+    ok = _solver->solve();
     if (globalStats) {
       globalStats->timeLinearSolution = get_monotonic_time()-t;
       t=get_monotonic_time();
     }
 
-    _optimizer->update(_solver.x());
+    _optimizer->update(_solver->x());
     if (globalStats) {
       globalStats->timeUpdate = get_monotonic_time()-t;
     }
@@ -94,7 +95,7 @@ namespace g2o {
   void OptimizationAlgorithmGaussNewton::printVerbose(std::ostream& os) const
   {
     os
-      << "\t schur= " << _solver.schur();
+      << "\t schur= " << _solver->schur();
   }
 
 } // end namespace
diff --git a/g2o/core/optimization_algorithm_gauss_newton.h b/g2o/core/optimization_algorithm_gauss_newton.h
index 5acbab65..409aa27c 100644
--- a/g2o/core/optimization_algorithm_gauss_newton.h
+++ b/g2o/core/optimization_algorithm_gauss_newton.h
@@ -27,31 +27,26 @@
 #ifndef G2O_OPTIMIZATION_ALGORITHM_GAUSS_NEWTON_H
 #define G2O_OPTIMIZATION_ALGORITHM_GAUSS_NEWTON_H
 
-#include "g2o_core_api.h"
 #include "optimization_algorithm_with_hessian.h"
-#include <memory>
 
 namespace g2o {
 
   /**
    * \brief Implementation of the Gauss Newton Algorithm
    */
-  class G2O_CORE_API OptimizationAlgorithmGaussNewton : public OptimizationAlgorithmWithHessian
+  class  OptimizationAlgorithmGaussNewton : public OptimizationAlgorithmWithHessian
   {
     public:
       /**
        * construct the Gauss Newton algorithm, which use the given Solver for solving the
        * linearized system.
        */
-      explicit OptimizationAlgorithmGaussNewton(std::unique_ptr<Solver> solver);
+      explicit OptimizationAlgorithmGaussNewton(Solver* solver);
       virtual ~OptimizationAlgorithmGaussNewton();
 
       virtual SolverResult solve(int iteration, bool online = false);
 
       virtual void printVerbose(std::ostream& os) const;
-
-  private:
-    std::unique_ptr<Solver> m_solver;
   };
 
 } // end namespace
diff --git a/g2o/core/optimization_algorithm_levenberg.cpp b/g2o/core/optimization_algorithm_levenberg.cpp
index dece525d..4ad2bb0b 100644
--- a/g2o/core/optimization_algorithm_levenberg.cpp
+++ b/g2o/core/optimization_algorithm_levenberg.cpp
@@ -24,30 +24,34 @@
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+// Modified Raul Mur Artal (2014)
+// - Stop criterium (solve function)
+
 #include "optimization_algorithm_levenberg.h"
 
 #include <iostream>
 
-#include "g2o/stuff/timeutil.h"
+#include "../stuff/timeutil.h"
 
 #include "sparse_optimizer.h"
 #include "solver.h"
 #include "batch_stats.h"
-using namespace std;
+
 
 namespace g2o {
 
-  OptimizationAlgorithmLevenberg::OptimizationAlgorithmLevenberg(std::unique_ptr<Solver> solver)
-      : OptimizationAlgorithmWithHessian(*solver.get()),
-        _currentLambda(cst(-1.)),
-        _tau(cst(1e-5)),
-        _goodStepLowerScale(cst(1. / 3.)),
-        _goodStepUpperScale(cst(2. / 3.)),
-        _ni(cst(2.)),
-        _levenbergIterations(0),
-        m_solver{std::move(solver)} {
-    _userLambdaInit = _properties.makeProperty<Property<number_t> >("initialLambda", 0.);
-    _maxTrialsAfterFailure = _properties.makeProperty<Property<int> >("maxTrialsAfterFailure", 10);
+  OptimizationAlgorithmLevenberg::OptimizationAlgorithmLevenberg(Solver* solver) :
+    OptimizationAlgorithmWithHessian(solver)
+  {
+    _currentLambda = -1.;
+    _tau = 1e-5; // Carlos: originally 1e-5
+    _goodStepUpperScale = 2./3.;
+    _goodStepLowerScale = 1./3.;
+    _userLambdaInit = _properties.makeProperty<Property<double> >("initialLambda", 0.);
+    _maxTrialsAfterFailure = _properties.makeProperty<Property<int> >("maxTrialsAfterFailure", 10); // Carlos: Originally 10 iterations
+    _ni=2.;
+    _levenbergIterations = 0;
+    _nBad = 0;
   }
 
   OptimizationAlgorithmLevenberg::~OptimizationAlgorithmLevenberg()
@@ -57,17 +61,17 @@ namespace g2o {
   OptimizationAlgorithm::SolverResult OptimizationAlgorithmLevenberg::solve(int iteration, bool online)
   {
     assert(_optimizer && "_optimizer not set");
-    assert(_solver.optimizer() == _optimizer && "underlying linear solver operates on different graph");
+    assert(_solver->optimizer() == _optimizer && "underlying linear solver operates on different graph");
 
     if (iteration == 0 && !online) { // built up the CCS structure, here due to easy time measure
-      bool ok = _solver.buildStructure();
+      bool ok = _solver->buildStructure();
       if (! ok) {
-        cerr << __PRETTY_FUNCTION__ << ": Failure while building CCS structure" << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": Failure while building CCS structure" << std::endl;
         return OptimizationAlgorithm::Fail;
       }
     }
 
-    number_t t=get_monotonic_time();
+    double t=get_monotonic_time();
     _optimizer->computeActiveErrors();
     G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
     if (globalStats) {
@@ -75,9 +79,12 @@ namespace g2o {
       t=get_monotonic_time();
     }
 
-    number_t currentChi = _optimizer->activeRobustChi2();
+    double currentChi = _optimizer->activeRobustChi2();
+    double tempChi=currentChi;
 
-    _solver.buildSystem();
+    double iniChi = currentChi;
+
+    _solver->buildSystem();
     if (globalStats) {
       globalStats->timeQuadraticForm = get_monotonic_time()-t;
     }
@@ -86,9 +93,10 @@ namespace g2o {
     if (iteration == 0) {       
       _currentLambda = computeLambdaInit();
       _ni = 2;
+      _nBad = 0;
     }
 
-    number_t rho=0;
+    double rho=0;
     int& qmax = _levenbergIterations;
     qmax = 0;
     do {
@@ -98,36 +106,36 @@ namespace g2o {
         t=get_monotonic_time();
       }
       // update the diagonal of the system matrix
-      _solver.setLambda(_currentLambda, true);
-      bool ok2 = _solver.solve();
+      _solver->setLambda(_currentLambda, true);
+      bool ok2 = _solver->solve();
       if (globalStats) {
         globalStats->timeLinearSolution+=get_monotonic_time()-t;
         t=get_monotonic_time();
       }
-      _optimizer->update(_solver.x());
+      _optimizer->update(_solver->x());
       if (globalStats) {
         globalStats->timeUpdate = get_monotonic_time()-t;
       }
 
       // restore the diagonal
-      _solver.restoreDiagonal();
+      _solver->restoreDiagonal();
 
       _optimizer->computeActiveErrors();
-      number_t tempChi = _optimizer->activeRobustChi2();
-
+      tempChi = _optimizer->activeRobustChi2();
+      // std::cout << "tempChi: " << tempChi << std::endl;
       if (! ok2)
-        tempChi=std::numeric_limits<number_t>::max();
+        tempChi=std::numeric_limits<double>::max();
 
       rho = (currentChi-tempChi);
-      number_t scale = computeScale();
-      scale += cst(1e-3); // make sure it's non-zero :)
+      double scale = computeScale();
+      scale += 1e-3; // make sure it's non-zero :)
       rho /=  scale;
 
       if (rho>0 && g2o_isfinite(tempChi)){ // last step was good
-        number_t alpha = 1.-pow((2*rho-1),3);
+        double alpha = 1.-pow((2*rho-1),3);
         // crop lambda between minimum and maximum factors
         alpha = (std::min)(alpha, _goodStepUpperScale);
-        number_t scaleFactor = (std::max)(_goodStepLowerScale, alpha);
+        double scaleFactor = (std::max)(_goodStepLowerScale, alpha);
         _currentLambda *= scaleFactor;
         _ni = 2;
         currentChi=tempChi;
@@ -136,22 +144,35 @@ namespace g2o {
         _currentLambda*=_ni;
         _ni*=2;
         _optimizer->pop(); // restore the last state before trying to optimize
-        if (!g2o_isfinite(_currentLambda))
-          break;
       }
       qmax++;
     } while (rho<0 && qmax < _maxTrialsAfterFailure->value() && ! _optimizer->terminate());
 
-    if (qmax == _maxTrialsAfterFailure->value() || rho==0 || !g2o_isfinite(_currentLambda))
+    if (qmax == _maxTrialsAfterFailure->value() || rho==0)
+    {
+      // std::cout << "qmax = " << qmax << "             rho = " << rho << std::endl;
       return Terminate;
+    }
+
+    //Stop criterium (Raul)
+    if((iniChi-currentChi)*1e3<iniChi)
+        _nBad++;
+    else
+        _nBad=0;
+
+    if(_nBad>=3)
+    {
+        return Terminate;
+    }
+
     return OK;
   }
 
-  number_t OptimizationAlgorithmLevenberg::computeLambdaInit() const
+  double OptimizationAlgorithmLevenberg::computeLambdaInit() const
   {
     if (_userLambdaInit->value() > 0)
       return _userLambdaInit->value();
-    number_t maxDiagonal=0;
+    double maxDiagonal=0.;
     for (size_t k = 0; k < _optimizer->indexMapping().size(); k++) {
       OptimizableGraph::Vertex* v = _optimizer->indexMapping()[k];
       assert(v);
@@ -163,11 +184,11 @@ namespace g2o {
     return _tau*maxDiagonal;
   }
 
-  number_t OptimizationAlgorithmLevenberg::computeScale() const
+  double OptimizationAlgorithmLevenberg::computeScale() const
   {
-    number_t scale = 0;
-    for (size_t j=0; j < _solver.vectorSize(); j++){
-      scale += _solver.x()[j] * (_currentLambda * _solver.x()[j] + _solver.b()[j]);
+    double scale = 0.;
+    for (size_t j=0; j < _solver->vectorSize(); j++){
+      scale += _solver->x()[j] * (_currentLambda * _solver->x()[j] + _solver->b()[j]);
     }
     return scale;
   }
@@ -177,7 +198,7 @@ namespace g2o {
     _maxTrialsAfterFailure->setValue(max_trials);
   }
 
-  void OptimizationAlgorithmLevenberg::setUserLambdaInit(number_t lambda)
+  void OptimizationAlgorithmLevenberg::setUserLambdaInit(double lambda)
   {
     _userLambdaInit->setValue(lambda);
   }
@@ -185,7 +206,7 @@ namespace g2o {
   void OptimizationAlgorithmLevenberg::printVerbose(std::ostream& os) const
   {
     os
-      << "\t schur= " << _solver.schur()
+      << "\t schur= " << _solver->schur()
       << "\t lambda= " << FIXED(_currentLambda)
       << "\t levenbergIter= " << _levenbergIterations;
   }
diff --git a/g2o/core/optimization_algorithm_levenberg.h b/g2o/core/optimization_algorithm_levenberg.h
index 9ad451d1..bc4a4a06 100644
--- a/g2o/core/optimization_algorithm_levenberg.h
+++ b/g2o/core/optimization_algorithm_levenberg.h
@@ -28,23 +28,20 @@
 #define G2O_SOLVER_LEVENBERG_H
 
 #include "optimization_algorithm_with_hessian.h"
-#include "g2o_core_api.h"
-
-#include <memory>
 
 namespace g2o {
 
   /**
    * \brief Implementation of the Levenberg Algorithm
    */
-  class G2O_CORE_API OptimizationAlgorithmLevenberg : public OptimizationAlgorithmWithHessian
+  class  OptimizationAlgorithmLevenberg : public OptimizationAlgorithmWithHessian
   {
     public:
       /**
        * construct the Levenberg algorithm, which will use the given Solver for solving the
        * linearized system.
        */
-      explicit OptimizationAlgorithmLevenberg(std::unique_ptr<Solver> solver);
+      explicit OptimizationAlgorithmLevenberg(Solver* solver);
       virtual ~OptimizationAlgorithmLevenberg();
 
       virtual SolverResult solve(int iteration, bool online = false);
@@ -52,7 +49,7 @@ namespace g2o {
       virtual void printVerbose(std::ostream& os) const;
 
       //! return the currently used damping factor
-      number_t currentLambda() const { return _currentLambda;}
+      double currentLambda() const { return _currentLambda;}
 
       //! the number of internal iteration if an update step increases chi^2 within Levenberg-Marquardt
       void setMaxTrialsAfterFailure(int max_trials);
@@ -61,9 +58,9 @@ namespace g2o {
       int maxTrialsAfterFailure() const { return _maxTrialsAfterFailure->value();}
 
       //! return the lambda set by the user, if < 0 the SparseOptimizer will compute the initial lambda
-      number_t userLambdaInit() {return _userLambdaInit->value();}
+      double userLambdaInit() {return _userLambdaInit->value();}
       //! specify the initial lambda used for the first iteraion, if not given the SparseOptimizer tries to compute a suitable value
-      void setUserLambdaInit(number_t lambda);
+      void setUserLambdaInit(double lambda);
 
       //! return the number of levenberg iterations performed in the last round
       int levenbergIteration() { return _levenbergIterations;}
@@ -71,23 +68,23 @@ namespace g2o {
     protected:
       // Levenberg parameters
       Property<int>* _maxTrialsAfterFailure;
-      Property<number_t>* _userLambdaInit;
-      number_t _currentLambda;
-      number_t _tau;
-      number_t _goodStepLowerScale; ///< lower bound for lambda decrease if a good LM step
-      number_t _goodStepUpperScale; ///< upper bound for lambda decrease if a good LM step
-      number_t _ni;
+      Property<double>* _userLambdaInit;
+      double _currentLambda;
+      double _tau;
+      double _goodStepLowerScale; ///< lower bound for lambda decrease if a good LM step
+      double _goodStepUpperScale; ///< upper bound for lambda decrease if a good LM step
+      double _ni;
       int _levenbergIterations;   ///< the numer of levenberg iterations performed to accept the last step
+      //RAUL
+      int _nBad;
 
       /**
        * helper for Levenberg, this function computes the initial damping factor, if the user did not
        * specify an own value, see setUserLambdaInit()
        */
-      number_t computeLambdaInit() const;
-      number_t computeScale() const;
+      double computeLambdaInit() const;
+      double computeScale() const;
 
-  private:
-      std::unique_ptr<Solver> m_solver;
   };
 
 } // end namespace
diff --git a/g2o/core/optimization_algorithm_property.h b/g2o/core/optimization_algorithm_property.h
index 54d8e6ec..62abb0ec 100644
--- a/g2o/core/optimization_algorithm_property.h
+++ b/g2o/core/optimization_algorithm_property.h
@@ -29,14 +29,12 @@
 
 #include <string>
 
-#include "g2o_core_api.h"
-
 namespace g2o {
 
 /**
  * \brief describe the properties of a solver
  */
-struct G2O_CORE_API OptimizationAlgorithmProperty
+struct  OptimizationAlgorithmProperty
 {
   std::string name;           ///< name of the solver, e.g., var
   std::string desc;           ///< short description of the solver
diff --git a/g2o/core/optimization_algorithm_with_hessian.cpp b/g2o/core/optimization_algorithm_with_hessian.cpp
index 6e255eee..03730edb 100644
--- a/g2o/core/optimization_algorithm_with_hessian.cpp
+++ b/g2o/core/optimization_algorithm_with_hessian.cpp
@@ -31,11 +31,11 @@
 #include "sparse_optimizer.h"
 
 #include <iostream>
-using namespace std;
+
 
 namespace g2o {
 
-  OptimizationAlgorithmWithHessian::OptimizationAlgorithmWithHessian(Solver& solver) :
+  OptimizationAlgorithmWithHessian::OptimizationAlgorithmWithHessian(Solver* solver) :
     OptimizationAlgorithm(),
     _solver(solver)
   {
@@ -43,12 +43,15 @@ namespace g2o {
   }
 
   OptimizationAlgorithmWithHessian::~OptimizationAlgorithmWithHessian()
-  {}
+  {
+    delete _solver;
+  }
 
   bool OptimizationAlgorithmWithHessian::init(bool online)
   {
     assert(_optimizer && "_optimizer not set");
-    _solver.setWriteDebug(_writeDebug->value());
+    assert(_solver && "Solver not set");
+    _solver->setWriteDebug(_writeDebug->value());
     bool useSchur=false;
     for (OptimizableGraph::VertexContainer::const_iterator it=_optimizer->activeVertices().begin(); it!=_optimizer->activeVertices().end(); ++it) {
       OptimizableGraph::Vertex* v= *it;
@@ -57,39 +60,37 @@ namespace g2o {
         break;
       }
     }
-    if (useSchur)
-    {
-      if  (_solver.supportsSchur())
-        _solver.setSchur(true);
-    }
-    else
-    {
-      if  (_solver.supportsSchur())
-        _solver.setSchur(false);
+    if (useSchur){
+      if  (_solver->supportsSchur())
+        _solver->setSchur(true);
+    } else {
+      if  (_solver->supportsSchur())
+        _solver->setSchur(false);
     }
 
-    bool initState = _solver.init(_optimizer, online);
+    bool initState = _solver->init(_optimizer, online);
     return initState;
   }
 
-  bool OptimizationAlgorithmWithHessian::computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices)
+  bool OptimizationAlgorithmWithHessian::computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices)
   {
-    return _solver.computeMarginals(spinv, blockIndices);
+    return _solver ? _solver->computeMarginals(spinv, blockIndices) : false;
   }
 
   bool OptimizationAlgorithmWithHessian::buildLinearStructure()
   {
-    return _solver.buildStructure();
+    return _solver ? _solver->buildStructure() : false;
   }
 
   void OptimizationAlgorithmWithHessian::updateLinearSystem()
   {
-    _solver.buildSystem();
+    if (_solver)
+      _solver->buildSystem();
   }
 
   bool OptimizationAlgorithmWithHessian::updateStructure(const std::vector<HyperGraph::Vertex*>& vset, const HyperGraph::EdgeSet& edges)
   {
-    return _solver.updateStructure(vset, edges);
+    return _solver ? _solver->updateStructure(vset, edges) : false;
   }
 
   void OptimizationAlgorithmWithHessian::setWriteDebug(bool writeDebug)
diff --git a/g2o/core/optimization_algorithm_with_hessian.h b/g2o/core/optimization_algorithm_with_hessian.h
index 802ab938..8a799c27 100644
--- a/g2o/core/optimization_algorithm_with_hessian.h
+++ b/g2o/core/optimization_algorithm_with_hessian.h
@@ -28,7 +28,6 @@
 #define G2O_OPTIMIZATION_ALGORITHM_WITH_HESSIAN_H
 
 #include "optimization_algorithm.h"
-#include "g2o_core_api.h"
 
 namespace g2o {
 
@@ -37,15 +36,15 @@ namespace g2o {
   /**
    * \brief Base for solvers operating on the approximated Hessian, e.g., Gauss-Newton, Levenberg
    */
-  class G2O_CORE_API OptimizationAlgorithmWithHessian : public OptimizationAlgorithm
+  class  OptimizationAlgorithmWithHessian : public OptimizationAlgorithm
   {
     public:
-      explicit OptimizationAlgorithmWithHessian(Solver& solver);
+      explicit OptimizationAlgorithmWithHessian(Solver* solver);
       virtual ~OptimizationAlgorithmWithHessian();
 
       virtual bool init(bool online = false);
 
-      virtual bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices);
+      virtual bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices);
 
       virtual bool buildLinearStructure();
 
@@ -54,7 +53,7 @@ namespace g2o {
       virtual bool updateStructure(const std::vector<HyperGraph::Vertex*>& vset, const HyperGraph::EdgeSet& edges);
 
       //! return the underlying solver used to solve the linear system
-      Solver& solver() { return _solver;}
+      Solver* solver() { return _solver;}
 
       /**
        * write debug output of the Hessian if system is not positive definite
@@ -63,7 +62,7 @@ namespace g2o {
       virtual bool writeDebug() const { return _writeDebug->value();}
 
     protected:
-      Solver& _solver;
+      Solver* _solver;
       Property<bool>* _writeDebug;
 
   };
diff --git a/g2o/core/ownership.h b/g2o/core/ownership.h
deleted file mode 100644
index 65b5ff70..00000000
--- a/g2o/core/ownership.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef G2O_OWNERSHIP_H
-#define G2O_OWNERSHIP_H
-
-#include <g2o/config.h>
-
-namespace g2o
-{
-    template<typename T>
-    void release(T* obj)
-    {
-        (void)obj;
-#if G2O_DELETE_IMPLICITLY_OWNED_OBJECTS
-        delete obj;
-#endif
-    }
-}
-
-#endif
\ No newline at end of file
diff --git a/g2o/core/parameter.h b/g2o/core/parameter.h
index 82ebafb0..6def6644 100644
--- a/g2o/core/parameter.h
+++ b/g2o/core/parameter.h
@@ -33,7 +33,7 @@
 
 namespace g2o {
 
-    class G2O_CORE_API Parameter : public HyperGraph::HyperGraphElement
+    class  Parameter : public HyperGraph::HyperGraphElement
     {
       public:
         Parameter();
diff --git a/g2o/core/parameter_container.cpp b/g2o/core/parameter_container.cpp
index a63ff402..4d2860cb 100644
--- a/g2o/core/parameter_container.cpp
+++ b/g2o/core/parameter_container.cpp
@@ -31,13 +31,13 @@
 #include "factory.h"
 #include "parameter.h"
 
-#include "g2o/stuff/macros.h"
-#include "g2o/stuff/color_macros.h"
-#include "g2o/stuff/string_tools.h"
+#include "../stuff/macros.h"
+#include "../stuff/color_macros.h"
+#include "../stuff/string_tools.h"
 
 namespace g2o {
 
-  using namespace std;
+  
 
   ParameterContainer::ParameterContainer(bool isMainStorage_) :
     _isMainStorage(isMainStorage_)
@@ -47,7 +47,7 @@ namespace g2o {
   void ParameterContainer::clear() {
     if (!_isMainStorage)
       return;
-    for (iterator it = begin(); it!=end(); ++it){
+    for (iterator it = begin(); it!=end(); it++){
       delete it->second;
     }
     BaseClass::clear();
@@ -63,28 +63,21 @@ namespace g2o {
     iterator it=find(p->id());
     if (it!=end())
       return false;
-    insert(make_pair(p->id(), p));
+    insert(std::make_pair(p->id(), p));
     return true;
   }
 
   Parameter* ParameterContainer::getParameter(int id) {
     iterator it=find(id);
     if (it==end())
-      return nullptr;
-    return it->second;
-  }
-
-  const Parameter* ParameterContainer::getParameter(int id) const {
-    const_iterator it=find(id);
-    if (it==end())
-      return nullptr;
+      return 0;
     return it->second;
   }
 
   Parameter* ParameterContainer::detachParameter(int id){
     iterator it=find(id);
     if (it==end())
-      return nullptr;
+      return 0;
     Parameter* p=it->second;
     erase(it);
     return p;
@@ -92,18 +85,18 @@ namespace g2o {
   
   bool ParameterContainer::write(std::ostream& os) const{
     Factory* factory = Factory::instance();
-    for (const_iterator it=begin(); it!=end(); ++it){
+    for (const_iterator it=begin(); it!=end(); it++){
       os << factory->tag(it->second) << " ";
       os << it->second->id() << " ";
       it->second->write(os);
-      os << endl;
+      os << std::endl;
     }
     return true;
   }
 
   bool ParameterContainer::read(std::istream& is, const std::map<std::string, std::string>* _renamedTypesLookup){
-    stringstream currentLine;
-    string token;
+    std::stringstream currentLine;
+    std::string token;
 
     Factory* factory = Factory::instance();
     HyperGraph::GraphElemBitset elemBitset;
@@ -117,7 +110,7 @@ namespace g2o {
       if (bytesRead == 0 || token.size() == 0 || token[0] == '#')
         continue;
       if (_renamedTypesLookup && _renamedTypesLookup->size()>0){
-	map<string, string>::const_iterator foundIt = _renamedTypesLookup->find(token);
+	std::map<std::string, std::string>::const_iterator foundIt = _renamedTypesLookup->find(token);
 	if (foundIt != _renamedTypesLookup->end()) {
 	  token = foundIt->second;
 	}
@@ -134,11 +127,11 @@ namespace g2o {
       p->setId(pid);
       bool r = p->read(currentLine);
       if (! r) {
-        cerr << __PRETTY_FUNCTION__ << ": Error reading data " << token << " for parameter " << pid << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": Error reading data " << token << " for parameter " << pid << std::endl;
         delete p;
       } else {
         if (! addParameter(p) ){
-          cerr << __PRETTY_FUNCTION__ << ": Parameter of type:" << token << " id:" << pid << " already defined" << endl;
+          std::cerr << __PRETTY_FUNCTION__ << ": Parameter of type:" << token << " id:" << pid << " already defined" << std::endl;
         }
       }
     } // while read line
diff --git a/g2o/core/parameter_container.h b/g2o/core/parameter_container.h
index 03c48281..eef6c2ff 100644
--- a/g2o/core/parameter_container.h
+++ b/g2o/core/parameter_container.h
@@ -53,8 +53,6 @@ namespace g2o {
       bool addParameter(Parameter* p);
       //! return a parameter based on its ID
       Parameter* getParameter(int id);
-      //! return a parameter based on its ID
-      const Parameter* getParameter(int id) const;
       //! remove a parameter from the container, i.e., the user now owns the pointer
       Parameter* detachParameter(int id);
       //! read parameters from a stream
diff --git a/g2o/core/robust_kernel.cpp b/g2o/core/robust_kernel.cpp
index 69340b65..ac6776d8 100644
--- a/g2o/core/robust_kernel.cpp
+++ b/g2o/core/robust_kernel.cpp
@@ -33,12 +33,12 @@ RobustKernel::RobustKernel() :
 {
 }
 
-RobustKernel::RobustKernel(number_t delta) :
+RobustKernel::RobustKernel(double delta) :
   _delta(delta)
 {
 }
 
-void RobustKernel::setDelta(number_t delta)
+void RobustKernel::setDelta(double delta)
 {
   _delta = delta;
 }
diff --git a/g2o/core/robust_kernel.h b/g2o/core/robust_kernel.h
index a142b2a6..29e1394a 100644
--- a/g2o/core/robust_kernel.h
+++ b/g2o/core/robust_kernel.h
@@ -27,9 +27,13 @@
 #ifndef G2O_ROBUST_KERNEL_H
 #define G2O_ROBUST_KERNEL_H
 
+#ifdef _MSC_VER
 #include <memory>
+#else
+#include <tr1/memory>
+#endif
+#include <Eigen/Core>
 
-#include "g2o_core_api.h"
 
 namespace g2o {
 
@@ -44,11 +48,11 @@ namespace g2o {
    *
    * chi^2 = sum_{e} rho( e^T Omega e )
    */
-  class G2O_CORE_API RobustKernel
+  class  RobustKernel
   {
     public:
       RobustKernel();
-      explicit RobustKernel(number_t delta);
+      explicit RobustKernel(double delta);
       virtual ~RobustKernel() {}
       /**
        * compute the scaling factor for a error:
@@ -58,19 +62,19 @@ namespace g2o {
        * rho[1]: First derivative of the scaling function
        * rho[2]: Second derivative of the scaling function
        */
-      virtual void robustify(number_t squaredError, Vector3& rho) const = 0;
+      virtual void robustify(double squaredError, Eigen::Vector3d& rho) const = 0;
 
       /**
        * set the window size of the error. A squared error above delta^2 is considered
        * as outlier in the data.
        */
-      virtual void setDelta(number_t delta);
-      number_t delta() const { return _delta;}
+      virtual void setDelta(double delta);
+      double delta() const { return _delta;}
 
     protected:
-      number_t _delta;
+      double _delta;
   };
-  typedef std::shared_ptr<RobustKernel> RobustKernelPtr;
+  typedef std::tr1::shared_ptr<RobustKernel> RobustKernelPtr;
 
 } // end namespace g2o
 
diff --git a/g2o/core/robust_kernel_factory.cpp b/g2o/core/robust_kernel_factory.cpp
index 3ab9345a..0c6899c3 100644
--- a/g2o/core/robust_kernel_factory.cpp
+++ b/g2o/core/robust_kernel_factory.cpp
@@ -29,7 +29,7 @@
 
 #include <cassert>
 
-using namespace std;
+
 
 namespace g2o {
 
@@ -60,7 +60,7 @@ void RobustKernelFactory::registerRobustKernel(const std::string& tag, AbstractR
 {
   CreatorMap::const_iterator foundIt = _creator.find(tag);
   if (foundIt != _creator.end()) {
-    cerr << "RobustKernelFactory WARNING: Overwriting robust kernel tag " << tag << endl;
+    std::cerr << "RobustKernelFactory WARNING: Overwriting robust kernel tag " << tag << std::endl;
     assert(0);
   }
 
@@ -83,7 +83,7 @@ RobustKernel* RobustKernelFactory::construct(const std::string& tag) const
   if (foundIt != _creator.end()) {
     return foundIt->second->construct();
   }
-  return nullptr;
+  return 0;
 }
 
 AbstractRobustKernelCreator* RobustKernelFactory::creator(const std::string& tag) const
@@ -92,7 +92,7 @@ AbstractRobustKernelCreator* RobustKernelFactory::creator(const std::string& tag
   if (foundIt != _creator.end()) {
     return foundIt->second;
   }
-  return nullptr;
+  return 0;
 }
 
 void RobustKernelFactory::fillKnownKernels(std::vector<std::string>& types) const
diff --git a/g2o/core/robust_kernel_factory.h b/g2o/core/robust_kernel_factory.h
index 84b8bdcf..bcdec07f 100644
--- a/g2o/core/robust_kernel_factory.h
+++ b/g2o/core/robust_kernel_factory.h
@@ -27,7 +27,7 @@
 #ifndef G2O_ROBUST_KERNEL_FACTORY_H
 #define G2O_ROBUST_KERNEL_FACTORY_H
 
-#include "g2o_core_api.h"
+#include "../stuff/misc.h"
 
 #include <string>
 #include <map>
@@ -41,7 +41,7 @@ namespace g2o {
     /**
    * \brief Abstract interface for allocating a robust kernel
    */
-  class G2O_CORE_API AbstractRobustKernelCreator
+  class  AbstractRobustKernelCreator
   {
     public:
       /**
@@ -64,7 +64,7 @@ namespace g2o {
   /**
    * \brief create robust kernels based on their human readable name
    */
-  class G2O_CORE_API RobustKernelFactory
+  class  RobustKernelFactory
   {
     public:
 
@@ -144,7 +144,7 @@ namespace g2o {
 
 #define G2O_USE_ROBUST_KERNEL(classname) \
     extern "C" void G2O_ROBUST_KERNEL_FACTORY_IMPORT g2o_robust_kernel_##classname(void); \
-    static g2o::ForceLinker g2o_force_robust_kernel_link_##classname(g2o_robust_kernel_##classname);
+    static g2o::TypeFunctionProxy proxy_##classname(g2o_robust_kernel_##classname);
 
 } // end namespace g2o
 
diff --git a/g2o/core/robust_kernel_impl.cpp b/g2o/core/robust_kernel_impl.cpp
index 66b5397d..e446efcd 100644
--- a/g2o/core/robust_kernel_impl.cpp
+++ b/g2o/core/robust_kernel_impl.cpp
@@ -31,13 +31,13 @@
 
 namespace g2o {
 
-RobustKernelScaleDelta::RobustKernelScaleDelta(const RobustKernelPtr& kernel, number_t delta) :
+RobustKernelScaleDelta::RobustKernelScaleDelta(const RobustKernelPtr& kernel, double delta) :
   RobustKernel(delta),
   _kernel(kernel)
 {
 }
 
-RobustKernelScaleDelta::RobustKernelScaleDelta(number_t delta) :
+RobustKernelScaleDelta::RobustKernelScaleDelta(double delta) :
   RobustKernel(delta)
 {
 }
@@ -47,11 +47,11 @@ void RobustKernelScaleDelta::setKernel(const RobustKernelPtr& ptr)
   _kernel = ptr;
 }
 
-void RobustKernelScaleDelta::robustify(number_t error, Vector3& rho) const
+void RobustKernelScaleDelta::robustify(double error, Eigen::Vector3d& rho) const
 {
   if (_kernel.get()) {
-    number_t dsqr = _delta * _delta;
-    number_t dsqrReci = 1. / dsqr;
+    double dsqr = _delta * _delta;
+    double dsqrReci = 1. / dsqr;
     _kernel->robustify(dsqrReci * error, rho);
     rho[0] *= dsqr;
     rho[2] *= dsqrReci;
@@ -62,89 +62,81 @@ void RobustKernelScaleDelta::robustify(number_t error, Vector3& rho) const
   }
 }
 
-void RobustKernelHuber::robustify(number_t e, Vector3& rho) const
+void RobustKernelHuber::setDelta(double delta)
 {
-  number_t dsqr = _delta * _delta;
+	dsqr = delta*delta;
+	_delta = delta;
+}
+
+
+void RobustKernelHuber::setDeltaSqr(const double &delta, const double &deltaSqr)
+{
+	dsqr = deltaSqr;
+	_delta = delta;
+}
+
+void RobustKernelHuber::robustify(double e, Eigen::Vector3d& rho) const
+{
+  //dsqr = _delta * _delta;
   if (e <= dsqr) { // inlier
     rho[0] = e;
     rho[1] = 1.;
     rho[2] = 0.;
   } else { // outlier
-    number_t sqrte = sqrt(e); // absolut value of the error
+    double sqrte = sqrt(e); // absolut value of the error
     rho[0] = 2*sqrte*_delta - dsqr; // rho(e)   = 2 * delta * e^(1/2) - delta^2
     rho[1] = _delta / sqrte;        // rho'(e)  = delta / sqrt(e)
     rho[2] = - 0.5 * rho[1] / e;    // rho''(e) = -1 / (2*e^(3/2)) = -1/2 * (delta/e) / e
   }
 }
 
-void RobustKernelPseudoHuber::robustify(number_t e2, Vector3& rho) const
+void RobustKernelTukey::setDeltaSqr(const double &deltaSqr, const double &inv)
 {
-  number_t dsqr = _delta * _delta;
-  number_t dsqrReci = 1. / dsqr;
-  number_t aux1 = dsqrReci * e2 + 1.0;
-  number_t aux2 = sqrt(aux1);
-  rho[0] = 2 * dsqr * (aux2 - 1);
-  rho[1] = 1. / aux2;
-  rho[2] = -0.5 * dsqrReci * rho[1] / aux1;
-}
-
-void RobustKernelCauchy::robustify(number_t e2, Vector3& rho) const
-{
-  number_t dsqr = _delta * _delta;
-  number_t dsqrReci = 1. / dsqr;
-  number_t aux = dsqrReci * e2 + 1.0;
-  rho[0] = dsqr * log(aux);
-  rho[1] = 1. / aux;
-  rho[2] = -dsqrReci * std::pow(rho[1], 2);
-}
+ _deltaSqr = deltaSqr;
+ _invDeltaSqr = inv;
  
-void RobustKernelGemanMcClure::robustify(number_t e2, Vector3& rho) const
-{
-  const number_t aux = _delta / (_delta + e2);
-  rho[0] = e2 * aux;
-  rho[1] = aux * aux;
-  rho[2] = -2. * rho[1] * aux;
 }
 
-void RobustKernelWelsch::robustify(number_t e2, Vector3& rho) const
+void RobustKernelTukey::robustify(double e, Eigen::Vector3d& rho) const
 {
-  const number_t dsqr = _delta * _delta;
-  const number_t aux = e2 / dsqr;
-  const number_t aux2 = exp (-aux);
-  rho[0] = dsqr * (1. - aux2);
-  rho[1] = aux2;
-  rho[2] = -aux2 / dsqr;
+  if (e <= _deltaSqr) { // inlier
+    double factor = e*_invDeltaSqr;
+    double d = 1-factor;
+    double dd = d*d;
+    rho[0] = _deltaSqr*(1-dd*d);
+    rho[1] = 3*dd;
+    rho[2] = -6*_invDeltaSqr*d;
+  } else { // outlier
+    rho[0] = _deltaSqr; // rho(e)   = delta^2
+    rho[1] = 0.;
+    rho[2] = 0.;   
+  }
 }
 
-void RobustKernelFair::robustify(number_t e2, Vector3& rho) const
+void RobustKernelPseudoHuber::robustify(double e2, Eigen::Vector3d& rho) const
 {
-  const number_t sqrte = sqrt(e2);
-  const number_t aux = sqrte / _delta;
-  rho[0] = 2. *  _delta * _delta * (aux - log1p(aux));
-  rho[1] = 1. / (1. + aux);
-  rho[2] = - 0.5 / (sqrte * (1. + aux));
+  double dsqr = _delta * _delta;
+  double dsqrReci = 1. / dsqr;
+  double aux1 = dsqrReci * e2 + 1.0;
+  double aux2 = sqrt(aux1);
+  rho[0] = 2 * dsqr * (aux2 - 1);
+  rho[1] = 1. / aux2;
+  rho[2] = -0.5 * dsqrReci * rho[1] / aux1;
 }
 
-void RobustKernelTukey::robustify(number_t e2, Vector3& rho) const
+void RobustKernelCauchy::robustify(double e2, Eigen::Vector3d& rho) const
 {
-  const number_t e = sqrt(e2);
-  const number_t delta2 = _delta * _delta;
-  if (e <= _delta) {
-    const number_t aux = e2 / delta2;
-    rho[0] = delta2 * (1. - std::pow((1. - aux), 3)) / 3.;
-    rho[1] = std::pow((1. - aux), 2);
-    rho[2] = -2. * (1. - aux) / delta2;
-  } else {
-    rho[0] = delta2 / 3.;
-    rho[1] = 0;
-    rho[2] = 0;
-  }
+  double dsqr = _delta * _delta;
+  double dsqrReci = 1. / dsqr;
+  double aux = dsqrReci * e2 + 1.0;
+  rho[0] = dsqr * log(aux);
+  rho[1] = 1. / aux;
+  rho[2] = -dsqrReci * std::pow(rho[1], 2); 
 }
 
-
-void RobustKernelSaturated::robustify(number_t e2, Vector3& rho) const
+void RobustKernelSaturated::robustify(double e2, Eigen::Vector3d& rho) const
 {
-  number_t dsqr = _delta * _delta;
+  double dsqr = _delta * _delta;
   if (e2 <= dsqr) { // inlier
     rho[0] = e2;
     rho[1] = 1.;
@@ -157,10 +149,10 @@ void RobustKernelSaturated::robustify(number_t e2, Vector3& rho) const
 }
 
 //delta is used as $phi$
-void RobustKernelDCS::robustify(number_t e2, Vector3& rho) const
+void RobustKernelDCS::robustify(double e2, Eigen::Vector3d& rho) const
 {
-  const number_t& phi = _delta;
-  number_t scale = (2.0*phi)/(phi+e2);
+  const double& phi = _delta;
+  double scale = (2.0*phi)/(phi+e2);
   if(scale>=1.0)
     scale = 1.0;
 
@@ -169,14 +161,13 @@ void RobustKernelDCS::robustify(number_t e2, Vector3& rho) const
   rho[2] = 0;    
 }
 
+
 // register the kernel to their factory
 G2O_REGISTER_ROBUST_KERNEL(Huber, RobustKernelHuber)
+G2O_REGISTER_ROBUST_KERNEL(Tukey, RobustKernelTukey)
 G2O_REGISTER_ROBUST_KERNEL(PseudoHuber, RobustKernelPseudoHuber)
 G2O_REGISTER_ROBUST_KERNEL(Cauchy, RobustKernelCauchy)
-G2O_REGISTER_ROBUST_KERNEL(GemanMcClure, RobustKernelGemanMcClure)
-G2O_REGISTER_ROBUST_KERNEL(Welsch, RobustKernelWelsch)
-G2O_REGISTER_ROBUST_KERNEL(Fair, RobustKernelFair)
-G2O_REGISTER_ROBUST_KERNEL(Tukey, RobustKernelTukey)
 G2O_REGISTER_ROBUST_KERNEL(Saturated, RobustKernelSaturated)
 G2O_REGISTER_ROBUST_KERNEL(DCS, RobustKernelDCS)
+
 } // end namespace g2o
diff --git a/g2o/core/robust_kernel_impl.h b/g2o/core/robust_kernel_impl.h
index f069bbcc..066cc37f 100644
--- a/g2o/core/robust_kernel_impl.h
+++ b/g2o/core/robust_kernel_impl.h
@@ -28,7 +28,6 @@
 #define G2O_ROBUST_KERNEL_IMPL_H
 
 #include "robust_kernel.h"
-#include "g2o_core_api.h"
 
 namespace g2o {
 
@@ -39,22 +38,22 @@ namespace g2o {
    * one implements a kernel which only is designed for a fixed window
    * size.
    */
-  class G2O_CORE_API RobustKernelScaleDelta : public RobustKernel
+  class  RobustKernelScaleDelta : public RobustKernel
   {
     public:
       /**
        * construct the scaled kernel ontop of another kernel which might be shared accross
        * several scaled kernels
        */
-      explicit RobustKernelScaleDelta(const RobustKernelPtr& kernel, number_t delta = 1.);
-      explicit RobustKernelScaleDelta(number_t delta = 1.);
+      explicit RobustKernelScaleDelta(const RobustKernelPtr& kernel, double delta = 1.);
+      explicit RobustKernelScaleDelta(double delta = 1.);
 
       //! return the underlying kernel
       const RobustKernelPtr kernel() const { return _kernel;}
       //! use another kernel for the underlying operation
       void setKernel(const RobustKernelPtr& ptr);
 
-      void robustify(number_t error, Vector3& rho) const;
+      void robustify(double error, Eigen::Vector3d& rho) const;
 
     protected:
       RobustKernelPtr _kernel;
@@ -74,12 +73,40 @@ namespace g2o {
    *               1/2    2
    * rho(e) = 2 d e    - d
    */
-  class G2O_CORE_API RobustKernelHuber : public RobustKernel
+  class  RobustKernelHuber : public RobustKernel
   {
     public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
+      virtual void setDelta(double delta);
+      virtual void setDeltaSqr(const double &delta, const double &deltaSqr);
+      virtual void robustify(double e2, Eigen::Vector3d& rho) const;
+
+    private:
+      float dsqr;
+  };
+
+   /**
+   * \brief Tukey Cost Function
+   *
+   *
+   * If e^(1/2) < d
+   * rho(e) = delta2(1-(1-e/delta2)^3)
+   *
+   * else
+   *              
+   * rho(e) = delta2
+   */
+  class  RobustKernelTukey : public RobustKernel
+  {
+    public:
+
+      virtual void setDeltaSqr(const double &deltaSqr, const double &inv);
+      virtual void robustify(double e2, Eigen::Vector3d& rho) const;
+    private:
+      float _deltaSqr;
+      float _invDeltaSqr;
   };
 
+
   /**
    * \brief Pseudo Huber Cost Function
    *
@@ -91,10 +118,10 @@ namespace g2o {
    *             2
    *            d
    */
-  class G2O_CORE_API RobustKernelPseudoHuber : public RobustKernel
+  class  RobustKernelPseudoHuber : public RobustKernel
   {
     public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
+      virtual void robustify(double e2, Eigen::Vector3d& rho) const;
   };
 
   /**
@@ -105,71 +132,10 @@ namespace g2o {
    *         2
    *        d
    */
-  class G2O_CORE_API RobustKernelCauchy : public RobustKernel
+  class  RobustKernelCauchy : public RobustKernel
   {
     public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
-  };
-
-  /**
-   * \brief Geman-McClure cost function
-   *
-   * See http://research.microsoft.com/en-us/um/people/zhang/Papers/ZhangIVC-97-01.pdf
-   * and http://www2.informatik.uni-freiburg.de/~agarwal/resources/agarwal-thesis.pdf
-   *    e2
-   *  -----
-   *  e2 + 1
-   */
-  class G2O_CORE_API RobustKernelGemanMcClure : public RobustKernel
-  {
-    public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
-  };
-
-  /**
-   * \brief Welsch cost function
-   *
-   * See http://research.microsoft.com/en-us/um/people/zhang/Papers/ZhangIVC-97-01.pdf
-   *
-   * d^2 [1 - exp(- e2/d^2)]
-   *
-   */
-  class G2O_CORE_API RobustKernelWelsch : public RobustKernel
-  {
-    public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
-  };
-
-  /**
-   * \brief Fair cost function
-   *
-   * See http://research.microsoft.com/en-us/um/people/zhang/Papers/ZhangIVC-97-01.pdf
-   *
-   * 2 * d^2 [e2 / d - log (1 + e2 / d)]
-   *
-   */
-  class G2O_CORE_API RobustKernelFair : public RobustKernel
-  {
-    public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
-  };
-
-  /**
-   * \brief Tukey Cost Function
-   *
-   * See http://research.microsoft.com/en-us/um/people/zhang/Papers/ZhangIVC-97-01.pdf
-   *
-   * If e2^(1/2) <= d
-   * rho(e) = d^2 * (1 - ( 1 - e2 / d^2)^3) / 3
-   *
-   * else
-   *
-   * rho(e) = d^2 / 3
-   */
-  class G2O_CORE_API RobustKernelTukey : public RobustKernel
-  {
-    public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
+      virtual void robustify(double e2, Eigen::Vector3d& rho) const;
   };
 
   /**
@@ -177,10 +143,10 @@ namespace g2o {
    *
    * The error is at most delta^2
    */
-  class G2O_CORE_API RobustKernelSaturated : public RobustKernel
+  class  RobustKernelSaturated : public RobustKernel
   {
     public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
+      virtual void robustify(double e2, Eigen::Vector3d& rho) const;
   };
 
   /**
@@ -190,11 +156,12 @@ namespace g2o {
    *
    * delta is used as $phi$
    */
-  class G2O_CORE_API RobustKernelDCS : public RobustKernel
+  class  RobustKernelDCS : public RobustKernel
   {
     public:
-      virtual void robustify(number_t e2, Vector3& rho) const;
+      virtual void robustify(double e2, Eigen::Vector3d& rho) const;
   };
+
 } // end namespace g2o
 
 #endif
diff --git a/g2o/core/solver.cpp b/g2o/core/solver.cpp
index 00cbaba7..cdddfac0 100644
--- a/g2o/core/solver.cpp
+++ b/g2o/core/solver.cpp
@@ -25,7 +25,6 @@
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "solver.h"
-#include "dynamic_aligned_buffer.hpp"
 
 #include <cstring>
 #include <algorithm>
@@ -40,8 +39,8 @@ Solver::Solver() :
 
 Solver::~Solver()
 {
-  free_aligned(_x);
-  free_aligned(_b);
+  delete[] _x;
+  delete[] _b;
 }
 
 void Solver::resizeVector(size_t sx)
@@ -51,20 +50,20 @@ void Solver::resizeVector(size_t sx)
   sx += _additionalVectorSpace; // allocate some additional space if requested
   if (_maxXSize < sx) {
     _maxXSize = 2*sx;
-    free_aligned(_x);
-    _x = allocate_aligned<number_t>(_maxXSize);
+    delete[] _x;
+    _x = new double[_maxXSize];
 #ifndef NDEBUG
-    memset(_x, 0, _maxXSize * sizeof(number_t));
+    memset(_x, 0, _maxXSize * sizeof(double));
 #endif
     if (_b) { // backup the former b, might still be needed for online processing
-      memcpy(_x, _b, oldSize * sizeof(number_t));
-      free_aligned(_b);
-      _b = allocate_aligned<number_t>(_maxXSize);
+      memcpy(_x, _b, oldSize * sizeof(double));
+      delete[] _b;
+      _b = new double[_maxXSize];
       std::swap(_b, _x);
     } else {
-      _b = allocate_aligned<number_t>(_maxXSize);
+      _b = new double[_maxXSize];
 #ifndef NDEBUG
-      memset(_b, 0, _maxXSize * sizeof(number_t));
+      memset(_b, 0, _maxXSize * sizeof(double));
 #endif
     }
   }
diff --git a/g2o/core/solver.h b/g2o/core/solver.h
index 454f11b8..41cf6918 100644
--- a/g2o/core/solver.h
+++ b/g2o/core/solver.h
@@ -28,8 +28,8 @@
 #define G2O_SOLVER_H
 
 #include "hyper_graph.h"
+#include "batch_stats.h"
 #include "sparse_block_matrix.h"
-#include "g2o_core_api.h"
 #include <cstddef>
 
 namespace g2o {
@@ -40,7 +40,7 @@ namespace g2o {
   /**
    * \brief Generic interface for a sparse solver operating on a graph which solves one iteration of the linearized objective function
    */
-  class G2O_CORE_API Solver
+  class  Solver
   {
     public:
       Solver();
@@ -74,7 +74,7 @@ namespace g2o {
        * computes the block diagonal elements of the pattern specified in the input
        * and stores them in given SparseBlockMatrix
        */
-      virtual bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices) = 0;
+      virtual bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices) = 0;
 
       /**
        * update the system while performing Levenberg, i.e., modifying the diagonal
@@ -84,7 +84,7 @@ namespace g2o {
        * If backup is true, then the solver should store a backup of the diagonal, which
        * can be restored by restoreDiagonal()
        */
-      virtual bool setLambda(number_t lambda, bool backup = false) = 0;
+      virtual bool setLambda(double lambda, bool backup = false) = 0;
 
       /**
        * restore a previosly made backup of the diagonal
@@ -92,11 +92,11 @@ namespace g2o {
       virtual void restoreDiagonal() = 0;
 
       //! return x, the solution vector
-      number_t* x() { return _x;}
-      const number_t* x() const { return _x;}
+      double* x() { return _x;}
+      const double* x() const { return _x;}
       //! return b, the right hand side of the system
-      number_t* b() { return _b;}
-      const number_t* b() const { return _b;}
+      double* b() { return _b;}
+      const double* b() const { return _b;}
 
       //! return the size of the solution vector (x) and b
       size_t vectorSize() const { return _xSize;}
@@ -133,8 +133,8 @@ namespace g2o {
 
     protected:
       SparseOptimizer* _optimizer;
-      number_t* _x;
-      number_t* _b;
+      double* _x;
+      double* _b;
       size_t _xSize, _maxXSize;
       bool _isLevenberg; ///< the system we gonna solve is a Levenberg-Marquardt system
       size_t _additionalVectorSpace;
diff --git a/g2o/core/sparse_block_matrix.h b/g2o/core/sparse_block_matrix.h
index f54c6591..0cc7181c 100644
--- a/g2o/core/sparse_block_matrix.h
+++ b/g2o/core/sparse_block_matrix.h
@@ -34,16 +34,14 @@
 #include <iomanip>
 #include <cassert>
 #include <Eigen/Core>
-#include <memory>
 
 #include "sparse_block_matrix_ccs.h"
 #include "matrix_structure.h"
 #include "matrix_operations.h"
 #include "g2o/config.h"
-#include "g2o/stuff/misc.h"
-#include "g2o/stuff/sparse_helper.h"
 
 namespace g2o {
+
 /**
  * \brief Sparse matrix which uses blocks
  *
@@ -60,7 +58,7 @@ namespace g2o {
  * block sizes than you have to use a dynamic-block matrix (default
  * template argument).  
  */
-template <class MatrixType = MatrixX >
+template <class MatrixType = Eigen::MatrixXd >
 class SparseBlockMatrix {
 
   public:
@@ -78,7 +76,7 @@ class SparseBlockMatrix {
      * constructs a sparse block matrix having a specific layout
      * @param rbi: array of int containing the row layout of the blocks. 
      * the component i of the array should contain the index of the first row of the block i+1.
-     * @param cbi: array of int containing the column layout of the blocks.
+     * @param rbi: array of int containing the column layout of the blocks. 
      *  the component i of the array should contain the index of the first col of the block i+1.
      * @param rb: number of row blocks
      * @param cb: number of col blocks
@@ -132,33 +130,29 @@ class SparseBlockMatrix {
 
     //! transposes a block matrix, The transposed type should match the argument false on failure
     template <class MatrixTransposedType>
-    bool transpose(SparseBlockMatrix<MatrixTransposedType>& dest) const;
-
-    template <class MatrixTransposedType>
-    std::unique_ptr<SparseBlockMatrix<MatrixTransposedType>> transposed() const;
+    bool transpose(SparseBlockMatrix<MatrixTransposedType>*& dest) const;
 
     //! adds the current matrix to the destination
-    bool add(SparseBlockMatrix<MatrixType>& dest) const;
-    std::unique_ptr<SparseBlockMatrix<MatrixType>> added() const;
+    bool add(SparseBlockMatrix<MatrixType>*& dest) const ;
 
     //! dest = (*this) *  M
     template <class MatrixResultType, class MatrixFactorType>
     bool multiply(SparseBlockMatrix<MatrixResultType> *& dest, const SparseBlockMatrix<MatrixFactorType>* M) const;
 
     //! dest = (*this) *  src
-    void multiply(number_t*& dest, const number_t* src) const;
+    void multiply(double*& dest, const double* src) const;
 
     /**
      * compute dest = (*this) *  src
      * However, assuming that this is a symmetric matrix where only the upper triangle is stored
      */
-    void multiplySymmetricUpperTriangle(number_t*& dest, const number_t* src) const;
+    void multiplySymmetricUpperTriangle(double*& dest, const double* src) const;
 
     //! dest = M * (*this)
-    void rightMultiply(number_t*& dest, const number_t* src) const;
+    void rightMultiply(double*& dest, const double* src) const;
 
     //! *this *= a
-    void scale( number_t a);
+    void scale( double a);
 
     /**
      * writes in dest a block permutaton specified by pinv.
@@ -169,20 +163,17 @@ class SparseBlockMatrix {
     /**
      * fill the CCS arrays of a matrix, arrays have to be allocated beforehand
      */
-    int fillCCS(int* Cp, int* Ci, number_t* Cx, bool upperTriangle = false) const;
+    int fillCCS(int* Cp, int* Ci, double* Cx, bool upperTriangle = false) const;
 
     /**
      * fill the CCS arrays of a matrix, arrays have to be allocated beforehand. This function only writes
      * the values and assumes that column and row structures have already been written.
      */
-    int fillCCS(number_t* Cx, bool upperTriangle = false) const;
+    int fillCCS(double* Cx, bool upperTriangle = false) const;
 
     //! exports the non zero blocks in the structure matrix ms
     void fillBlockStructure(MatrixStructure& ms) const;
 
-    //! exports the non zero blocks into a column compressed structure
-    void fillBlockStructure(int* Cp, int* Ci) const;
-
     //! the block matrices per block-column
     const std::vector<IntBlockMap>& blockCols() const { return _blockCols;}
     std::vector<IntBlockMap>& blockCols() { return _blockCols;}
@@ -226,18 +217,12 @@ class SparseBlockMatrix {
     //! and the block column is stored as a map row_block -> matrix_block_ptr.
     std::vector <IntBlockMap> _blockCols;
     bool _hasStorage;
-
-  private:
-    template <class MatrixTransposedType>
-    void transpose_internal(SparseBlockMatrix<MatrixTransposedType>& dest) const;
-
-    void add_internal(SparseBlockMatrix<MatrixType>& dest) const;
 };
 
 template < class  MatrixType >
 std::ostream& operator << (std::ostream&, const SparseBlockMatrix<MatrixType>& m);
 
-  typedef SparseBlockMatrix<MatrixX> SparseBlockMatrixX;
+  typedef SparseBlockMatrix<Eigen::MatrixXd> SparseBlockMatrixXd;   
 
 } //end namespace
 
diff --git a/g2o/core/sparse_block_matrix.hpp b/g2o/core/sparse_block_matrix.hpp
index 6b3914f2..389bb61f 100644
--- a/g2o/core/sparse_block_matrix.hpp
+++ b/g2o/core/sparse_block_matrix.hpp
@@ -26,6 +26,30 @@
 
 namespace g2o {
   
+
+  namespace {
+    struct TripletEntry
+    {
+      int r, c;
+      double x;
+      TripletEntry(int r_, int c_, double x_) : r(r_), c(c_), x(x_) {}
+    };
+    struct TripletColSort
+    {
+      bool operator()(const TripletEntry& e1, const TripletEntry& e2) const
+      {
+        return e1.c < e2.c || (e1.c == e2.c && e1.r < e2.r);
+      }
+    };
+    /** Helper class to sort pair based on first elem */
+    template<class T1, class T2, class Pred = std::less<T1> >
+    struct CmpPairFirst {
+      bool operator()(const std::pair<T1,T2>& left, const std::pair<T1,T2>& right) {
+        return Pred()(left.first, right.first);
+      }
+    };
+  }
+
   template <class MatrixType>
   SparseBlockMatrix<MatrixType>::SparseBlockMatrix( const int * rbi, const int* cbi, int rb, int cb, bool hasStorage):
     _rowBlockIndices(rbi,rbi+rb),
@@ -70,7 +94,7 @@ namespace g2o {
     typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* _block=0;
     if (it==_blockCols[c].end()){
       if (!_hasStorage && ! alloc )
-        return nullptr;
+        return 0;
       else {
         int rb=rowsOfBlock(r);
         int cb=colsOfBlock(c);
@@ -90,7 +114,7 @@ namespace g2o {
   const typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* SparseBlockMatrix<MatrixType>::block(int r, int c) const {
     typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it =_blockCols[c].find(r);
     if (it==_blockCols[c].end())
-  return nullptr;
+  return 0;
     return it->second;
   }
 
@@ -108,102 +132,69 @@ namespace g2o {
     return ret;
   }
 
-  template <class MatrixType>
-  template <class MatrixTransposedType>
-  void SparseBlockMatrix<MatrixType>::transpose_internal(SparseBlockMatrix<MatrixTransposedType>& dest) const
-  {
-    for (size_t i = 0; i<_blockCols.size(); ++i)
-    {
-      for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it = _blockCols[i].begin(); it != _blockCols[i].end(); ++it)
-      {
-        typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* s = it->second;
-        typename SparseBlockMatrix<MatrixTransposedType>::SparseMatrixBlock* d = dest.block(i, it->first, true);
-        *d = s->transpose();
-      }
-    }
-  }
 
   template <class MatrixType>
   template <class MatrixTransposedType>
-  bool SparseBlockMatrix<MatrixType>::transpose(SparseBlockMatrix<MatrixTransposedType>& dest) const
-  {
-    if (!dest._hasStorage)
-      return false;
-    if (_rowBlockIndices.size() != dest._colBlockIndices.size())
-      return false;
-    if (_colBlockIndices.size() != dest._rowBlockIndices.size())
-      return  false;
-    for (size_t i = 0; i<_rowBlockIndices.size(); ++i)
-    {
-      if (_rowBlockIndices[i] != dest._colBlockIndices[i])
+  bool SparseBlockMatrix<MatrixType>::transpose(SparseBlockMatrix<MatrixTransposedType>*& dest) const {
+    if (! dest){
+      dest=new SparseBlockMatrix<MatrixTransposedType>(&_colBlockIndices[0], &_rowBlockIndices[0], _colBlockIndices.size(), _rowBlockIndices.size());
+    } else {
+      if (! dest->_hasStorage)
         return false;
-    }
-    for (size_t i = 0; i<_colBlockIndices.size(); ++i)
-    {
-      if (_colBlockIndices[i] != dest._rowBlockIndices[i])
+      if(_rowBlockIndices.size()!=dest->_colBlockIndices.size())
         return false;
+      if (_colBlockIndices.size()!=dest->_rowBlockIndices.size())
+        return  false;
+      for (size_t i=0; i<_rowBlockIndices.size(); ++i){
+        if(_rowBlockIndices[i]!=dest->_colBlockIndices[i])
+          return false;
+      }
+      for (size_t i=0; i<_colBlockIndices.size(); ++i){
+        if(_colBlockIndices[i]!=dest->_rowBlockIndices[i])
+          return false;
+      }
     }
 
-    transpose_internal(dest);
-    return true;
-  }
-
-  template <class MatrixType>
-  template <class MatrixTransposedType>
-  std::unique_ptr<SparseBlockMatrix<MatrixTransposedType>> SparseBlockMatrix<MatrixType>::transposed() const
-  {
-    auto dest = g2o::make_unique<SparseBlockMatrix<MatrixTransposedType>>(
-        &_colBlockIndices[0], &_rowBlockIndices[0], _colBlockIndices.size(), _rowBlockIndices.size());
-    transpose_internal(*dest);
-    return std::move(dest);
-  }
-
-  template <class MatrixType>
-  void SparseBlockMatrix<MatrixType>::add_internal(SparseBlockMatrix<MatrixType>& dest) const
-  {
-    for (size_t i = 0; i<_blockCols.size(); ++i)
-    {
-      for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it = _blockCols[i].begin(); it != _blockCols[i].end(); ++it)
-      {
-        typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* s = it->second;
-        typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* d = dest.block(it->first, i, true);
-        (*d) += *s;
+    for (size_t i=0; i<_blockCols.size(); ++i){
+      for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it=_blockCols[i].begin(); it!=_blockCols[i].end(); ++it){
+        typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* s=it->second;
+        typename SparseBlockMatrix<MatrixTransposedType>::SparseMatrixBlock* d=dest->block(i,it->first,true);
+        *d = s->transpose();
       }
     }
+    return true;
   }
 
   template <class MatrixType>
-  bool SparseBlockMatrix<MatrixType>::add(SparseBlockMatrix<MatrixType>& dest) const
-  {
-    if (!dest._hasStorage)
-      return false;
-    if (_rowBlockIndices.size() != dest._rowBlockIndices.size())
-      return false;
-    if (_colBlockIndices.size() != dest._colBlockIndices.size())
-      return  false;
-    for (size_t i = 0; i<_rowBlockIndices.size(); ++i)
-    {
-      if (_rowBlockIndices[i] != dest._rowBlockIndices[i])
+  bool SparseBlockMatrix<MatrixType>::add(SparseBlockMatrix*& dest) const {
+    if (! dest){
+      dest=new SparseBlockMatrix(&_rowBlockIndices[0], &_colBlockIndices[0], _rowBlockIndices.size(), _colBlockIndices.size());
+    } else {
+      if (! dest->_hasStorage)
         return false;
-    }
-    for (size_t i = 0; i<_colBlockIndices.size(); ++i)
-    {
-      if (_colBlockIndices[i] != dest._colBlockIndices[i])
+      if(_rowBlockIndices.size()!=dest->_rowBlockIndices.size())
         return false;
+      if (_colBlockIndices.size()!=dest->_colBlockIndices.size())
+        return  false;
+      for (size_t i=0; i<_rowBlockIndices.size(); ++i){
+        if(_rowBlockIndices[i]!=dest->_rowBlockIndices[i])
+          return false;
+      }
+      for (size_t i=0; i<_colBlockIndices.size(); ++i){
+        if(_colBlockIndices[i]!=dest->_colBlockIndices[i])
+          return false;
+      }
+    }
+    for (size_t i=0; i<_blockCols.size(); ++i){
+      for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it=_blockCols[i].begin(); it!=_blockCols[i].end(); ++it){
+        typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* s=it->second;
+        typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* d=dest->block(it->first,i,true);
+        (*d)+=*s;
+      }
     }
-
-    add_internal(dest);
     return true;
   }
 
-  template <class MatrixType>
-  std::unique_ptr<SparseBlockMatrix<MatrixType>> SparseBlockMatrix<MatrixType>::added() const
-  {
-    auto a = g2o::make_unique<SparseBlockMatrix>(&_rowBlockIndices[0], &_colBlockIndices[0], _rowBlockIndices.size(), _colBlockIndices.size());
-    add_internal(*a);
-    return std::move(a);
-  }
-
   template <class MatrixType>
   template < class MatrixResultType, class MatrixFactorType >
   bool SparseBlockMatrix<MatrixType>::multiply(SparseBlockMatrix<MatrixResultType>*& dest, const SparseBlockMatrix<MatrixFactorType> * M) const {
@@ -241,15 +232,15 @@ namespace g2o {
   }
 
   template <class MatrixType>
-  void SparseBlockMatrix<MatrixType>::multiply(number_t*& dest, const number_t* src) const {
+  void SparseBlockMatrix<MatrixType>::multiply(double*& dest, const double* src) const {
     if (! dest){
-      dest=new number_t [_rowBlockIndices[_rowBlockIndices.size()-1] ];
-      memset(dest,0, _rowBlockIndices[_rowBlockIndices.size()-1]*sizeof(number_t));
+      dest=new double [_rowBlockIndices[_rowBlockIndices.size()-1] ];
+      memset(dest,0, _rowBlockIndices[_rowBlockIndices.size()-1]*sizeof(double));
     }
 
     // map the memory by Eigen
-    Eigen::Map<VectorX> destVec(dest, rows());
-    const Eigen::Map<const VectorX> srcVec(src, cols());
+    Eigen::Map<Eigen::VectorXd> destVec(dest, rows());
+    const Eigen::Map<const Eigen::VectorXd> srcVec(src, cols());
 
     for (size_t i=0; i<_blockCols.size(); ++i){
       int srcOffset = i ? _colBlockIndices[i-1] : 0;
@@ -258,22 +249,22 @@ namespace g2o {
         const typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* a=it->second;
         int destOffset = it->first ? _rowBlockIndices[it->first - 1] : 0;
         // destVec += *a * srcVec (according to the sub-vector parts)
-        internal::template axpy<typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock>(*a, srcVec, srcOffset, destVec, destOffset);
+        internal::axpy(*a, srcVec, srcOffset, destVec, destOffset);
       }
     }
   }
 
   template <class MatrixType>
-  void SparseBlockMatrix<MatrixType>::multiplySymmetricUpperTriangle(number_t*& dest, const number_t* src) const
+  void SparseBlockMatrix<MatrixType>::multiplySymmetricUpperTriangle(double*& dest, const double* src) const
   {
     if (! dest){
-      dest=new number_t [_rowBlockIndices[_rowBlockIndices.size()-1] ];
-      memset(dest,0, _rowBlockIndices[_rowBlockIndices.size()-1]*sizeof(number_t));
+      dest=new double [_rowBlockIndices[_rowBlockIndices.size()-1] ];
+      memset(dest,0, _rowBlockIndices[_rowBlockIndices.size()-1]*sizeof(double));
     }
 
     // map the memory by Eigen
-    Eigen::Map<VectorX> destVec(dest, rows());
-    const Eigen::Map<const VectorX> srcVec(src, cols());
+    Eigen::Map<Eigen::VectorXd> destVec(dest, rows());
+    const Eigen::Map<const Eigen::VectorXd> srcVec(src, cols());
 
     for (size_t i=0; i<_blockCols.size(); ++i){
       int srcOffset = colBaseOfBlock(i);
@@ -283,25 +274,25 @@ namespace g2o {
         if (destOffset > srcOffset) // only upper triangle
           break;
         // destVec += *a * srcVec (according to the sub-vector parts)
-        internal::template axpy<typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock>(*a, srcVec, srcOffset, destVec, destOffset);
+        internal::axpy(*a, srcVec, srcOffset, destVec, destOffset);
         if (destOffset < srcOffset)
-          internal::template atxpy<typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock>(*a, srcVec, destOffset, destVec, srcOffset);
+          internal::atxpy(*a, srcVec, destOffset, destVec, srcOffset);
       }
     }
   }
 
   template <class MatrixType>
-  void SparseBlockMatrix<MatrixType>::rightMultiply(number_t*& dest, const number_t* src) const {
+  void SparseBlockMatrix<MatrixType>::rightMultiply(double*& dest, const double* src) const {
     int destSize=cols();
 
     if (! dest){
-      dest=new number_t [ destSize ];
-      memset(dest,0, destSize*sizeof(number_t));
+      dest=new double [ destSize ];
+      memset(dest,0, destSize*sizeof(double));
     }
 
     // map the memory by Eigen
-    Eigen::Map<VectorX> destVec(dest, destSize);
-    Eigen::Map<const VectorX> srcVec(src, rows());
+    Eigen::Map<Eigen::VectorXd> destVec(dest, destSize);
+    Eigen::Map<const Eigen::VectorXd> srcVec(src, rows());
 
 #   ifdef G2O_OPENMP
 #   pragma omp parallel for default (shared) schedule(dynamic, 10)
@@ -314,14 +305,14 @@ namespace g2o {
         const typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* a=it->second;
         int srcOffset = rowBaseOfBlock(it->first);
         // destVec += *a.transpose() * srcVec (according to the sub-vector parts)
-        internal::template atxpy<typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock>(*a, srcVec, srcOffset, destVec, destOffset);
+        internal::atxpy(*a, srcVec, srcOffset, destVec, destOffset);
       }
     }
     
   }
 
   template <class MatrixType>
-  void SparseBlockMatrix<MatrixType>::scale(number_t a_) {
+  void SparseBlockMatrix<MatrixType>::scale(double a_) {
     for (size_t i=0; i<_blockCols.size(); ++i){
       for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it=_blockCols[i].begin(); it!=_blockCols[i].end(); ++it){
         typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* a=it->second;
@@ -345,7 +336,7 @@ namespace g2o {
     for (int i=1; i<n; ++i){
       colIdx[i]=colIdx[i-1]+colsOfBlock(cmin+i);
     }
-    SparseBlockMatrix* s=new SparseBlockMatrix(rowIdx, colIdx, m, n, true);
+    auto* s=new SparseBlockMatrix(rowIdx, colIdx, m, n, true);
     for (int i=0; i<n; ++i){
       int mc=cmin+i;
       for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it=_blockCols[mc].begin(); it!=_blockCols[mc].end(); ++it){
@@ -441,7 +432,7 @@ namespace g2o {
     }
     // now ready to permute the columns
     for (size_t i=0; i<n; ++i){
-      //cerr << PVAR(i) <<  " ";
+      //std::cerr << PVAR(i) <<  " ";
       int pi=pinv[i];
       for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it=_blockCols[i].begin(); 
           it!=_blockCols[i].end(); ++it){
@@ -463,7 +454,7 @@ namespace g2o {
           *b=s->transpose();
         }
       }
-      //cerr << endl;
+      //std::cerr << std::endl;
       // within each row, 
     }
     return true;
@@ -471,10 +462,10 @@ namespace g2o {
   }
 
   template <class MatrixType>
-  int SparseBlockMatrix<MatrixType>::fillCCS(number_t* Cx, bool upperTriangle) const
+  int SparseBlockMatrix<MatrixType>::fillCCS(double* Cx, bool upperTriangle) const
   {
-    assert(Cx && "Target destination is NULL");
-    number_t* CxStart = Cx;
+    assert(Cx && "Target destination is nullptr");
+    double* CxStart = Cx;
     for (size_t i=0; i<_blockCols.size(); ++i){
       int cstart=i ? _colBlockIndices[i-1] : 0;
       int csize=colsOfBlock(i);
@@ -486,7 +477,7 @@ namespace g2o {
           int elemsToCopy = b->rows();
           if (upperTriangle && rstart == cstart)
             elemsToCopy = c + 1;
-          memcpy(Cx, b->data() + c*b->rows(), elemsToCopy * sizeof(number_t));
+          memcpy(Cx, b->data() + c*b->rows(), elemsToCopy * sizeof(double));
           Cx += elemsToCopy;
 
         }
@@ -496,9 +487,9 @@ namespace g2o {
   }
 
   template <class MatrixType>
-  int SparseBlockMatrix<MatrixType>::fillCCS(int* Cp, int* Ci, number_t* Cx, bool upperTriangle) const
+  int SparseBlockMatrix<MatrixType>::fillCCS(int* Cp, int* Ci, double* Cx, bool upperTriangle) const
   {
-    assert(Cp && Ci && Cx && "Target destination is NULL");
+    assert(Cp && Ci && Cx && "Target destination is nullptr");
     int nz=0;
     for (size_t i=0; i<_blockCols.size(); ++i){
       int cstart=i ? _colBlockIndices[i-1] : 0;
@@ -528,17 +519,19 @@ namespace g2o {
   template <class MatrixType>
   void SparseBlockMatrix<MatrixType>::fillBlockStructure(MatrixStructure& ms) const
   {
-    ms.alloc(_colBlockIndices.size(), nonZeroBlocks());
+    int n     = _colBlockIndices.size();
+    int nzMax = (int)nonZeroBlocks();
+
+    ms.alloc(n, nzMax);
     ms.m = _rowBlockIndices.size();
-    fillBlockStructure(ms.Ap, ms.Aii);
-  }
 
-  template <class MatrixType>
-  void SparseBlockMatrix<MatrixType>::fillBlockStructure(int* Cp, int* Ci) const {
     int nz = 0;
-    for (int c = 0; c < static_cast<int>(_blockCols.size()); ++c) {
+    int* Cp = ms.Ap;
+    int* Ci = ms.Aii;
+    for (int i = 0; i < static_cast<int>(_blockCols.size()); ++i){
       *Cp = nz;
-      for (auto it = _blockCols[c].begin(); it != _blockCols[c].end(); ++it) {
+      const int& c = i;
+      for (typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it=_blockCols[i].begin(); it!=_blockCols[i].end(); ++it) {
         const int& r = it->first;
         if (r <= c) {
           *Ci++ = r;
@@ -547,8 +540,8 @@ namespace g2o {
       }
       Cp++;
     }
-    *Cp = nz;
-    assert(nz <= static_cast<int>(nonZeroBlocks()));
+    *Cp=nz;
+    assert(nz <= nzMax);
   }
 
   template <class MatrixType>
@@ -649,7 +642,7 @@ namespace g2o {
       std::sort(sparseRowSorted.begin(), sparseRowSorted.end(), CmpPairFirst<int, MatrixType*>());
       // try to free some memory early
       HashSparseColumn aux;
-      std::swap(aux, column);
+      swap(aux, column);
       // now insert sorted vector to the std::map structure
       IntBlockMap& destColumnMap = blockCols()[i];
       destColumnMap.insert(sparseRowSorted[0]);
diff --git a/g2o/core/sparse_block_matrix_ccs.h b/g2o/core/sparse_block_matrix_ccs.h
index 209d0cb0..d6983b49 100644
--- a/g2o/core/sparse_block_matrix_ccs.h
+++ b/g2o/core/sparse_block_matrix_ccs.h
@@ -34,7 +34,11 @@
 #include "g2o/config.h"
 #include "matrix_operations.h"
 
+#ifdef _MSC_VER
 #include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
 
 namespace g2o {
 
@@ -96,18 +100,18 @@ namespace g2o {
       //! indices of the column blocks
       const std::vector<int>& colBlockIndices() const { return _colBlockIndices;}
 
-      void rightMultiply(number_t*& dest, const number_t* src) const
+      void rightMultiply(double*& dest, const double* src) const
       {
         int destSize=cols();
 
         if (! dest){
-          dest=new number_t[ destSize ];
-          memset(dest,0, destSize*sizeof(number_t));
+          dest=new double [ destSize ];
+          memset(dest,0, destSize*sizeof(double));
         }
 
         // map the memory by Eigen
-        Eigen::Map<VectorX> destVec(dest, destSize);
-        Eigen::Map<const VectorX> srcVec(src, rows());
+        Eigen::Map<Eigen::VectorXd> destVec(dest, destSize);
+        Eigen::Map<const Eigen::VectorXd> srcVec(src, rows());
 
 #      ifdef G2O_OPENMP
 #      pragma omp parallel for default (shared) schedule(dynamic, 10)
@@ -118,7 +122,7 @@ namespace g2o {
             const SparseMatrixBlock* a = it->block;
             int srcOffset = rowBaseOfBlock(it->row);
             // destVec += *a.transpose() * srcVec (according to the sub-vector parts)
-            internal::template atxpy<SparseMatrixBlock>(*a, srcVec, srcOffset, destVec, destOffset);
+            internal::atxpy(*a, srcVec, srcOffset, destVec, destOffset);
           }
         }
       }
@@ -136,9 +140,9 @@ namespace g2o {
       /**
        * fill the CCS arrays of a matrix, arrays have to be allocated beforehand
        */
-      int fillCCS(int* Cp, int* Ci, number_t* Cx, bool upperTriangle = false) const
+      int fillCCS(int* Cp, int* Ci, double* Cx, bool upperTriangle = false) const
       {
-        assert(Cp && Ci && Cx && "Target destination is NULL");
+        assert(Cp && Ci && Cx && "Target destination is nullptr");
         int nz=0;
         for (size_t i=0; i<_blockCols.size(); ++i){
           int cstart=i ? _colBlockIndices[i-1] : 0;
@@ -169,10 +173,10 @@ namespace g2o {
        * fill the CCS arrays of a matrix, arrays have to be allocated beforehand. This function only writes
        * the values and assumes that column and row structures have already been written.
        */
-      int fillCCS(number_t* Cx, bool upperTriangle = false) const
+      int fillCCS(double* Cx, bool upperTriangle = false) const
       {
-        assert(Cx && "Target destination is NULL");
-        number_t* CxStart = Cx;
+        assert(Cx && "Target destination is nullptr");
+        double* CxStart = Cx;
         int cstart = 0;
         for (size_t i=0; i<_blockCols.size(); ++i){
           int csize = _colBlockIndices[i] - cstart;
@@ -184,7 +188,7 @@ namespace g2o {
               int elemsToCopy = b->rows();
               if (upperTriangle && rstart == cstart)
                 elemsToCopy = c + 1;
-              memcpy(Cx, b->data() + c*b->rows(), elemsToCopy * sizeof(number_t));
+              memcpy(Cx, b->data() + c*b->rows(), elemsToCopy * sizeof(double));
               Cx += elemsToCopy;
 
             }
@@ -219,7 +223,7 @@ namespace g2o {
       //! rows of the matrix
       int rows() const {return _rowBlockIndices.size() ? _rowBlockIndices.back() : 0;}
 
-      typedef std::unordered_map<int, MatrixType*> SparseColumn;
+      typedef std::tr1::unordered_map<int, MatrixType*> SparseColumn;
 
       SparseBlockMatrixHashMap(const std::vector<int>& rowIndices, const std::vector<int>& colIndices) :
         _rowBlockIndices(rowIndices), _colBlockIndices(colIndices)
diff --git a/g2o/core/sparse_block_matrix_diagonal.h b/g2o/core/sparse_block_matrix_diagonal.h
index 9c6dc684..245eab72 100644
--- a/g2o/core/sparse_block_matrix_diagonal.h
+++ b/g2o/core/sparse_block_matrix_diagonal.h
@@ -29,6 +29,7 @@
 
 #include <vector>
 #include <Eigen/Core>
+#include <Eigen/StdVector>
 
 #include "g2o/config.h"
 #include "matrix_operations.h"
@@ -73,17 +74,17 @@ namespace g2o {
       //! indices of the row blocks
       const std::vector<int>& blockIndices() const { return _blockIndices;}
 
-      void multiply(number_t*& dest, const number_t* src) const
+      void multiply(double*& dest, const double* src) const
       {
         int destSize=cols();
         if (! dest) {
-          dest=new number_t[destSize];
-          memset(dest,0, destSize*sizeof(number_t));
+          dest=new double[destSize];
+          memset(dest,0, destSize*sizeof(double));
         }
 
         // map the memory by Eigen
-        Eigen::Map<VectorX> destVec(dest, destSize);
-        Eigen::Map<const VectorX> srcVec(src, rows());
+        Eigen::Map<Eigen::VectorXd> destVec(dest, destSize);
+        Eigen::Map<const Eigen::VectorXd> srcVec(src, rows());
 
 #      ifdef G2O_OPENMP
 #      pragma omp parallel for default (shared) schedule(dynamic, 10)
@@ -93,7 +94,7 @@ namespace g2o {
           int srcOffset = destOffset;
           const SparseMatrixBlock& A = _diagonal[i];
           // destVec += *A.transpose() * srcVec (according to the sub-vector parts)
-          internal::template axpy<SparseMatrixBlock>(A, srcVec, srcOffset, destVec, destOffset);
+          internal::axpy(A, srcVec, srcOffset, destVec, destOffset);
         }
       }
 
diff --git a/g2o/core/sparse_block_matrix_test.cpp b/g2o/core/sparse_block_matrix_test.cpp
index 86325e8d..96e885ab 100644
--- a/g2o/core/sparse_block_matrix_test.cpp
+++ b/g2o/core/sparse_block_matrix_test.cpp
@@ -27,18 +27,18 @@
 #include "sparse_block_matrix.h"
 #include <iostream>
 
-using namespace std;
+
 using namespace g2o;
 using namespace Eigen;
 
-typedef SparseBlockMatrix< MatrixX >
+typedef SparseBlockMatrix< MatrixXd >
 SparseBlockMatrixX;
 
 std::ostream& operator << (std::ostream& os, const SparseBlockMatrixX::SparseMatrixBlock& m) {
   for (int i=0; i<m.rows(); ++i){
     for (int j=0; j<m.cols(); ++j)
-      cerr << m(i,j) << " ";
-    cerr << endl;
+      std::cerr << m(i,j) << " ";
+    std::cerr << std::endl;
   }
   return os;
 }
@@ -46,61 +46,61 @@ std::ostream& operator << (std::ostream& os, const SparseBlockMatrixX::SparseMat
 int main (int argc, char** argv){
   int rcol[] = {3,6,8,12};
   int ccol[] = {2,4,13};
-  cerr << "creation" << endl;
+  std::cerr << "creation" << std::endl;
   SparseBlockMatrixX* M=new SparseBlockMatrixX(rcol, ccol, 4,3);
 
-  cerr << "block access" << endl;
+  std::cerr << "block access" << std::endl;
 
   SparseBlockMatrixX::SparseMatrixBlock* b=M->block(0,0, true);
-  cerr << b->rows() << " " << b->cols() << endl;
+  std::cerr << b->rows() << " " << b->cols() << std::endl;
   for (int i=0; i<b->rows(); ++i)
     for (int j=0; j<b->cols(); ++j){
       (*b)(i,j)=i*b->cols()+j;
     }
 
 
-  cerr << "block access 2" << endl;
+  std::cerr << "block access 2" << std::endl;
   b=M->block(0,2, true);
-  cerr << b->rows() << " " << b->cols() << endl;
+  std::cerr << b->rows() << " " << b->cols() << std::endl;
   for (int i=0; i<b->rows(); ++i)
     for (int j=0; j<b->cols(); ++j){
       (*b)(i,j)=i*b->cols()+j;
     }
 
   b=M->block(3,2, true);
-  cerr << b->rows() << " " << b->cols() << endl;
+  std::cerr << b->rows() << " " << b->cols() << std::endl;
   for (int i=0; i<b->rows(); ++i)
     for (int j=0; j<b->cols(); ++j){
       (*b)(i,j)=i*b->cols()+j;
     }
 
-  cerr << *M << endl;
+  std::cerr << *M << std::endl;
 
-  cerr << "SUM" << endl;
+  std::cerr << "SUM" << std::endl;
 
   SparseBlockMatrixX* Ms=0;
   M->add(Ms);
   M->add(Ms);
-  cerr << *Ms;
+  std::cerr << *Ms;
   
   SparseBlockMatrixX* Mt=0;
   M->transpose(Mt);
-  cerr << *Mt << endl;
+  std::cerr << *Mt << std::endl;
 
   SparseBlockMatrixX* Mp=0;
   M->multiply(Mp, Mt);
-  cerr << *Mp << endl;
+  std::cerr << *Mp << std::endl;
   
   int iperm[]={3,2,1,0};
   SparseBlockMatrixX* PMp=0;
 
   Mp->symmPermutation(PMp,iperm, false);
-  cerr << *PMp << endl;
+  std::cerr << *PMp << std::endl;
 
   PMp->clear(true);
   Mp->block(3,0)->fill(0.);
   Mp->symmPermutation(PMp,iperm, true);
-  cerr << *PMp << endl;
+  std::cerr << *PMp << std::endl;
   
   
   
diff --git a/g2o/core/sparse_optimizer.cpp b/g2o/core/sparse_optimizer.cpp
index 9263d5f5..523facc6 100644
--- a/g2o/core/sparse_optimizer.cpp
+++ b/g2o/core/sparse_optimizer.cpp
@@ -38,25 +38,23 @@
 #include "batch_stats.h"
 #include "hyper_graph_action.h"
 #include "robust_kernel.h"
-#include "g2o/stuff/timeutil.h"
-#include "g2o/stuff/macros.h"
-#include "g2o/stuff/misc.h"
+#include "../stuff/timeutil.h"
+#include "../stuff/macros.h"
+#include "../stuff/misc.h"
 #include "g2o/config.h"
 
-#include "g2o/core/ownership.h"
-
 namespace g2o{
-  using namespace std;
+  
+
 
   SparseOptimizer::SparseOptimizer() :
-    _forceStopFlag(0), _verbose(false), _algorithm(nullptr), _computeBatchStatistics(false)
+    _forceStopFlag(0), _verbose(false), _algorithm(0), _computeBatchStatistics(false)
   {
     _graphActions.resize(AT_NUM_ELEMENTS);
   }
 
-  SparseOptimizer::~SparseOptimizer()
-  {
-    release(_algorithm);
+  SparseOptimizer::~SparseOptimizer(){
+    delete _algorithm;
     G2OBatchStatistics::setGlobalStats(0);
   }
 
@@ -82,16 +80,16 @@ namespace g2o{
       OptimizableGraph::Edge* e = _activeEdges[k];
       bool hasNan = arrayHasNaN(e->errorData(), e->dimension());
       if (hasNan) {
-        cerr << "computeActiveErrors(): found NaN in error for edge " << e << endl;
+        std::cerr << "computeActiveErrors(): found NaN in error for edge " << e << std::endl;
       }
     }
 #  endif
 
   }
 
-  number_t SparseOptimizer::activeChi2( ) const
+  double SparseOptimizer::activeChi2( ) const
   {
-    number_t chi = 0.0;
+    double chi = 0.0;
     for (EdgeContainer::const_iterator it = _activeEdges.begin(); it != _activeEdges.end(); ++it) {
       const OptimizableGraph::Edge* e = *it;
       chi += e->chi2();
@@ -99,10 +97,10 @@ namespace g2o{
     return chi;
   }
 
-  number_t SparseOptimizer::activeRobustChi2() const
+  double SparseOptimizer::activeRobustChi2() const
   {
-    Vector3 rho;
-    number_t chi = 0.0;
+    Eigen::Vector3d rho;
+    double chi = 0.0;
     for (EdgeContainer::const_iterator it = _activeEdges.begin(); it != _activeEdges.end(); ++it) {
       const OptimizableGraph::Edge* e = *it;
       if (e->robustKernel()) {
@@ -117,7 +115,7 @@ namespace g2o{
 
   OptimizableGraph::Vertex* SparseOptimizer::findGauge(){
     if (vertices().empty())
-      return nullptr;
+      return 0;
 
     int maxDim=0;
     for (HyperGraph::VertexIDMap::iterator it=vertices().begin(); it!=vertices().end(); ++it){
@@ -207,17 +205,16 @@ namespace g2o{
 
   bool SparseOptimizer::initializeOptimization(HyperGraph::VertexSet& vset, int level){
     if (edges().size() == 0) {
-      cerr << __PRETTY_FUNCTION__ << ": Attempt to initialize an empty graph" << endl;
+      std::cerr << __PRETTY_FUNCTION__ << ": Attempt to initialize an empty graph" << std::endl;
       return false;
     }
-    preIteration(-1);
     bool workspaceAllocated = _jacobianWorkspace.allocate(); (void) workspaceAllocated;
     assert(workspaceAllocated && "Error while allocating memory for the Jacobians");
     clearIndexMapping();
     _activeVertices.clear();
     _activeVertices.reserve(vset.size());
     _activeEdges.clear();
-    set<Edge*> auxEdgeSet; // temporary structure to avoid duplicates
+    std::set<Edge*> auxEdgeSet; // temporary structure to avoid duplicates
     for (HyperGraph::VertexSet::iterator it=vset.begin(); it!=vset.end(); ++it){
       OptimizableGraph::Vertex* v= (OptimizableGraph::Vertex*) *it;
       const OptimizableGraph::EdgeSet& vEdges=v->edges();
@@ -228,7 +225,7 @@ namespace g2o{
         if (level < 0 || e->level() == level) {
 
           bool allVerticesOK = true;
-          for (vector<HyperGraph::Vertex*>::const_iterator vit = e->vertices().begin(); vit != e->vertices().end(); ++vit) {
+          for (std::vector<HyperGraph::Vertex*>::const_iterator vit = e->vertices().begin(); vit != e->vertices().end(); ++vit) {
             if (vset.find(*vit) == vset.end()) {
               allVerticesOK = false;
               break;
@@ -248,12 +245,12 @@ namespace g2o{
 #      ifndef NDEBUG
         int estimateDim = v->estimateDimension();
         if (estimateDim > 0) {
-          VectorX estimateData(estimateDim);
+          Eigen::VectorXd estimateData(estimateDim);
           if (v->getEstimateData(estimateData.data()) == true) {
             int k;
             bool hasNan = arrayHasNaN(estimateData.data(), estimateDim, &k);
             if (hasNan)
-              cerr << __PRETTY_FUNCTION__ << ": Vertex " << v->id() << " contains a nan entry at index " << k << endl;
+              std::cerr << __PRETTY_FUNCTION__ << ": Vertex " << v->id() << " contains a nan entry at index " << k << std::endl;
           }
         }
 #      endif
@@ -262,42 +259,35 @@ namespace g2o{
     }
 
     _activeEdges.reserve(auxEdgeSet.size());
-    for (set<Edge*>::iterator it = auxEdgeSet.begin(); it != auxEdgeSet.end(); ++it)
+    for (std::set<Edge*>::iterator it = auxEdgeSet.begin(); it != auxEdgeSet.end(); ++it)
       _activeEdges.push_back(*it);
 
     sortVectorContainers();
-    bool indexMappingStatus = buildIndexMapping(_activeVertices);
-    postIteration(-1);
-    return indexMappingStatus;
+    return buildIndexMapping(_activeVertices);
   }
 
   bool SparseOptimizer::initializeOptimization(HyperGraph::EdgeSet& eset){
-    preIteration(-1);
     bool workspaceAllocated = _jacobianWorkspace.allocate(); (void) workspaceAllocated;
     assert(workspaceAllocated && "Error while allocating memory for the Jacobians");
     clearIndexMapping();
     _activeVertices.clear();
     _activeEdges.clear();
     _activeEdges.reserve(eset.size());
-    set<Vertex*> auxVertexSet; // temporary structure to avoid duplicates
+    std::set<Vertex*> auxVertexSet; // temporary structure to avoid duplicates
     for (HyperGraph::EdgeSet::iterator it=eset.begin(); it!=eset.end(); ++it){
       OptimizableGraph::Edge* e=(OptimizableGraph::Edge*)(*it);
-      if (e->numUndefinedVertices())
-	continue;
-      for (vector<HyperGraph::Vertex*>::const_iterator vit = e->vertices().begin(); vit != e->vertices().end(); ++vit) {
+      for (std::vector<HyperGraph::Vertex*>::const_iterator vit = e->vertices().begin(); vit != e->vertices().end(); ++vit) {
         auxVertexSet.insert(static_cast<OptimizableGraph::Vertex*>(*vit));
       }
       _activeEdges.push_back(reinterpret_cast<OptimizableGraph::Edge*>(*it));
     }
 
     _activeVertices.reserve(auxVertexSet.size());
-    for (set<Vertex*>::iterator it = auxVertexSet.begin(); it != auxVertexSet.end(); ++it)
+    for (std::set<Vertex*>::iterator it = auxVertexSet.begin(); it != auxVertexSet.end(); ++it)
       _activeVertices.push_back(*it);
 
     sortVectorContainers();
-    bool indexMappingStatus = buildIndexMapping(_activeVertices);
-    postIteration(-1);
-    return indexMappingStatus;
+    return buildIndexMapping(_activeVertices);
   }
 
   void SparseOptimizer::setToOrigin(){
@@ -322,15 +312,13 @@ namespace g2o{
       OptimizableGraph::Edge* e = *it;
       for (size_t i = 0; i < e->vertices().size(); ++i) {
         OptimizableGraph::Vertex* v = static_cast<OptimizableGraph::Vertex*>(e->vertex(i));
-	if (!v)
-	  continue;
         if (v->fixed())
           fixedVertices.insert(v);
         else { // check for having a prior which is able to fully initialize a vertex
           for (EdgeSet::const_iterator vedgeIt = v->edges().begin(); vedgeIt != v->edges().end(); ++vedgeIt) {
             OptimizableGraph::Edge* vedge = static_cast<OptimizableGraph::Edge*>(*vedgeIt);
             if (vedge->vertices().size() == 1 && vedge->initialEstimatePossible(emptySet, v) > 0.) {
-              //cerr << "Initialize with prior for " << v->id() << endl;
+              //std::cerr << "Initialize with prior for " << v->id() << std::endl;
               vedge->initialEstimate(emptySet, v);
               fixedVertices.insert(v);
             }
@@ -356,27 +344,27 @@ namespace g2o{
     }
     if (verbose()) {
       computeActiveErrors();
-      cerr << "iteration= -1\t chi2= " << activeChi2()
+      std::cerr << "iteration= -1\t chi2= " << activeChi2()
           << "\t time= 0.0"
           << "\t cumTime= 0.0"
-          << "\t (using initial guess from " << costFunction.name() << ")" << endl;
+          << "\t (using initial guess from " << costFunction.name() << ")" << std::endl;
     }
   }
 
   int SparseOptimizer::optimize(int iterations, bool online)
   {
     if (_ivMap.size() == 0) {
-      cerr << __PRETTY_FUNCTION__ << ": 0 vertices to optimize, maybe forgot to call initializeOptimization()" << endl;
+      std::cerr << __PRETTY_FUNCTION__ << ": 0 vertices to optimize, maybe forgot to call initializeOptimization()" << std::endl;
       return -1;
     }
 
     int cjIterations=0;
-    number_t cumTime=0;
+    double cumTime=0;
     bool ok=true;
 
     ok = _algorithm->init(online);
     if (! ok) {
-      cerr << __PRETTY_FUNCTION__ << " Error while initializing" << endl;
+      std::cerr << __PRETTY_FUNCTION__ << " Error while initializing" << std::endl;
       return -1;
     }
 
@@ -396,7 +384,7 @@ namespace g2o{
         cstat.numVertices = _activeVertices.size();
       }
       
-      number_t ts = get_monotonic_time();
+      double ts = get_monotonic_time();
       result = _algorithm->solve(i, online);
       ok = ( result == OptimizationAlgorithm::OK );
 
@@ -409,17 +397,17 @@ namespace g2o{
       }
 
       if (verbose()){
-        number_t dts = get_monotonic_time()-ts;
+        double dts = get_monotonic_time()-ts;
         cumTime += dts;
         if (! errorComputed)
           computeActiveErrors();
-        cerr << "iteration= " << i
+        std::cerr << "iteration= " << i
           << "\t chi2= " << FIXED(activeRobustChi2())
           << "\t time= " << dts
           << "\t cumTime= " << cumTime
           << "\t edges= " << _activeEdges.size();
-        _algorithm->printVerbose(cerr);
-        cerr << endl;
+        _algorithm->printVerbose(std::cerr);
+        std::cerr << std::endl;
       }
       ++cjIterations; 
       postIteration(i);
@@ -430,7 +418,8 @@ namespace g2o{
     return cjIterations;
   }
 
-  void SparseOptimizer::update(const number_t* update)
+
+  void SparseOptimizer::update(const double* update)
   {
     // update the graph by calling oplus on the vertices
     for (size_t i=0; i < _ivMap.size(); ++i) {
@@ -438,7 +427,7 @@ namespace g2o{
 #ifndef NDEBUG
       bool hasNan = arrayHasNaN(update, v->dimension());
       if (hasNan)
-        cerr << __PRETTY_FUNCTION__ << ": Update contains a nan for vertex " << v->id() << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": Update contains a nan for vertex " << v->id() << std::endl;
 #endif
       v->oplus(update);
       update += v->dimension();
@@ -486,13 +475,13 @@ namespace g2o{
     }
 
     //if (newVertices.size() != vset.size())
-    //cerr << __PRETTY_FUNCTION__ << ": something went wrong " << PVAR(vset.size()) << " " << PVAR(newVertices.size()) << endl;
+    //std::cerr << __PRETTY_FUNCTION__ << ": something went wrong " << PVAR(vset.size()) << " " << PVAR(newVertices.size()) << std::endl;
     return _algorithm->updateStructure(newVertices, eset);
   }
 
   void SparseOptimizer::sortVectorContainers()
   {
-    // sort vector structures to get deterministic ordering based on IDs
+    // sort std::vector structures to get deterministic ordering based on IDs
     sort(_activeVertices.begin(), _activeVertices.end(), VertexIDCompare());
     sort(_activeEdges.begin(), _activeEdges.end(), EdgeIDCompare());
   }
@@ -536,23 +525,25 @@ namespace g2o{
       (*it)->pop();
   }
 
-  void SparseOptimizer::push(HyperGraph::VertexSet& vlist) {
+  void SparseOptimizer::push(HyperGraph::VertexSet& vlist)
+  {
     for (HyperGraph::VertexSet::iterator it = vlist.begin(); it != vlist.end(); ++it) {
       OptimizableGraph::Vertex* v = dynamic_cast<OptimizableGraph::Vertex*>(*it);
       if (v)
-        v->push();
+	v->push();
       else 
-        cerr << __FUNCTION__ << ": FATAL PUSH SET" << endl;
+	std::cerr << __FUNCTION__ << ": FATAL PUSH SET" << std::endl;
     }
   }
 
-  void SparseOptimizer::pop(HyperGraph::VertexSet& vlist) {
-    for (HyperGraph::VertexSet::iterator it = vlist.begin(); it != vlist.end(); ++it) {
-      OptimizableGraph::Vertex* v = dynamic_cast<OptimizableGraph::Vertex*>(*it);
+  void SparseOptimizer::pop(HyperGraph::VertexSet& vlist)
+  {
+    for (HyperGraph::VertexSet::iterator it = vlist.begin(); it != vlist.end(); ++it){
+      OptimizableGraph::Vertex* v = dynamic_cast<OptimizableGraph::Vertex*> (*it);
       if (v)
-        v->pop();
+	v->pop();
       else 
-        cerr << __FUNCTION__ << ": FATAL POP SET" << endl;
+	std::cerr << __FUNCTION__ << ": FATAL POP SET" << std::endl;
     }
   }
 
@@ -570,15 +561,13 @@ namespace g2o{
   void SparseOptimizer::setAlgorithm(OptimizationAlgorithm* algorithm)
   {
     if (_algorithm) // reset the optimizer for the formerly used solver
-      _algorithm->setOptimizer(nullptr);
-
+      _algorithm->setOptimizer(0);
     _algorithm = algorithm;
-
     if (_algorithm)
       _algorithm->setOptimizer(this);
   }
 
-  bool SparseOptimizer::computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices){
+  bool SparseOptimizer::computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices){
     return _algorithm->computeMarginals(spinv, blockIndices);
   }
 
@@ -587,14 +576,14 @@ namespace g2o{
     _forceStopFlag=flag;
   }
 
-  bool SparseOptimizer::removeVertex(HyperGraph::Vertex* v, bool detach)
+  bool SparseOptimizer::removeVertex(HyperGraph::Vertex* v)
   {
     OptimizableGraph::Vertex* vv = static_cast<OptimizableGraph::Vertex*>(v);
     if (vv->hessianIndex() >= 0) {
       clearIndexMapping();
       _ivMap.clear();
     }
-    return HyperGraph::removeVertex(v, detach);
+    return HyperGraph::removeVertex(v);
   }
 
   bool SparseOptimizer::addComputeErrorAction(HyperGraphAction* action)
diff --git a/g2o/core/sparse_optimizer.h b/g2o/core/sparse_optimizer.h
index 54415d79..b046b68a 100644
--- a/g2o/core/sparse_optimizer.h
+++ b/g2o/core/sparse_optimizer.h
@@ -27,21 +27,22 @@
 #ifndef G2O_GRAPH_OPTIMIZER_CHOL_H_
 #define G2O_GRAPH_OPTIMIZER_CHOL_H_
 
-#include "g2o/stuff/macros.h"
+#include "../stuff/macros.h"
 
 #include "optimizable_graph.h"
 #include "sparse_block_matrix.h"
-#include "g2o_core_api.h"
 #include "batch_stats.h"
 
+#include <map>
 
 namespace g2o {
 
   // forward declaration
+  class ActivePathCostFunction;
   class OptimizationAlgorithm;
   class EstimatePropagatorCost;
 
-  class G2O_CORE_API SparseOptimizer : public OptimizableGraph {
+  class  SparseOptimizer : public OptimizableGraph {
 
     public:
     enum {
@@ -126,7 +127,7 @@ namespace g2o {
      * @param spinv: the sparse block matrix with the result
      * @returns false if the operation is not supported by the solver
      */
-    bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const std::vector<std::pair<int, int> >& blockIndices);
+    bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const std::vector<std::pair<int, int> >& blockIndices);
 
     /**
      * computes the inverse of the specified vertex.
@@ -134,7 +135,7 @@ namespace g2o {
      * @param spinv: the sparse block matrix with the result
      * @returns false if the operation is not supported by the solver
      */
-    bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const Vertex* vertex) {
+    bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const Vertex* vertex) {
       if (vertex->hessianIndex() < 0) {
           return false;
       }
@@ -149,7 +150,7 @@ namespace g2o {
      * @param spinv: the sparse block matrix with the result
      * @returns false if the operation is not supported by the solver
      */
-    bool computeMarginals(SparseBlockMatrix<MatrixX>& spinv, const VertexContainer& vertices) {
+    bool computeMarginals(SparseBlockMatrix<Eigen::MatrixXd>& spinv, const VertexContainer& vertices) {
       std::vector<std::pair<int, int> > indices;
       for (VertexContainer::const_iterator it = vertices.begin(); it != vertices.end(); ++it) {
         indices.push_back(std::pair<int, int>((*it)->hessianIndex(),(*it)->hessianIndex()));
@@ -165,13 +166,13 @@ namespace g2o {
     bool gaugeFreedom();
 
     /**returns the cached chi2 of the active portion of the graph*/
-    number_t activeChi2() const;
+    double activeChi2() const;
     /**
      * returns the cached chi2 of the active portion of the graph.
      * In contrast to activeChi2() this functions considers the weighting
      * of the error according to the robustification of the error functions.
      */
-    number_t activeRobustChi2() const;
+    double activeRobustChi2() const;
 
     //! verbose information during optimization
     bool verbose()  const {return _verbose;}
@@ -199,7 +200,7 @@ namespace g2o {
      * mapping is erased. In case you need the index mapping for manipulating the
      * graph, you have to store it in your own copy.
      */
-    virtual bool removeVertex(HyperGraph::Vertex* v, bool detach=false);
+    virtual bool removeVertex(HyperGraph::Vertex* v);
 
     /**
      * search for an edge in _activeVertices and return the iterator pointing to it
@@ -259,10 +260,10 @@ namespace g2o {
 
     /**
      * update the estimate of the active vertices 
-     * @param update: the number_t vector containing the stacked
+     * @param update: the double vector containing the stacked
      * elements of the increments on the vertices.
      */
-    void update(const number_t* update);
+    void update(const double* update);
 
     /**
        returns the set of batch statistics about the optimisation
diff --git a/g2o/core/sparse_optimizer_terminate_action.cpp b/g2o/core/sparse_optimizer_terminate_action.cpp
deleted file mode 100644
index 914a47d1..00000000
--- a/g2o/core/sparse_optimizer_terminate_action.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "sparse_optimizer_terminate_action.h"
-
-#include "sparse_optimizer.h"
-
-#include <limits>
-
-namespace g2o {
-
-  SparseOptimizerTerminateAction::SparseOptimizerTerminateAction() :
-    HyperGraphAction(),
-    _gainThreshold(cst(1e-6)), _lastChi(0), _auxTerminateFlag(false),
-    _maxIterations(std::numeric_limits<int>::max())
-  {
-  }
-
-  void SparseOptimizerTerminateAction::setGainThreshold(number_t gainThreshold)
-  {
-    _gainThreshold = gainThreshold;
-  }
-
-  HyperGraphAction* SparseOptimizerTerminateAction::operator()(const HyperGraph* graph, Parameters* parameters)
-  {
-    assert(dynamic_cast<const SparseOptimizer*>(graph) && "graph is not a SparseOptimizer");
-    assert(dynamic_cast<HyperGraphAction::ParametersIteration*>(parameters) && "error casting parameters");
-
-    const SparseOptimizer* optimizer = static_cast<const SparseOptimizer*>(graph);
-    HyperGraphAction::ParametersIteration* params = static_cast<HyperGraphAction::ParametersIteration*>(parameters);
-
-    const_cast<SparseOptimizer*>(optimizer)->computeActiveErrors();
-    if (params->iteration < 0)
-    {
-      // let the optimizer run for at least one iteration
-      // Hence, we reset the stop flag
-      setOptimizerStopFlag(optimizer, false);
-    } else if (params->iteration == 0) {
-      // first iteration, just store the chi2 value
-      _lastChi = optimizer->activeRobustChi2();
-    } else {
-      // compute the gain and stop the optimizer in case the
-      // gain is below the threshold or we reached the max
-      // number of iterations
-      bool stopOptimizer = false;
-      if (params->iteration < _maxIterations) {
-        number_t currentChi = optimizer->activeRobustChi2();
-        number_t gain = (_lastChi - currentChi) / currentChi;
-        _lastChi = currentChi;
-        if (gain >= 0 && gain < _gainThreshold)
-          stopOptimizer = true;
-      } else {
-        stopOptimizer = true;
-      }
-      if (stopOptimizer) { // tell the optimizer to stop
-        setOptimizerStopFlag(optimizer, true);
-      }
-    }
-    return this;
-  }
-
-  void SparseOptimizerTerminateAction::setMaxIterations(int maxit)
-  {
-    _maxIterations = maxit;
-  }
-
-  void SparseOptimizerTerminateAction::setOptimizerStopFlag(const SparseOptimizer* optimizer, bool stop)
-  {
-    if (optimizer->forceStopFlag()) {
-      *(optimizer->forceStopFlag()) = stop;
-    } else {
-      _auxTerminateFlag = stop;
-      const_cast<SparseOptimizer*>(optimizer)->setForceStopFlag(&_auxTerminateFlag);
-    }
-  }
-
-} // end namespace
diff --git a/g2o/core/sparse_optimizer_terminate_action.h b/g2o/core/sparse_optimizer_terminate_action.h
deleted file mode 100644
index f28f42b5..00000000
--- a/g2o/core/sparse_optimizer_terminate_action.h
+++ /dev/null
@@ -1,68 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef SPARSE_OPTIMIZER_TERMINATE_ACTION_H
-#define SPARSE_OPTIMIZER_TERMINATE_ACTION_H
-
-#include "g2o_core_api.h"
-#include "hyper_graph_action.h"
-
-namespace g2o {
-
-  class SparseOptimizer;
-
-  /**
-   * \brief stop iterating based on the gain which is (oldChi - currentChi) / currentChi.
-   *
-   * stop iterating based on the gain which is (oldChi - currentChi) / currentChi.
-   * If the gain is larger than zero and below the threshold, then the optimizer is stopped.
-   * Typically usage of this action includes adding it as a postIteration action, by calling
-   * addPostIterationAction on a sparse optimizer.
-   */
-  class G2O_CORE_API SparseOptimizerTerminateAction : public HyperGraphAction
-  {
-    public:
-      SparseOptimizerTerminateAction();
-      virtual HyperGraphAction* operator()(const HyperGraph* graph, Parameters* parameters = 0);
-
-      number_t gainThreshold() const { return _gainThreshold;}
-      void setGainThreshold(number_t gainThreshold);
-
-      int maxIterations() const { return _maxIterations;}
-      void setMaxIterations(int maxit);
-
-    protected:
-      number_t _gainThreshold;
-      number_t _lastChi;
-      bool _auxTerminateFlag;
-      int _maxIterations;
-
-      void setOptimizerStopFlag(const SparseOptimizer* optimizer, bool stop);
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/solvers/CMakeLists.txt b/g2o/solvers/CMakeLists.txt
deleted file mode 100644
index a6c92b74..00000000
--- a/g2o/solvers/CMakeLists.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-add_subdirectory(pcg)
-add_subdirectory(dense)
-add_subdirectory(structure_only)
-
-if(CSPARSE_FOUND)
-  add_subdirectory(csparse)
-  add_subdirectory(slam2d_linear)
-endif()
-
-if(CHOLMOD_FOUND)
-  add_subdirectory(cholmod)
-endif(CHOLMOD_FOUND)
-
-# Sparse Module of Eigen is stable starting from 3.1
-if (DEFINED EIGEN3_VERSION)
-  if(${EIGEN3_VERSION} VERSION_GREATER "3.1.0" OR ${EIGEN3_VERSION} VERSION_EQUAL "3.1.0")
-    add_subdirectory(eigen)
-  endif()
-endif()
diff --git a/g2o/solvers/cholmod/CMakeLists.txt b/g2o/solvers/cholmod/CMakeLists.txt
deleted file mode 100644
index aa6303a3..00000000
--- a/g2o/solvers/cholmod/CMakeLists.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-if (NOT G2O_USE_CHOLMOD)
-  return()
-endif()
-
-add_library(solver_cholmod ${G2O_LIB_TYPE}
-  solver_cholmod.cpp
-  linear_solver_cholmod.h
-)
-
-target_include_directories(solver_cholmod PUBLIC
-  $<BUILD_INTERFACE:${CHOLMOD_INCLUDES}>
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-    $<INSTALL_INTERFACE:include/g2o/solvers/cholmod>)
-
-set_target_properties(solver_cholmod PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_cholmod)
-if (APPLE)
-  set_target_properties(solver_cholmod PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-add_definitions(${BLAS_DEFINITIONS} ${LAPACK_DEFINITIONS})
-target_link_libraries(solver_cholmod ${CHOLMOD_LIBRARIES} ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES} core)
-
-install(TARGETS solver_cholmod
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION} ${CHOLMOD_INCLUDE_DIR}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/cholmod)
diff --git a/g2o/solvers/cholmod/linear_solver_cholmod.h b/g2o/solvers/cholmod/linear_solver_cholmod.h
deleted file mode 100644
index cb854024..00000000
--- a/g2o/solvers/cholmod/linear_solver_cholmod.h
+++ /dev/null
@@ -1,286 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINEAR_SOLVER_CHOLMOD
-#define G2O_LINEAR_SOLVER_CHOLMOD
-
-#include <cholmod.h>
-
-#include "g2o/core/batch_stats.h"
-#include "g2o/core/linear_solver.h"
-#include "g2o/core/marginal_covariance_cholesky.h"
-#include "g2o/stuff/sparse_helper.h"
-#include "g2o/stuff/timeutil.h"
-
-namespace g2o {
-
-/**
- * \brief Our extension of the CHOLMOD matrix struct
- */
-struct CholmodExt : public cholmod_sparse {
-  CholmodExt() {
-    nzmax = 0;
-    nrow = 0;
-    ncol = 0;
-    p = nullptr;
-    i = nullptr;
-    nz = nullptr;
-    x = nullptr;
-    z = nullptr;
-    stype = 1;  // upper triangular block only
-    itype = CHOLMOD_INT;
-    xtype = CHOLMOD_REAL;
-    dtype = CHOLMOD_DOUBLE;
-    sorted = 1;
-    packed = 1;
-    columnsAllocated = 0;
-  }
-  ~CholmodExt() {
-    delete[](int*) p;
-    p = nullptr;
-    delete[](double*) x;
-    x = nullptr;
-    delete[](int*) i;
-    i = nullptr;
-  }
-  size_t columnsAllocated;
-};
-
-/**
- * \brief basic solver for Ax = b which has to reimplemented for different linear algebra libraries
- */
-template <typename MatrixType>
-class LinearSolverCholmod : public LinearSolverCCS<MatrixType> {
- public:
-  LinearSolverCholmod() : LinearSolverCCS<MatrixType>(), _cholmodFactor(nullptr) {
-    cholmod_start(&_cholmodCommon);
-
-    // setup ordering strategy
-    _cholmodCommon.nmethods = 1;
-    _cholmodCommon.method[0].ordering = CHOLMOD_AMD;  // CHOLMOD_COLAMD
-    //_cholmodCommon.postorder = 0;
-
-    _cholmodCommon.supernodal = CHOLMOD_AUTO;  // CHOLMOD_SUPERNODAL; //CHOLMOD_SIMPLICIAL;
-  }
-
-  LinearSolverCholmod(LinearSolverCholmod<MatrixType> const&) = delete;
-  LinearSolverCholmod& operator=(LinearSolverCholmod<MatrixType> const&) = delete;
-
-  virtual ~LinearSolverCholmod() {
-    freeCholdmodFactor();
-    cholmod_finish(&_cholmodCommon);
-  }
-
-  virtual bool init() {
-    freeCholdmodFactor();
-    return true;
-  }
-
-  bool solve(const SparseBlockMatrix<MatrixType>& A, double* x, double* b) {
-    double t;
-    bool cholState = computeCholmodFactor(A, t);
-    if (!cholState) return false;
-
-    // setting up b for calling cholmod
-    cholmod_dense bcholmod;
-    bcholmod.nrow = bcholmod.d = _cholmodSparse.nrow;
-    bcholmod.ncol = 1;
-    bcholmod.x = b;
-    bcholmod.xtype = CHOLMOD_REAL;
-    bcholmod.dtype = CHOLMOD_DOUBLE;
-    cholmod_dense* xcholmod = cholmod_solve(CHOLMOD_A, _cholmodFactor, &bcholmod, &_cholmodCommon);
-    memcpy(x, xcholmod->x, sizeof(double) * bcholmod.nrow);  // copy back to our array
-    cholmod_free_dense(&xcholmod, &_cholmodCommon);
-
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->timeNumericDecomposition = get_monotonic_time() - t;
-      globalStats->choleskyNNZ = static_cast<size_t>(_cholmodCommon.method[0].lnz);
-    }
-
-    return true;
-  }
-
-  virtual bool saveMatrix(const std::string& fileName) {
-    writeCCSMatrix(fileName, _cholmodSparse.nrow, _cholmodSparse.ncol, (int*)_cholmodSparse.p,
-                   (int*)_cholmodSparse.i, (double*)_cholmodSparse.x, true);
-    return true;
-  }
-
- protected:
-  // temp used for cholesky with cholmod
-  cholmod_common _cholmodCommon;
-  CholmodExt _cholmodSparse;
-  cholmod_factor* _cholmodFactor;
-  MatrixStructure _matrixStructure;
-  VectorXI _scalarPermutation, _blockPermutation;
-
-  void computeSymbolicDecomposition(const SparseBlockMatrix<MatrixType>& A) {
-    double t = get_monotonic_time();
-    if (!this->blockOrdering()) {
-      // setup ordering strategy
-      _cholmodCommon.nmethods = 1;
-      _cholmodCommon.method[0].ordering = CHOLMOD_AMD;                     // CHOLMOD_COLAMD
-      _cholmodFactor = cholmod_analyze(&_cholmodSparse, &_cholmodCommon);  // symbolic factorization
-    } else {
-      A.fillBlockStructure(_matrixStructure);
-
-      // get the ordering for the block matrix
-      if (_blockPermutation.size() == 0) _blockPermutation.resize(_matrixStructure.n);
-      if (_blockPermutation.size() < _matrixStructure.n)  // double space if resizing
-        _blockPermutation.resize(2 * _matrixStructure.n);
-
-      // prepare AMD call via CHOLMOD
-      cholmod_sparse auxCholmodSparse;
-      auxCholmodSparse.nzmax = _matrixStructure.nzMax();
-      auxCholmodSparse.nrow = auxCholmodSparse.ncol = _matrixStructure.n;
-      auxCholmodSparse.p = _matrixStructure.Ap;
-      auxCholmodSparse.i = _matrixStructure.Aii;
-      auxCholmodSparse.nz = 0;
-      auxCholmodSparse.x = 0;
-      auxCholmodSparse.z = 0;
-      auxCholmodSparse.stype = 1;
-      auxCholmodSparse.xtype = CHOLMOD_PATTERN;
-      auxCholmodSparse.itype = CHOLMOD_INT;
-      auxCholmodSparse.dtype = CHOLMOD_DOUBLE;
-      auxCholmodSparse.sorted = 1;
-      auxCholmodSparse.packed = 1;
-      int amdStatus =
-          cholmod_amd(&auxCholmodSparse, NULL, 0, _blockPermutation.data(), &_cholmodCommon);
-      if (!amdStatus) return;
-
-      // blow up the permutation to the scalar matrix
-      this->blockToScalarPermutation(A, _blockPermutation, _scalarPermutation);
-
-      // apply the ordering
-      _cholmodCommon.nmethods = 1;
-      _cholmodCommon.method[0].ordering = CHOLMOD_GIVEN;
-      _cholmodFactor =
-          cholmod_analyze_p(&_cholmodSparse, _scalarPermutation.data(), NULL, 0, &_cholmodCommon);
-    }
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) globalStats->timeSymbolicDecomposition = get_monotonic_time() - t;
-  }
-
-  void fillCholmodExt(const SparseBlockMatrix<MatrixType>& A, bool onlyValues) {
-    if (!onlyValues) this->initMatrixStructure(A);
-    size_t m = A.rows();
-    size_t n = A.cols();
-    assert(m > 0 && n > 0 && "Hessian has 0 rows/cols");
-
-    if (_cholmodSparse.columnsAllocated < n) {
-      // pre-allocate more space if re-allocating
-      _cholmodSparse.columnsAllocated = _cholmodSparse.columnsAllocated == 0 ? n : 2 * n;
-      delete[](int*) _cholmodSparse.p;
-      _cholmodSparse.p = new int[_cholmodSparse.columnsAllocated + 1];
-    }
-    if (!onlyValues) {
-      size_t nzmax = A.nonZeros();
-      if (_cholmodSparse.nzmax < nzmax) {
-        // pre-allocate more space if re-allocating
-        _cholmodSparse.nzmax = _cholmodSparse.nzmax == 0 ? nzmax : 2 * nzmax;
-        delete[](double*) _cholmodSparse.x;
-        delete[](int*) _cholmodSparse.i;
-        _cholmodSparse.i = new int[_cholmodSparse.nzmax];
-        _cholmodSparse.x = new double[_cholmodSparse.nzmax];
-      }
-    }
-    _cholmodSparse.ncol = n;
-    _cholmodSparse.nrow = m;
-
-    if (onlyValues)
-      this->_ccsMatrix->fillCCS((double*)_cholmodSparse.x, true);
-    else
-      this->_ccsMatrix->fillCCS((int*)_cholmodSparse.p, (int*)_cholmodSparse.i,
-                                (double*)_cholmodSparse.x, true);
-  }
-
-  //! compute the cholmodFactor for the given matrix A
-  bool computeCholmodFactor(const SparseBlockMatrix<MatrixType>& A, double& t) {
-    // _cholmodFactor used as bool, if not existing will copy the whole structure, otherwise only
-    // the values
-    fillCholmodExt(A, _cholmodFactor != nullptr);
-
-    if (_cholmodFactor == 0) {
-      computeSymbolicDecomposition(A);
-      assert(_cholmodFactor != 0 && "Symbolic cholesky failed");
-    }
-    t = get_monotonic_time();
-
-    cholmod_factorize(&_cholmodSparse, _cholmodFactor, &_cholmodCommon);
-    if (_cholmodCommon.status == CHOLMOD_NOT_POSDEF) {
-      if (this->writeDebug()) {
-        std::cerr << "Cholesky failure, writing debug.txt (Hessian loadable by Octave)"
-                  << std::endl;
-        saveMatrix("debug.txt");
-      }
-      return false;
-    }
-    return true;
-  }
-
-  bool solveBlocks_impl(const SparseBlockMatrix<MatrixType>& A,
-                        std::function<void(MarginalCovarianceCholesky&)> compute) {
-    double t;
-    bool cholState = computeCholmodFactor(A, t);
-    if (!cholState) return false;
-
-    // convert the factorization to LL, simplical, packed, monotonic
-    int change_status =
-        cholmod_change_factor(CHOLMOD_REAL, 1, 0, 1, 1, _cholmodFactor, &_cholmodCommon);
-    if (!change_status) return false;
-    assert(_cholmodFactor->is_ll && !_cholmodFactor->is_super && _cholmodFactor->is_monotonic &&
-           "Cholesky factor has wrong format");
-
-    // invert the permutation
-    int* p = (int*)_cholmodFactor->Perm;
-    VectorXI pinv(_cholmodSparse.ncol);
-    for (size_t i = 0; i < _cholmodSparse.ncol; ++i) pinv(p[i]) = i;
-
-    // compute the marginal covariance
-    MarginalCovarianceCholesky mcc;
-    mcc.setCholeskyFactor(_cholmodSparse.ncol, (int*)_cholmodFactor->p, (int*)_cholmodFactor->i,
-                          (double*)_cholmodFactor->x, pinv.data());
-    compute(mcc);
-
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->choleskyNNZ =
-          static_cast<size_t>(_cholmodCommon.method[_cholmodCommon.selected].lnz);
-    }
-    return true;
-  }
-
-  void freeCholdmodFactor() {
-    if (_cholmodFactor != nullptr) {
-      cholmod_free_factor(&_cholmodFactor, &_cholmodCommon);
-      _cholmodFactor = nullptr;
-    }
-  }
-};
-
-}  // namespace g2o
-#endif
diff --git a/g2o/solvers/cholmod/solver_cholmod.cpp b/g2o/solvers/cholmod/solver_cholmod.cpp
deleted file mode 100644
index c5d9480a..00000000
--- a/g2o/solvers/cholmod/solver_cholmod.cpp
+++ /dev/null
@@ -1,120 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "linear_solver_cholmod.h"
-
-#include "g2o/core/block_solver.h"
-#include "g2o/core/solver.h"
-#include "g2o/core/optimization_algorithm_factory.h"
-
-#include "g2o/core/optimization_algorithm_gauss_newton.h"
-#include "g2o/core/optimization_algorithm_levenberg.h"
-#include "g2o/core/optimization_algorithm_dogleg.h"
-
-#include "g2o/stuff/macros.h"
-
-//#define ADD_SCALAR_ORDERING
-using namespace std;
-
-namespace g2o {
-
-  namespace
-  {
-    template<int p, int l, bool blockorder>
-    std::unique_ptr<BlockSolverBase> AllocateSolver()
-    {
-      std::cerr << "# Using CHOLMOD poseDim " << p << " landMarkDim " << l << " blockordering " << blockorder << std::endl;
-      auto linearSolver = g2o::make_unique<LinearSolverCholmod<typename BlockSolverPL<p, l>::PoseMatrixType>>();
-      linearSolver->setBlockOrdering(blockorder);
-      return g2o::make_unique<BlockSolverPL<p, l>>(std::move(linearSolver));
-    }
-  }
-
-  static OptimizationAlgorithm* createSolver(const std::string& fullSolverName)
-  {
-    static const std::map<std::string, std::function<std::unique_ptr<BlockSolverBase>()>> solver_factories{
-      { "var_cholmod", &AllocateSolver<-1, -1, true> },
-      { "fix3_2_cholmod", &AllocateSolver<3, 2, true> },
-      { "fix6_3_cholmod", &AllocateSolver<6, 3, true> },
-      { "fix7_3_cholmod", &AllocateSolver<7, 3, true> },
-#ifdef ADD_SCALAR_ORDERING
-      { "fix3_2_cholmod_scalar", &AllocateSolver<3, 2, false> },
-      { "fix6_3_cholmod_scalar", &AllocateSolver<6, 3, false> },
-      { "fix7_3_cholmod_scalar", &AllocateSolver<7, 3, false> },
-#endif
-    };
-
-    string solverName = fullSolverName.substr(3);
-    auto solverf = solver_factories.find(solverName);
-    if (solverf == solver_factories.end())
-      return nullptr;
-
-    string methodName = fullSolverName.substr(0, 2);
-
-    if (methodName == "gn")
-    {
-      return new OptimizationAlgorithmGaussNewton(solverf->second());
-    }
-    else if (methodName == "lm")
-    {
-      return new OptimizationAlgorithmLevenberg(solverf->second());
-    }
-    else if (methodName == "dl")
-    {
-      return new OptimizationAlgorithmDogleg(solverf->second());
-    }
-
-    return nullptr;
-  }
-
-  class CholmodSolverCreator : public AbstractOptimizationAlgorithmCreator {
-   public:
-    explicit CholmodSolverCreator(const OptimizationAlgorithmProperty& p) : AbstractOptimizationAlgorithmCreator(p) {}
-    virtual OptimizationAlgorithm* construct() { return createSolver(property().name); }
-  };
-
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(cholmod);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_var_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_var_cholmod", "Gauss-Newton: Cholesky solver using CHOLMOD (variable blocksize)", "CHOLMOD", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix3_2_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_fix3_2_cholmod", "Gauss-Newton: Cholesky solver using CHOLMOD (fixed blocksize)", "CHOLMOD", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix6_3_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_fix6_3_cholmod", "Gauss-Newton: Cholesky solver using CHOLMOD (fixed blocksize)", "CHOLMOD", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix7_3_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_fix7_3_cholmod", "Gauss-Newton: Cholesky solver using CHOLMOD (fixed blocksize)", "CHOLMOD", true, 7, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_var_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_var_cholmod", "Levenberg: Cholesky solver using CHOLMOD (variable blocksize)", "CHOLMOD", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix3_2_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_fix3_2_cholmod", "Levenberg: Cholesky solver using CHOLMOD (fixed blocksize)", "CHOLMOD", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix6_3_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_fix6_3_cholmod", "Levenberg: Cholesky solver using CHOLMOD (fixed blocksize)", "CHOLMOD", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix7_3_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_fix7_3_cholmod", "Levenberg: Cholesky solver using CHOLMOD (fixed blocksize)", "CHOLMOD", true, 7, 3)));
-
-#ifdef ADD_SCALAR_ORDERING
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix3_2_cholmod_scalar, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_fix3_2_cholmod_scalar", "Gauss-Newton: Cholesky solver using CHOLMOD (fixed blocksize, scalar ordering)", "CHOLMOD", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix6_3_cholmod_scalar, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_fix6_3_cholmod_scalar", "Gauss-Newton: Cholesky solver using CHOLMOD (fixed blocksize, scalar ordering)", "CHOLMOD", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix7_3_cholmod_scalar, new CholmodSolverCreator(OptimizationAlgorithmProperty("gn_fix7_3_cholmod_scalar", "Gauss-Newton: Cholesky solver using CHOLMOD (fixed blocksize, scalar ordering)", "CHOLMOD", true, 7, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix3_2_cholmod_scalar, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_fix3_2_cholmod_scalar", "Levenberg: Cholesky solver using CHOLMOD (fixed blocksize, scalar ordering)", "CHOLMOD", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix6_3_cholmod_scalar, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_fix6_3_cholmod_scalar", "Levenberg: Cholesky solver using CHOLMOD (fixed blocksize, scalar ordering)", "CHOLMOD", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix7_3_cholmod_scalar, new CholmodSolverCreator(OptimizationAlgorithmProperty("lm_fix7_3_cholmod_scalar", "Levenberg: Cholesky solver using CHOLMOD (fixed blocksize, scalar ordering)", "CHOLMOD", true, 7, 3)));
-#endif
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(dl_var_cholmod, new CholmodSolverCreator(OptimizationAlgorithmProperty("dl_var_cholmod", "Dogleg: Cholesky solver using CHOLMOD (variable blocksize)", "CHOLMOD", false, Eigen::Dynamic, Eigen::Dynamic)));
-}
diff --git a/g2o/solvers/csparse/CMakeLists.txt b/g2o/solvers/csparse/CMakeLists.txt
deleted file mode 100644
index 6fbb7058..00000000
--- a/g2o/solvers/csparse/CMakeLists.txt
+++ /dev/null
@@ -1,48 +0,0 @@
-if(NOT G2O_USE_CSPARSE)
-  return()
-endif()
-
-add_library(csparse_extension ${G2O_LGPL_LIB_TYPE}
-  csparse_helper.cpp csparse_helper.h
-  csparse_extension.cpp csparse_extension.h
-  g2o_csparse_extension_api.h
-)
-set_target_properties(csparse_extension PROPERTIES OUTPUT_NAME ${LIB_PREFIX}csparse_extension)
-if (APPLE)
-  set_target_properties(csparse_extension PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-target_include_directories(csparse_extension PUBLIC
-  $<BUILD_INTERFACE:${CSPARSE_INCLUDE_DIR}>
-  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-  $<INSTALL_INTERFACE:include/g2o/solvers/csparse>)
-target_link_libraries(csparse_extension PUBLIC stuff ${CSPARSE_LIBRARY} ${G2O_EIGEN3_EIGEN_TARGET})
-
-add_library(solver_csparse ${G2O_LIB_TYPE}
-  solver_csparse.cpp
-  linear_solver_csparse.h
-  g2o_csparse_api.h
-)
-set_target_properties(solver_csparse PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_csparse)
-if (APPLE)
-  set_target_properties(solver_csparse PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-target_include_directories(solver_csparse PUBLIC
-  $<BUILD_INTERFACE:${CSPARSE_INCLUDE_DIR}>
-  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-  $<INSTALL_INTERFACE:include/g2o/solvers/csparse>)
-target_link_libraries(solver_csparse
-  PUBLIC csparse_extension
-  PUBLIC core)
-
-install(TARGETS solver_csparse csparse_extension
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-  )
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/csparse)
diff --git a/g2o/solvers/csparse/csparse_extension.cpp b/g2o/solvers/csparse/csparse_extension.cpp
deleted file mode 100644
index 3dab043f..00000000
--- a/g2o/solvers/csparse/csparse_extension.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-// CSparse: a Concise Sparse matrix package.
-// Copyright (c) 2005, Timothy A. Davis.
-// http://www.cise.ufl.edu/research/sparse/CSparse
-// 
-// --------------------------------------------------------------------------------
-// 
-// CSparse is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 1.1 of the License, or (at your option) any later version.
-// 
-// CSparse is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this Module; if not, write to the Free Software
-// Foundation, Inc., 50 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-#include <iostream>
-#include "csparse_extension.h"
-
-#include "g2o/stuff/macros.h"
-
-using namespace std;
-
-namespace g2o {
-namespace csparse_extension {
-
-  /**
-   * Originally from CSparse, avoid memory re-allocations by giving workspace pointers
-   * CSparse: Copyright (c) 2006-2011, Timothy A. Davis.
-   */
-  int cs_cholsolsymb(const cs *A, number_t *b, const css* S, number_t* x, int* work)
-  {
-    csn *N ;
-    int n, ok ;
-    if (!CS_CSC (A) || !b || ! S || !x) {
-      cerr << __PRETTY_FUNCTION__ << ": No valid input!" << endl;
-      assert(0); // get a backtrace in debug mode
-      return (0) ;     /* check inputs */
-    }
-    n = A->n ;
-    N = cs_chol_workspace (A, S, work, x) ;                    /* numeric Cholesky factorization */
-    if (!N) {
-      cerr << __PRETTY_FUNCTION__ << ": cholesky failed!" << endl;
-      /*assert(0);*/
-    }
-    ok = (N != NULL) ;
-    if (ok)
-    {
-      cs_ipvec (S->pinv, b, x, n) ;   /* x = P*b */
-      cs_lsolve (N->L, x) ;           /* x = L\x */
-      cs_ltsolve (N->L, x) ;          /* x = L'\x */
-      cs_pvec (S->pinv, x, b, n) ;    /* b = P'*x */
-    }
-    cs_nfree (N) ;
-    return (ok) ;
-  }
-
-  /**
-   * Originally from CSparse, avoid memory re-allocations by giving workspace pointers
-   * CSparse: Copyright (c) 2006-2011, Timothy A. Davis.
-   */
-  /* L = chol (A, [pinv parent cp]), pinv is optional */
-  csn* cs_chol_workspace (const cs *A, const css *S, int* cin, number_t* xin)
-  {
-    number_t d, lki, *Lx, *x, *Cx ;
-    int top, i, p, k, n, *Li, *Lp, *cp, *pinv, *s, *c, *parent, *Cp, *Ci ;
-    cs *L, *C, *E ;
-    csn *N ;
-    if (!CS_CSC (A) || !S || !S->cp || !S->parent) return (NULL) ;
-    n = A->n ;
-    N = (csn*) cs_calloc (1, sizeof (csn)) ;       /* allocate result */
-    c = cin ;     /* get int workspace */
-    x = xin ;    /* get number_t workspace */
-    cp = S->cp ; pinv = S->pinv ; parent = S->parent ;
-    C = pinv ? cs_symperm (A, pinv, 1) : ((cs *) A) ;
-    E = pinv ? C : NULL ;           /* E is alias for A, or a copy E=A(p,p) */
-    if (!N || !c || !x || !C) return (cs_ndone (N, E, NULL, NULL, 0)) ;
-    s = c + n ;
-    Cp = C->p ; Ci = C->i ; Cx = C->x ;
-    N->L = L = cs_spalloc (n, n, cp [n], 1, 0) ;    /* allocate result */
-    if (!L) return (cs_ndone (N, E, NULL, NULL, 0)) ;
-    Lp = L->p ; Li = L->i ; Lx = L->x ;
-    for (k = 0 ; k < n ; k++) Lp [k] = c [k] = cp [k] ;
-    for (k = 0 ; k < n ; k++)       /* compute L(k,:) for L*L' = C */
-    {
-      /* --- Nonzero pattern of L(k,:) ------------------------------------ */
-      top = cs_ereach (C, k, parent, s, c) ;      /* find pattern of L(k,:) */
-      x [k] = 0 ;                                 /* x (0:k) is now zero */
-      for (p = Cp [k] ; p < Cp [k+1] ; p++)       /* x = full(triu(C(:,k))) */
-      {
-        if (Ci [p] <= k) x [Ci [p]] = Cx [p] ;
-      }
-      d = x [k] ;                     /* d = C(k,k) */
-      x [k] = 0 ;                     /* clear x for k+1st iteration */
-      /* --- Triangular solve --------------------------------------------- */
-      for ( ; top < n ; top++)    /* solve L(0:k-1,0:k-1) * x = C(:,k) */
-      {
-        i = s [top] ;               /* s [top..n-1] is pattern of L(k,:) */
-        lki = x [i] / Lx [Lp [i]] ; /* L(k,i) = x (i) / L(i,i) */
-        x [i] = 0 ;                 /* clear x for k+1st iteration */
-        for (p = Lp [i] + 1 ; p < c [i] ; p++)
-        {
-          x [Li [p]] -= Lx [p] * lki ;
-        }
-        d -= lki * lki ;            /* d = d - L(k,i)*L(k,i) */
-        p = c [i]++ ;
-        Li [p] = k ;                /* store L(k,i) in column i */
-        Lx [p] = lki ;
-      }
-      /* --- Compute L(k,k) ----------------------------------------------- */
-      if (d <= 0) return (cs_ndone (N, E, NULL, NULL, 0)) ; /* not pos def */
-      p = c [k]++ ;
-      Li [p] = k ;                /* store L(k,k) = sqrt (d) in column k */
-      Lx [p] = sqrt (d) ;
-    }
-    Lp [n] = cp [n] ;               /* finalize L */
-    return (cs_ndone (N, E, NULL, NULL, 1)) ; /* success: free E,s,x; return N */
-  }
-
-} // end namespace
-} // end namespace
diff --git a/g2o/solvers/csparse/csparse_extension.h b/g2o/solvers/csparse/csparse_extension.h
deleted file mode 100644
index 8b9da26e..00000000
--- a/g2o/solvers/csparse/csparse_extension.h
+++ /dev/null
@@ -1,47 +0,0 @@
-// CSparse: a Concise Sparse matrix package.
-// Copyright (c) 2006, Timothy A. Davis.
-// http://www.cise.ufl.edu/research/sparse/CSparse
-// 
-// --------------------------------------------------------------------------------
-// 
-// CSparse is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-// 
-// CSparse is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this Module; if not, write to the Free Software
-// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-#ifndef G2O_CSPARSE_EXTENSION_H
-#define G2O_CSPARSE_EXTENSION_H
-
-#ifndef NCOMPLEX
-#define NCOMPLEX
-#endif
-#include <cs.h>
-
-#include "g2o_csparse_extension_api.h"
-
-namespace g2o {
-
-  namespace csparse_extension {
-
-// our extensions to csparse
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-  /**
-   * Originally from CSparse, avoid memory re-allocations by giving workspace pointers
-   * CSparse: Copyright (c) 2006-2011, Timothy A. Davis.
-   */
-G2O_CSPARSE_EXTENSION_API csn* cs_chol_workspace (const cs *A, const css *S, int* cin, number_t* xin);
-G2O_CSPARSE_EXTENSION_API int cs_cholsolsymb(const cs *A, number_t *b, const css* S, number_t* workspace, int* work);
-
-} // end namespace
-} // end namespace
-
-#endif
diff --git a/g2o/solvers/csparse/csparse_helper.cpp b/g2o/solvers/csparse/csparse_helper.cpp
deleted file mode 100644
index f34622c5..00000000
--- a/g2o/solvers/csparse/csparse_helper.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "csparse_helper.h"
-
-#include "g2o/stuff/sparse_helper.h"
-
-using namespace std;
-
-namespace g2o {
-namespace csparse_extension {
-
-bool writeCs2Octave(const char* filename, const cs* A, bool upperTriangular) {
-  int cols = A->n;
-  int rows = A->m;
-
-  if (A->nz == -1) {  // CCS matrix
-    const int* Ap = A->p;
-    const int* Ai = A->i;
-    const number_t* Ax = A->x;
-    return writeCCSMatrix(filename, rows, cols, Ap, Ai, Ax, upperTriangular);
-  } else {  // Triplet matrix
-    const int* Aj = A->p;
-    const int* Ai = A->i;
-    const number_t* Ax = A->x;
-    return writeTripletMatrix(filename, A->nz, rows, cols, Ai, Aj, Ax, upperTriangular);
-  }
-}
-
-}  // namespace csparse_extension
-}  // namespace g2o
diff --git a/g2o/solvers/csparse/csparse_helper.h b/g2o/solvers/csparse/csparse_helper.h
deleted file mode 100644
index 632022c5..00000000
--- a/g2o/solvers/csparse/csparse_helper.h
+++ /dev/null
@@ -1,46 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_CSPARSE_HELPER_H
-#define G2O_CSPARSE_HELPER_H
-
-#include "csparse_extension.h"
-
-#include "g2o_csparse_extension_api.h"
-
-namespace g2o {
-
-  namespace csparse_extension {
-
-/**
- * write the sparse matrix to a file loadable with ocatve
- */
-G2O_CSPARSE_EXTENSION_API bool writeCs2Octave(const char* filename, const cs* A, bool upperTriangular = true);
-
-} // end namespace
-} // end namespace
-
-#endif
diff --git a/g2o/solvers/csparse/g2o_csparse_api.h b/g2o/solvers/csparse/g2o_csparse_api.h
deleted file mode 100644
index 7bb8c8fc..00000000
--- a/g2o/solvers/csparse/g2o_csparse_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_SOLVER_CSPARSE_API_H
-#define G2O_SOLVER_CSPARSE_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef solver_csparse_EXPORTS
-#define G2O_SOLVER_CSPARSE_API __declspec(dllexport)
-#else
-#define G2O_SOLVER_CSPARSE_API __declspec(dllimport)
-#endif
-#else
-#define G2O_SOLVER_CSPARSE_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_SOLVER_CSPARSE_API
-#endif
-
-#endif // G2O_CSPARSE_API_H
diff --git a/g2o/solvers/csparse/g2o_csparse_extension_api.h b/g2o/solvers/csparse/g2o_csparse_extension_api.h
deleted file mode 100644
index a230cb40..00000000
--- a/g2o/solvers/csparse/g2o_csparse_extension_api.h
+++ /dev/null
@@ -1,39 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2012 Rainer Kuemmerle
-// 
-// g2o is free software: you can redistribute it and/or modify
-// it under the terms of the GNU Lesser General Public License as published
-// by the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-// 
-// g2o is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef G2O_CSPARSE_EXTENSION_API_H
-#define G2O_CSPARSE_EXTENSION_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_LGPL_SHARED_LIBS
-#ifdef csparse_extension_EXPORTS
-#define G2O_CSPARSE_EXTENSION_API __declspec(dllexport)
-#else
-#define G2O_CSPARSE_EXTENSION_API __declspec(dllimport)
-#endif
-#else
-#define G2O_CSPARSE_EXTENSION_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_CSPARSE_EXTENSION_API
-#endif
-
-#endif // G2O_CSPARSE_API_H
diff --git a/g2o/solvers/csparse/linear_solver_csparse.h b/g2o/solvers/csparse/linear_solver_csparse.h
deleted file mode 100644
index ae26f6e5..00000000
--- a/g2o/solvers/csparse/linear_solver_csparse.h
+++ /dev/null
@@ -1,267 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINEAR_SOLVERCSPARSE_H
-#define G2O_LINEAR_SOLVERCSPARSE_H
-
-#include <iostream>
-
-#include "csparse_helper.h"
-#include "g2o/core/batch_stats.h"
-#include "g2o/core/linear_solver.h"
-#include "g2o/core/marginal_covariance_cholesky.h"
-#include "g2o/stuff/timeutil.h"
-#include "g2o_csparse_api.h"
-
-namespace g2o {
-
-/**
- * \brief Our C++ version of the csparse struct
- */
-struct G2O_SOLVER_CSPARSE_API CSparseExt : public cs {
-  CSparseExt() {
-    nzmax = 0;
-    m = 0;
-    n = 0;
-    p = 0;
-    i = 0;
-    x = 0;
-    nz = 0;
-    columnsAllocated = 0;
-  }
-  CSparseExt(CSparseExt const&) = delete;
-  CSparseExt& operator=(CSparseExt const&) = delete;
-  ~CSparseExt() {
-    delete[] p;
-    delete[] i;
-    delete[] x;
-  }
-  int columnsAllocated;
-};
-
-/**
- * \brief linear solver which uses CSparse
- */
-template <typename MatrixType>
-class LinearSolverCSparse : public LinearSolverCCS<MatrixType> {
- public:
-  LinearSolverCSparse()
-      : LinearSolverCCS<MatrixType>(),
-        _symbolicDecomposition(nullptr),
-        _csWorkspaceSize(-1),
-        _csWorkspace(nullptr),
-        _csIntWorkspace(nullptr) {}
-
-  LinearSolverCSparse(LinearSolverCSparse<MatrixType> const&) = delete;
-  LinearSolverCSparse& operator=(LinearSolverCSparse<MatrixType> const&) = delete;
-
-  virtual ~LinearSolverCSparse() {
-    if (_symbolicDecomposition) {
-      cs_sfree(_symbolicDecomposition);
-      _symbolicDecomposition = nullptr;
-    }
-    delete[] _csWorkspace;
-    _csWorkspace = nullptr;
-    delete[] _csIntWorkspace;
-    _csIntWorkspace = nullptr;
-  }
-
-  virtual bool init() {
-    if (_symbolicDecomposition) {
-      cs_sfree(_symbolicDecomposition);
-      _symbolicDecomposition = nullptr;
-    }
-    return true;
-  }
-
-  bool solve(const SparseBlockMatrix<MatrixType>& A, number_t* x, number_t* b) {
-    prepareSolve(A);
-
-    number_t t = get_monotonic_time();
-    // _x = _b for calling csparse
-    if (x != b) memcpy(x, b, _ccsA.n * sizeof(number_t));
-    int ok = csparse_extension::cs_cholsolsymb(&_ccsA, x, _symbolicDecomposition, _csWorkspace,
-                                               _csIntWorkspace);
-    if (!ok && this->writeDebug()) {
-      std::cerr << "Cholesky failure, writing debug.txt (Hessian loadable by Octave)" << std::endl;
-      csparse_extension::writeCs2Octave("debug.txt", &_ccsA, true);
-    }
-
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->timeNumericDecomposition = get_monotonic_time() - t;
-      globalStats->choleskyNNZ = static_cast<size_t>(_symbolicDecomposition->lnz);
-    }
-
-    return ok != 0;
-  }
-
- protected:
-  css* _symbolicDecomposition;
-  int _csWorkspaceSize;
-  number_t* _csWorkspace;
-  int* _csIntWorkspace;
-  CSparseExt _ccsA;
-  MatrixStructure _matrixStructure;
-  VectorXI _scalarPermutation;
-
-  void prepareSolve(const SparseBlockMatrix<MatrixType>& A) {
-    fillCSparse(A, _symbolicDecomposition != 0);
-    // perform symbolic cholesky once
-    if (_symbolicDecomposition == nullptr) {
-      computeSymbolicDecomposition(A);
-      assert(_symbolicDecomposition && "Symbolic cholesky failed");
-    }
-    // re-allocate the temporary workspace for cholesky
-    if (_csWorkspaceSize < _ccsA.n) {
-      _csWorkspaceSize = 2 * _ccsA.n;
-      delete[] _csWorkspace;
-      _csWorkspace = new number_t[_csWorkspaceSize];
-      delete[] _csIntWorkspace;
-      _csIntWorkspace = new int[2 * _csWorkspaceSize];
-    }
-  }
-
-  void computeSymbolicDecomposition(const SparseBlockMatrix<MatrixType>& A) {
-    number_t t = get_monotonic_time();
-    if (!this->blockOrdering()) {
-      _symbolicDecomposition = cs_schol(1, &_ccsA);
-    } else {
-      A.fillBlockStructure(_matrixStructure);
-
-      // prepare block structure for the CSparse call
-      cs auxBlock;
-      auxBlock.nzmax = _matrixStructure.nzMax();
-      auxBlock.m = auxBlock.n = _matrixStructure.n;
-      auxBlock.p = _matrixStructure.Ap;
-      auxBlock.i = _matrixStructure.Aii;
-      auxBlock.x = NULL;  // no values
-      auxBlock.nz = -1;   // CCS format
-
-      // AMD ordering on the block structure
-      const int& n = _ccsA.n;
-      int* P = cs_amd(1, &auxBlock);
-
-      // blow up the permutation to the scalar matrix
-      VectorXI::MapType blockPermutation(P, _matrixStructure.n);
-      this->blockToScalarPermutation(A, blockPermutation, _scalarPermutation);
-      cs_free(P);  // clean the memory
-
-      // apply the scalar permutation to finish symbolic decomposition
-      _symbolicDecomposition = (css*)cs_calloc(1, sizeof(css)); /* allocate result S */
-      _symbolicDecomposition->pinv = cs_pinv(_scalarPermutation.data(), n);
-      cs* C = cs_symperm(&_ccsA, _symbolicDecomposition->pinv, 0);
-      _symbolicDecomposition->parent = cs_etree(C, 0);
-      int* post = cs_post(_symbolicDecomposition->parent, n);
-      int* c = cs_counts(C, _symbolicDecomposition->parent, post, 0);
-      cs_free(post);
-      cs_spfree(C);
-      _symbolicDecomposition->cp = (int*)cs_malloc(n + 1, sizeof(int));
-      _symbolicDecomposition->unz = _symbolicDecomposition->lnz =
-          cs_cumsum(_symbolicDecomposition->cp, c, n);
-      cs_free(c);
-      if (_symbolicDecomposition->lnz < 0) {
-        cs_sfree(_symbolicDecomposition);
-        _symbolicDecomposition = nullptr;
-      }
-    }
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->timeSymbolicDecomposition = get_monotonic_time() - t;
-    }
-
-    /* std::cerr << "# Number of nonzeros in L: " << (int)_symbolicDecomposition->lnz << " by " */
-    /*   << (_blockOrdering ? "block" : "scalar") << " AMD ordering " << std::endl; */
-  }
-
-  void fillCSparse(const SparseBlockMatrix<MatrixType>& A, bool onlyValues) {
-    if (!onlyValues) this->initMatrixStructure(A);
-    int m = A.rows();
-    int n = A.cols();
-    assert(m > 0 && n > 0 && "Hessian has 0 rows/cols");
-
-    if (_ccsA.columnsAllocated < n) {
-      // pre-allocate more space if re-allocating
-      _ccsA.columnsAllocated = _ccsA.columnsAllocated == 0 ? n : 2 * n;
-      delete[] _ccsA.p;
-      _ccsA.p = new int[_ccsA.columnsAllocated + 1];
-    }
-
-    if (!onlyValues) {
-      int nzmax = A.nonZeros();
-      if (_ccsA.nzmax < nzmax) {
-        // pre-allocate more space if re-allocating
-        _ccsA.nzmax = _ccsA.nzmax == 0 ? nzmax : 2 * nzmax;
-        delete[] _ccsA.x;
-        delete[] _ccsA.i;
-        _ccsA.i = new int[_ccsA.nzmax];
-        _ccsA.x = new number_t[_ccsA.nzmax];
-      }
-    }
-    _ccsA.m = m;
-    _ccsA.n = n;
-
-    if (onlyValues) {
-      this->_ccsMatrix->fillCCS(_ccsA.x, true);
-    } else {
-      int nz = this->_ccsMatrix->fillCCS(_ccsA.p, _ccsA.i, _ccsA.x, true);
-      (void)nz;
-      assert(nz <= _ccsA.nzmax);
-    }
-    _ccsA.nz = -1;  // tag as CCS formatted matrix
-  }
-
-  /**
-   * Implementation of the general parts for computing the inverse blocks of the linear system
-   * matrix. Here we call a function to do the underlying computation.
-   */
-  bool solveBlocks_impl(const SparseBlockMatrix<MatrixType>& A,
-                        std::function<void(MarginalCovarianceCholesky&)> compute) {
-    prepareSolve(A);
-    bool ok = true;
-    csn* numericCholesky = csparse_extension::cs_chol_workspace(&_ccsA, _symbolicDecomposition,
-                                                                _csIntWorkspace, _csWorkspace);
-    if (numericCholesky) {
-      MarginalCovarianceCholesky mcc;
-      mcc.setCholeskyFactor(_ccsA.n, numericCholesky->L->p, numericCholesky->L->i,
-                            numericCholesky->L->x, _symbolicDecomposition->pinv);
-      compute(mcc);
-      cs_nfree(numericCholesky);
-    } else {
-      ok = false;
-      std::cerr << "inverse fail (numeric decomposition)" << std::endl;
-    }
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->choleskyNNZ = static_cast<size_t>(_symbolicDecomposition->lnz);
-    }
-    return ok;
-  }
-};
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/solvers/csparse/solver_csparse.cpp b/g2o/solvers/csparse/solver_csparse.cpp
deleted file mode 100644
index 327e736f..00000000
--- a/g2o/solvers/csparse/solver_csparse.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-//
-// g2o is free software: you can redistribute it and/or modify
-// it under the terms of the GNU Lesser General Public License as published
-// by the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// g2o is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU Lesser General Public License for more details.
-//
-// You should have received a copy of the GNU Lesser General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "g2o/core/block_solver.h"
-#include "g2o/core/optimization_algorithm_dogleg.h"
-#include "g2o/core/optimization_algorithm_factory.h"
-#include "g2o/core/optimization_algorithm_gauss_newton.h"
-#include "g2o/core/optimization_algorithm_levenberg.h"
-#include "g2o/core/solver.h"
-#include "g2o/core/sparse_optimizer.h"
-#include "g2o/stuff/macros.h"
-#include "linear_solver_csparse.h"
-
-using namespace std;
-
-namespace g2o {
-
-namespace {
-template <int p, int l, bool blockorder>
-std::unique_ptr<BlockSolverBase> AllocateSolver() {
-  std::cerr << "# Using CSparse poseDim " << p << " landMarkDim " << l << " blockordering "
-            << blockorder << std::endl;
-  auto linearSolver =
-      g2o::make_unique<LinearSolverCSparse<typename BlockSolverPL<p, l>::PoseMatrixType>>();
-  linearSolver->setBlockOrdering(blockorder);
-  return g2o::make_unique<BlockSolverPL<p, l>>(std::move(linearSolver));
-}
-}  // namespace
-
-/**
- * helper function for allocating
- */
-static OptimizationAlgorithm* createSolver(const std::string& fullSolverName) {
-  static const std::map<std::string, std::function<std::unique_ptr<BlockSolverBase>()>>
-      solver_factories{
-          {"var_csparse", &AllocateSolver<-1, -1, false>},
-          {"fix3_2_csparse", &AllocateSolver<3, 2, true>},
-          {"fix6_3_csparse", &AllocateSolver<6, 3, true>},
-          {"fix7_3_csparse", &AllocateSolver<7, 3, true>},
-          {"fix3_2_scalar_csparse", &AllocateSolver<3, 2, false>},
-          {"fix6_3_scalar_csparse", &AllocateSolver<6, 3, false>},
-          {"fix7_3_scalar_csparse", &AllocateSolver<7, 3, false>},
-      };
-
-  string solverName = fullSolverName.substr(3);
-  auto solverf = solver_factories.find(solverName);
-  if (solverf == solver_factories.end()) return nullptr;
-
-  string methodName = fullSolverName.substr(0, 2);
-
-  if (methodName == "gn") {
-    return new OptimizationAlgorithmGaussNewton(solverf->second());
-  } else if (methodName == "lm") {
-    return new OptimizationAlgorithmLevenberg(solverf->second());
-  } else if (methodName == "dl") {
-    return new OptimizationAlgorithmDogleg(solverf->second());
-  }
-
-  return nullptr;
-}
-
-class CSparseSolverCreator : public AbstractOptimizationAlgorithmCreator {
- public:
-  explicit CSparseSolverCreator(const OptimizationAlgorithmProperty& p)
-      : AbstractOptimizationAlgorithmCreator(p) {}
-  virtual OptimizationAlgorithm* construct() { return createSolver(property().name); }
-};
-
-// clang-format off
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(csparse);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_var_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("gn_var_csparse", "Gauss-Newton: Cholesky solver using CSparse (variable blocksize)", "CSparse", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix3_2_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("gn_fix3_2_csparse", "Gauss-Newton: Cholesky solver using CSparse (fixed blocksize)", "CSparse", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix6_3_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("gn_fix6_3_csparse", "Gauss-Newton: Cholesky solver using CSparse (fixed blocksize)", "CSparse", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix7_3_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("gn_fix7_3_csparse", "Gauss-Newton: Cholesky solver using CSparse (fixed blocksize)", "CSparse", true, 7, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_var_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("lm_var_csparse", "Levenberg: Cholesky solver using CSparse (variable blocksize)", "CSparse", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix3_2_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("lm_fix3_2_csparse", "Levenberg: Cholesky solver using CSparse (fixed blocksize)", "CSparse", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix6_3_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("lm_fix6_3_csparse", "Levenberg: Cholesky solver using CSparse (fixed blocksize)", "CSparse", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix7_3_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("lm_fix7_3_csparse", "Levenberg: Cholesky solver using CSparse (fixed blocksize)", "CSparse", true, 7, 3)));
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(dl_var_csparse, new CSparseSolverCreator(OptimizationAlgorithmProperty("dl_var_csparse", "Dogleg: Cholesky solver using CSparse (variable blocksize)", "CSparse", false, Eigen::Dynamic, Eigen::Dynamic)));
-// clang-format on
-
-}  // namespace g2o
diff --git a/g2o/solvers/dense/CMakeLists.txt b/g2o/solvers/dense/CMakeLists.txt
deleted file mode 100644
index 64c6fc5b..00000000
--- a/g2o/solvers/dense/CMakeLists.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-add_library(solver_dense ${G2O_LIB_TYPE}
-  solver_dense.cpp linear_solver_dense.h
-)
-
-set_target_properties(solver_dense PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_dense)
-if (APPLE)
-  set_target_properties(solver_dense PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-target_link_libraries(solver_dense core)
-
-install(TARGETS solver_dense
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/dense)
diff --git a/g2o/solvers/dense/linear_solver_dense.h b/g2o/solvers/dense/linear_solver_dense.h
deleted file mode 100644
index 9884b532..00000000
--- a/g2o/solvers/dense/linear_solver_dense.h
+++ /dev/null
@@ -1,125 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// Copyright (C) 2012 R. Kmmerle
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINEAR_SOLVER_DENSE_H
-#define G2O_LINEAR_SOLVER_DENSE_H
-
-#include "g2o/core/linear_solver.h"
-#include "g2o/core/batch_stats.h"
-
-#include <vector>
-#include <utility>
-#include<Eigen/Core>
-#include<Eigen/Cholesky>
-
-
-namespace g2o {
-
-  /**
-   * \brief linear solver using dense cholesky decomposition
-   */
-  template <typename MatrixType>
-  class LinearSolverDense : public LinearSolver<MatrixType>
-  {
-    public:
-      LinearSolverDense() :
-        LinearSolver<MatrixType>(),
-        _reset(true)
-      {
-      }
-
-      virtual ~LinearSolverDense()
-      {
-      }
-
-      virtual bool init()
-      {
-        _reset = true;
-        return true;
-      }
-
-      bool solve(const SparseBlockMatrix<MatrixType>& A, number_t* x, number_t* b)
-      {
-        int n = A.cols();
-        int m = A.cols();
-
-        MatrixX& H = _H;
-        if (H.cols() != n) {
-          H.resize(n, m);
-          _reset = true;
-        }
-        if (_reset) {
-          _reset = false;
-          H.setZero();
-        }
-
-        // copy the sparse block matrix into a dense matrix
-        int c_idx = 0;
-        for (size_t i = 0; i < A.blockCols().size(); ++i) {
-          int c_size = A.colsOfBlock(i);
-          assert(c_idx == A.colBaseOfBlock(i) && "mismatch in block indices");
-
-          const typename SparseBlockMatrix<MatrixType>::IntBlockMap& col = A.blockCols()[i];
-          if (col.size() > 0) {
-            typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it;
-            for (it = col.begin(); it != col.end(); ++it) {
-              int r_idx = A.rowBaseOfBlock(it->first);
-              // only the upper triangular block is processed
-              if (it->first <= (int)i) {
-                int r_size = A.rowsOfBlock(it->first);
-                H.block(r_idx, c_idx, r_size, c_size) = *(it->second);
-                if (r_idx != c_idx) // write the lower triangular block
-                  H.block(c_idx, r_idx, c_size, r_size) = it->second->transpose();
-              }
-            }
-          }
-
-          c_idx += c_size;
-        }
-
-        // solving via Cholesky decomposition
-        VectorX::MapType xvec(x, m);
-        VectorX::ConstMapType bvec(b, n);
-        _cholesky.compute(H);
-        if (_cholesky.isPositive()) {
-          xvec = _cholesky.solve(bvec);
-          return true;
-        }
-        return false;
-      }
-
-    protected:
-      bool _reset;
-      MatrixX _H;
-      Eigen::LDLT<MatrixX> _cholesky;
-
-  };
-
-
-}// end namespace
-
-#endif
diff --git a/g2o/solvers/dense/solver_dense.cpp b/g2o/solvers/dense/solver_dense.cpp
deleted file mode 100644
index 132cdfaa..00000000
--- a/g2o/solvers/dense/solver_dense.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "linear_solver_dense.h"
-
-#include "g2o/config.h"
-#include "g2o/core/block_solver.h"
-#include "g2o/core/solver.h"
-#include "g2o/core/optimization_algorithm_factory.h"
-
-#include "g2o/core/optimization_algorithm_gauss_newton.h"
-#include "g2o/core/optimization_algorithm_levenberg.h"
-
-using namespace std;
-
-namespace g2o
-{
-  namespace
-  {
-    template<int p, int l>
-    std::unique_ptr<g2o::Solver> AllocateSolver()
-    {
-        std::cerr << "# Using DENSE poseDim " << p << " landMarkDim " << l << std::endl;
-        return g2o::make_unique<BlockSolverPL<p, l>>(
-          g2o::make_unique<LinearSolverDense<typename BlockSolverPL<p, l>::PoseMatrixType>>());
-    }
-  }
-
-  static OptimizationAlgorithm* createSolver(const std::string& fullSolverName)
-  {
-    static const std::map<std::string, std::function<std::unique_ptr<g2o::Solver>()>> solver_factories{
-      { "pcg", &AllocateSolver<-1, -1> },
-      { "pcg3_2", &AllocateSolver<3, 2> },
-      { "pcg6_3", &AllocateSolver<6, 3> },
-      { "pcg7_3", &AllocateSolver<7, 3> },
-    };
-
-    string solverName = fullSolverName.substr(3);
-    auto solverf = solver_factories.find(solverName);
-    if (solverf == solver_factories.end())
-      return nullptr;
-
-    string methodName = fullSolverName.substr(0, 2);
-
-    if (methodName == "gn")
-    {
-      return new OptimizationAlgorithmGaussNewton(solverf->second());
-    }
-    else if (methodName == "lm")
-    {
-      return new OptimizationAlgorithmLevenberg(solverf->second());
-    }
-
-    return nullptr;
-  }
-
-  class DenseSolverCreator : public AbstractOptimizationAlgorithmCreator {
-   public:
-    explicit DenseSolverCreator(const OptimizationAlgorithmProperty& p) : AbstractOptimizationAlgorithmCreator(p) {}
-    virtual OptimizationAlgorithm* construct() { return createSolver(property().name); }
-  };
-
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(dense);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_dense, new DenseSolverCreator(OptimizationAlgorithmProperty("gn_dense", "Gauss-Newton: Dense solver (variable blocksize)", "Dense", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_dense3_2, new DenseSolverCreator(OptimizationAlgorithmProperty("gn_dense3_2", "Gauss-Newton: Dense solver (fixed blocksize)", "Dense", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_dense6_3, new DenseSolverCreator(OptimizationAlgorithmProperty("gn_dense6_3", "Gauss-Newton: Dense solver (fixed blocksize)", "Dense", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_dense7_3, new DenseSolverCreator(OptimizationAlgorithmProperty("gn_dense7_3", "Gauss-Newton: Dense solver (fixed blocksize)", "Dense", true, 7, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_dense, new DenseSolverCreator(OptimizationAlgorithmProperty("lm_dense", "Levenberg: Dense solver (variable blocksize)", "Dense", false, -1, -1)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_dense3_2, new DenseSolverCreator(OptimizationAlgorithmProperty("lm_dense3_2", "Levenberg: Dense solver (fixed blocksize)", "Dense", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_dense6_3, new DenseSolverCreator(OptimizationAlgorithmProperty("lm_dense6_3", "Levenberg: Dense solver (fixed blocksize)", "Dense", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_dense7_3, new DenseSolverCreator(OptimizationAlgorithmProperty("lm_dense7_3", "Levenberg: Dense solver (fixed blocksize)", "Dense", true, 7, 3)));
-
-} // end namespace
diff --git a/g2o/solvers/eigen/CMakeLists.txt b/g2o/solvers/eigen/CMakeLists.txt
deleted file mode 100644
index ee85fe69..00000000
--- a/g2o/solvers/eigen/CMakeLists.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-add_library(solver_eigen ${G2O_LIB_TYPE}
-  solver_eigen.cpp
-  linear_solver_eigen.h
-)
-set_target_properties(solver_eigen PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_eigen)
-if (APPLE)
-  set_target_properties(solver_eigen PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(solver_eigen core)
-
-install(TARGETS solver_eigen
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/eigen)
-
diff --git a/g2o/solvers/eigen/linear_solver_eigen.h b/g2o/solvers/eigen/linear_solver_eigen.h
deleted file mode 100644
index ff434a41..00000000
--- a/g2o/solvers/eigen/linear_solver_eigen.h
+++ /dev/null
@@ -1,207 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINEAR_SOLVER_EIGEN_H
-#define G2O_LINEAR_SOLVER_EIGEN_H
-
-#include <Eigen/Sparse>
-#include <Eigen/SparseCholesky>
-#include <iostream>
-#include <vector>
-
-#include "g2o/core/batch_stats.h"
-#include "g2o/core/linear_solver.h"
-#include "g2o/core/marginal_covariance_cholesky.h"
-#include "g2o/stuff/timeutil.h"
-
-namespace g2o {
-
-/**
- * \brief linear solver which uses the sparse Cholesky solver from Eigen
- *
- * Has no dependencies except Eigen. Hence, should compile almost everywhere
- * without to much issues. Performance should be similar to CSparse.
- */
-template <typename MatrixType>
-class LinearSolverEigen : public LinearSolverCCS<MatrixType> {
- public:
-  typedef Eigen::SparseMatrix<number_t, Eigen::ColMajor> SparseMatrix;
-  typedef Eigen::Triplet<number_t> Triplet;
-  typedef Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic> PermutationMatrix;
-
-  using CholeskyDecompositionBase = Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper>;
-
-  /**
-   * \brief Sub-classing Eigen's SimplicialLLT to perform ordering with a given ordering
-   */
-  class CholeskyDecomposition : public CholeskyDecompositionBase {
-   public:
-    CholeskyDecomposition() : CholeskyDecompositionBase() {}
-
-    //! use a given permutation for analyzing the pattern of the sparse matrix
-    void analyzePatternWithPermutation(SparseMatrix& a, const PermutationMatrix& permutation) {
-      m_Pinv = permutation;
-      m_P = permutation.inverse();
-      int size = a.cols();
-      SparseMatrix ap(size, size);
-      ap.selfadjointView<Eigen::Upper>() = a.selfadjointView<UpLo>().twistedBy(m_P);
-      analyzePattern_preordered(ap, false);
-    }
-
-   protected:
-    using CholeskyDecompositionBase::analyzePattern_preordered;
-  };
-
- public:
-  LinearSolverEigen()
-      : LinearSolverCCS<MatrixType>(), _init(true) {}
-
-  virtual bool init() {
-    _init = true;
-    return true;
-  }
-
-  bool solve(const SparseBlockMatrix<MatrixType>& A, number_t* x, number_t* b) {
-    double t;
-    bool cholState = computeCholesky(A, t);
-    if (!cholState) return false;
-
-    // Solving the system
-    VectorX::MapType xx(x, _sparseMatrix.cols());
-    VectorX::ConstMapType bb(b, _sparseMatrix.cols());
-    xx = _cholesky.solve(bb);
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->timeNumericDecomposition = get_monotonic_time() - t;
-      globalStats->choleskyNNZ = _cholesky.matrixL().nestedExpression().nonZeros();
-    }
-    return true;
-  }
-
- protected:
-  bool _init;
-  SparseMatrix _sparseMatrix;
-  CholeskyDecomposition _cholesky;
-
-  // compute the cholesky factor
-  bool computeCholesky(const SparseBlockMatrix<MatrixType>& A, double& t) {
-    // perform some operations only once upon init
-    if (_init) _sparseMatrix.resize(A.rows(), A.cols());
-    fillSparseMatrix(A, !_init);
-    if (_init) computeSymbolicDecomposition(A);
-    _init = false;
-
-    t = get_monotonic_time();
-    _cholesky.factorize(_sparseMatrix);
-    if (_cholesky.info() != Eigen::Success) {  // the matrix is not positive definite
-      if (this->writeDebug()) {
-        std::cerr << "Cholesky failure, writing debug.txt (Hessian loadable by Octave)"
-                  << std::endl;
-        A.writeOctave("debug.txt");
-      }
-      return false;
-    }
-    return true;
-  }
-
-  /**
-   * compute the symbolic decompostion of the matrix only once.
-   * Since A has the same pattern in all the iterations, we only
-   * compute the fill-in reducing ordering once and re-use for all
-   * the following iterations.
-   */
-  void computeSymbolicDecomposition(const SparseBlockMatrix<MatrixType>& A) {
-    number_t t = get_monotonic_time();
-    if (!this->blockOrdering()) {
-      _cholesky.analyzePattern(_sparseMatrix);
-    } else {
-      assert(A.rows() == A.cols() && "Matrix A is not square");
-      // block ordering with the Eigen Interface
-      Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic> blockP;
-      {
-        SparseMatrix auxBlockMatrix(A.blockCols().size(), A.blockCols().size());
-        auxBlockMatrix.resizeNonZeros(A.nonZeroBlocks());
-        // fill the CCS structure of the Eigen SparseMatrix
-        A.fillBlockStructure(auxBlockMatrix.outerIndexPtr(), auxBlockMatrix.innerIndexPtr());
-        // determine ordering by AMD
-        using Ordering = Eigen::AMDOrdering<typename CholeskyDecomposition::StorageIndex>;
-        Ordering ordering;
-        ordering(auxBlockMatrix, blockP);
-      }
-
-      // Adapt the block permutation to the scalar matrix
-      PermutationMatrix scalarP(A.rows());
-      this->blockToScalarPermutation(A, blockP.indices(), scalarP.indices());
-      // analyze with the scalar permutation
-      _cholesky.analyzePatternWithPermutation(_sparseMatrix, scalarP);
-    }
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) globalStats->timeSymbolicDecomposition = get_monotonic_time() - t;
-  }
-
-  void fillSparseMatrix(const SparseBlockMatrix<MatrixType>& A, bool onlyValues) {
-    if (onlyValues) {
-      this->_ccsMatrix->fillCCS(_sparseMatrix.valuePtr(), true);
-      return;
-    }
-    this->initMatrixStructure(A);
-    _sparseMatrix.resizeNonZeros(A.nonZeros());
-    int nz = this->_ccsMatrix->fillCCS(_sparseMatrix.outerIndexPtr(), _sparseMatrix.innerIndexPtr(),
-                                       _sparseMatrix.valuePtr(), true);
-    (void)nz;
-    assert(nz <= static_cast<int>(_sparseMatrix.data().size()));
-  }
-
-  /**
-   * Implementation of the general parts for computing the inverse blocks of the linear system
-   * matrix. Here we call a function to do the underlying computation.
-   */
-  bool solveBlocks_impl(const SparseBlockMatrix<MatrixType>& A,
-                        std::function<void(MarginalCovarianceCholesky&)> compute) {
-    // compute the cholesky factor
-    double t;
-    bool cholState = computeCholesky(A, t);
-    if (!cholState) return false;
-    // compute the inverse blocks
-    MarginalCovarianceCholesky mcc;
-    mcc.setCholeskyFactor(_cholesky.matrixL().rows(),
-                          const_cast<int*>(_cholesky.matrixL().nestedExpression().outerIndexPtr()),
-                          const_cast<int*>(_cholesky.matrixL().nestedExpression().innerIndexPtr()),
-                          const_cast<number_t*>(_cholesky.matrixL().nestedExpression().valuePtr()),
-                          const_cast<int*>(_cholesky.permutationP().indices().data()));
-    compute(mcc);  // call the desired computation on the mcc object
-    // book keeping statistics
-    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-    if (globalStats) {
-      globalStats->choleskyNNZ = _cholesky.matrixL().nestedExpression().nonZeros();
-    }
-    return true;
-  }
-};
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/solvers/eigen/solver_eigen.cpp b/g2o/solvers/eigen/solver_eigen.cpp
deleted file mode 100644
index 6be9be56..00000000
--- a/g2o/solvers/eigen/solver_eigen.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "g2o/core/block_solver.h"
-#include "g2o/core/optimization_algorithm_dogleg.h"
-#include "g2o/core/optimization_algorithm_factory.h"
-#include "g2o/core/optimization_algorithm_gauss_newton.h"
-#include "g2o/core/optimization_algorithm_levenberg.h"
-#include "g2o/core/solver.h"
-#include "g2o/core/sparse_optimizer.h"
-#include "g2o/stuff/macros.h"
-#include "linear_solver_eigen.h"
-
-using namespace std;
-
-namespace g2o {
-
-namespace {
-template <int p, int l, bool blockorder>
-std::unique_ptr<BlockSolverBase> AllocateSolver() {
-  std::cerr << "# Using EigenSparseCholesky poseDim " << p << " landMarkDim " << l
-            << " blockordering " << blockorder << std::endl;
-  auto linearSolver =
-      g2o::make_unique<LinearSolverEigen<typename BlockSolverPL<p, l>::PoseMatrixType>>();
-  linearSolver->setBlockOrdering(blockorder);
-  return g2o::make_unique<BlockSolverPL<p, l>>(std::move(linearSolver));
-}
-}  // namespace
-
-/**
- * helper function for allocating
- */
-static OptimizationAlgorithm* createSolver(const std::string& fullSolverName) {
-  static const std::map<std::string, std::function<std::unique_ptr<BlockSolverBase>()>>
-      solver_factories{
-          {"var", &AllocateSolver<-1, -1, true>},
-          {"fix3_2", &AllocateSolver<3, 2, true>},
-          {"fix6_3", &AllocateSolver<6, 3, true>},
-          {"fix7_3", &AllocateSolver<7, 3, true>},
-          {"fix3_2_scalar", &AllocateSolver<3, 2, false>},
-          {"fix6_3_scalar", &AllocateSolver<6, 3, false>},
-          {"fix7_3_scalar", &AllocateSolver<7, 3, false>},
-      };
-
-  string solverName = fullSolverName.substr(3);
-  auto solverf = solver_factories.find(solverName);
-  if (solverf == solver_factories.end()) return nullptr;
-
-  string methodName = fullSolverName.substr(0, 2);
-
-  if (methodName == "gn") {
-    return new OptimizationAlgorithmGaussNewton(solverf->second());
-  } else if (methodName == "lm") {
-    return new OptimizationAlgorithmLevenberg(solverf->second());
-  } else if (methodName == "dl") {
-    return new OptimizationAlgorithmDogleg(solverf->second());
-  }
-
-  return nullptr;
-}
-
-class EigenSolverCreator : public AbstractOptimizationAlgorithmCreator {
- public:
-  explicit EigenSolverCreator(const OptimizationAlgorithmProperty& p)
-      : AbstractOptimizationAlgorithmCreator(p) {}
-  virtual OptimizationAlgorithm* construct() { return createSolver(property().name); }
-};
-
-// clang-format off
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(eigen);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_var, new EigenSolverCreator(OptimizationAlgorithmProperty("gn_var", "Gauss-Newton: Cholesky solver using Eigen's Sparse Cholesky methods (variable blocksize)", "Eigen", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix3_2, new EigenSolverCreator(OptimizationAlgorithmProperty("gn_fix3_2", "Gauss-Newton: Cholesky solver using  Eigen's Sparse Cholesky (fixed blocksize)", "Eigen", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix6_3, new EigenSolverCreator(OptimizationAlgorithmProperty("gn_fix6_3", "Gauss-Newton: Cholesky solver using  Eigen's Sparse Cholesky (fixed blocksize)", "Eigen", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_fix7_3, new EigenSolverCreator(OptimizationAlgorithmProperty("gn_fix7_3", "Gauss-Newton: Cholesky solver using  Eigen's Sparse Cholesky (fixed blocksize)", "Eigen", true, 7, 3)));
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_var, new EigenSolverCreator(OptimizationAlgorithmProperty("lm_var", "Levenberg: Cholesky solver using Eigen's Sparse Cholesky methods (variable blocksize)", "Eigen", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix3_2, new EigenSolverCreator(OptimizationAlgorithmProperty("lm_fix3_2", "Levenberg: Cholesky solver using  Eigen's Sparse Cholesky (fixed blocksize)", "Eigen", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix6_3, new EigenSolverCreator(OptimizationAlgorithmProperty("lm_fix6_3", "Levenberg: Cholesky solver using  Eigen's Sparse Cholesky (fixed blocksize)", "Eigen", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_fix7_3, new EigenSolverCreator(OptimizationAlgorithmProperty("lm_fix7_3", "Levenberg: Cholesky solver using  Eigen's Sparse Cholesky (fixed blocksize)", "Eigen", true, 7, 3)));
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(dl_var, new EigenSolverCreator(OptimizationAlgorithmProperty("dl_var", "Dogleg: Cholesky solver using Eigen's Sparse Cholesky methods (variable blocksize)", "Eigen", false, Eigen::Dynamic, Eigen::Dynamic)));
-// clang-format on
-}  // namespace g2o
diff --git a/g2o/solvers/pcg/CMakeLists.txt b/g2o/solvers/pcg/CMakeLists.txt
deleted file mode 100644
index 46d16479..00000000
--- a/g2o/solvers/pcg/CMakeLists.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-add_library(solver_pcg ${G2O_LIB_TYPE}
-  solver_pcg.cpp
-  linear_solver_pcg.h  
-  linear_solver_pcg.hpp
-)
-
-set_target_properties(solver_pcg PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_pcg)
-if (APPLE)
-  set_target_properties(solver_pcg PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-target_link_libraries(solver_pcg core)
-
-target_include_directories(solver_pcg PUBLIC
-  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-  $<INSTALL_INTERFACE:include/g2o/solvers/pcg>)
-
-install(TARGETS solver_pcg
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/pcg)
diff --git a/g2o/solvers/pcg/linear_solver_pcg.h b/g2o/solvers/pcg/linear_solver_pcg.h
deleted file mode 100644
index a842b32f..00000000
--- a/g2o/solvers/pcg/linear_solver_pcg.h
+++ /dev/null
@@ -1,108 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINEAR_SOLVER_PCG_H
-#define G2O_LINEAR_SOLVER_PCG_H
-
-#include "g2o/core/linear_solver.h"
-#include "g2o/core/batch_stats.h"
-
-#include <vector>
-#include <utility>
-#include<Eigen/Core>
-
-namespace g2o {
-
-  /**
-   * \brief linear solver using PCG, pre-conditioner is block Jacobi
-   */
-  template <typename MatrixType>
-  class LinearSolverPCG : public LinearSolver<MatrixType>
-  {
-    public:
-      LinearSolverPCG() :
-      LinearSolver<MatrixType>()
-      {
-        _tolerance = cst(1e-6);
-        _verbose = false;
-        _absoluteTolerance = true;
-        _residual = -1.0;
-        _maxIter = -1;
-      }
-
-      virtual ~LinearSolverPCG()
-      {
-      }
-
-      virtual bool init()
-      {
-        _residual = -1.0;
-        _indices.clear();
-        _sparseMat.clear();
-        return true;
-      }
-
-      bool solve(const SparseBlockMatrix<MatrixType>& A, number_t* x, number_t* b);
-
-      //! return the tolerance for terminating PCG before convergence
-      number_t tolerance() const { return _tolerance;}
-      void setTolerance(number_t tolerance) { _tolerance = tolerance;}
-
-      int maxIterations() const { return _maxIter;}
-      void setMaxIterations(int maxIter) { _maxIter = maxIter;}
-
-      bool absoluteTolerance() const { return _absoluteTolerance;}
-      void setAbsoluteTolerance(bool absoluteTolerance) { _absoluteTolerance = absoluteTolerance;}
-
-      bool verbose() const { return _verbose;}
-      void setVerbose(bool verbose) { _verbose = verbose;}
-
-    protected:
-      typedef std::vector< MatrixType, Eigen::aligned_allocator<MatrixType> > MatrixVector;
-      typedef std::vector< const MatrixType* > MatrixPtrVector;
-
-      number_t _tolerance;
-      number_t _residual;
-      bool _absoluteTolerance;
-      bool _verbose;
-      int _maxIter;
-
-      MatrixPtrVector _diag;
-      MatrixVector _J;
-
-      std::vector<std::pair<int, int> > _indices;
-      MatrixPtrVector _sparseMat;
-
-      void multDiag(const std::vector<int>& colBlockIndices, MatrixVector& A, const VectorX& src, VectorX& dest);
-      void multDiag(const std::vector<int>& colBlockIndices, MatrixPtrVector& A, const VectorX& src, VectorX& dest);
-      void mult(const std::vector<int>& colBlockIndices, const VectorX& src, VectorX& dest);
-  };
-
-#include "linear_solver_pcg.hpp"
-
-}// end namespace
-
-#endif
diff --git a/g2o/solvers/pcg/linear_solver_pcg.hpp b/g2o/solvers/pcg/linear_solver_pcg.hpp
deleted file mode 100644
index 165ccaaa..00000000
--- a/g2o/solvers/pcg/linear_solver_pcg.hpp
+++ /dev/null
@@ -1,197 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// helpers for doing fixed or variable size operations on the matrices
-
-namespace internal {
-
-#ifdef _MSC_VER
-  // MSVC does not like the template specialization, seems like MSVC applies type conversion
-  // which results in calling a fixed size method (segment<int>) on the dynamically sized matrices
-  template<typename MatrixType>
-  void pcg_axy(const MatrixType& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment(yoff, A.rows()) = A * x.segment(xoff, A.cols());
-  }
-#else
-  template<typename MatrixType>
-  inline void pcg_axy(const MatrixType& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment<MatrixType::RowsAtCompileTime>(yoff) = A * x.segment<MatrixType::ColsAtCompileTime>(xoff);
-  }
-  
-  template<>
-  inline void pcg_axy(const MatrixX& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment(yoff, A.rows()) = A * x.segment(xoff, A.cols());
-  }
-#endif
-
-  template<typename MatrixType>
-  inline void pcg_axpy(const MatrixType& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment<MatrixType::RowsAtCompileTime>(yoff) += A * x.segment<MatrixType::ColsAtCompileTime>(xoff);
-  }
-
-  template<>
-  inline void pcg_axpy(const MatrixX& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment(yoff, A.rows()) += A * x.segment(xoff, A.cols());
-  }
-
-  template<typename MatrixType>
-  inline void pcg_atxpy(const MatrixType& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment<MatrixType::ColsAtCompileTime>(yoff) += A.transpose() * x.segment<MatrixType::RowsAtCompileTime>(xoff);
-  }
-
-  template<>
-  inline void pcg_atxpy(const MatrixX& A, const VectorX& x, int xoff, VectorX& y, int yoff)
-  {
-    y.segment(yoff, A.cols()) += A.transpose() * x.segment(xoff, A.rows());
-  }
-}
-// helpers end
-
-template <typename MatrixType>
-bool LinearSolverPCG<MatrixType>::solve(const SparseBlockMatrix<MatrixType>& A, number_t* x, number_t* b)
-{
-  const bool indexRequired = _indices.size() == 0;
-  _diag.clear();
-  _J.clear();
-
-  // put the block matrix once in a linear structure, makes mult faster
-  int colIdx = 0;
-  for (size_t i = 0; i < A.blockCols().size(); ++i){
-    const typename SparseBlockMatrix<MatrixType>::IntBlockMap& col = A.blockCols()[i];
-    if (col.size() > 0) {
-      typename SparseBlockMatrix<MatrixType>::IntBlockMap::const_iterator it;
-      for (it = col.begin(); it != col.end(); ++it) {
-        if (it->first == (int)i) { // only the upper triangular block is needed
-          _diag.push_back(it->second);
-          _J.push_back(it->second->inverse());
-          break;
-        }
-        if (indexRequired) {
-          _indices.push_back(std::make_pair(it->first > 0 ? A.rowBlockIndices()[it->first-1] : 0, colIdx));
-          _sparseMat.push_back(it->second);
-        }
-
-      }
-    }
-    colIdx = A.colBlockIndices()[i];
-  }
-
-  int n = A.rows();
-  assert(n > 0 && "Hessian has 0 rows/cols");
-  Eigen::Map<VectorX> xvec(x, A.cols());
-  const Eigen::Map<VectorX> bvec(b, n);
-  xvec.setZero();
-
-  VectorX r, d, q, s;
-  d.setZero(n);
-  q.setZero(n);
-  s.setZero(n);
-
-  r = bvec;
-  multDiag(A.colBlockIndices(), _J, r, d);
-  number_t dn = r.dot(d);
-  number_t d0 = _tolerance * dn;
-
-  if (_absoluteTolerance) {
-    if (_residual > 0.0 && _residual > d0)
-      d0 = _residual;
-  }
-
-  int maxIter = _maxIter < 0 ? A.rows() : _maxIter;
-
-  int iteration;
-  for (iteration = 0; iteration < maxIter; ++iteration) {
-    if (_verbose)
-      std::cerr << "residual[" << iteration << "]: " << dn << std::endl;
-    if (dn <= d0)
-      break;  // done
-    mult(A.colBlockIndices(), d, q);
-    number_t a = dn / d.dot(q);
-    xvec += a*d;
-    // TODO: reset residual here every 50 iterations
-    r -= a*q;
-    multDiag(A.colBlockIndices(), _J, r, s);
-    number_t dold = dn;
-    dn = r.dot(s);
-    number_t ba = dn / dold;
-    d = s + ba*d;
-  }
-  //std::cerr << "residual[" << iteration << "]: " << dn << std::endl;
-  _residual = 0.5 * dn;
-  G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();
-  if (globalStats) {
-    globalStats->iterationsLinearSolver = iteration;
-  }
-
-  return true;
-}
-
-template <typename MatrixType>
-void LinearSolverPCG<MatrixType>::multDiag(const std::vector<int>& colBlockIndices, MatrixVector& A, const VectorX& src, VectorX& dest)
-{
-  int row = 0;
-  for (size_t i = 0; i < A.size(); ++i) {
-    internal::pcg_axy(A[i], src, row, dest, row);
-    row = colBlockIndices[i];
-  }
-}
-
-template <typename MatrixType>
-void LinearSolverPCG<MatrixType>::multDiag(const std::vector<int>& colBlockIndices, MatrixPtrVector& A, const VectorX& src, VectorX& dest)
-{
-  int row = 0;
-  for (size_t i = 0; i < A.size(); ++i) {
-    internal::pcg_axy(*A[i], src, row, dest, row);
-    row = colBlockIndices[i];
-  }
-}
-
-template <typename MatrixType>
-void LinearSolverPCG<MatrixType>::mult(const std::vector<int>& colBlockIndices, const VectorX& src, VectorX& dest)
-{
-  // first multiply with the diagonal
-  multDiag(colBlockIndices, _diag, src, dest);
-
-  // now multiply with the upper triangular block
-  for (size_t i = 0; i < _sparseMat.size(); ++i) {
-    const int& srcOffset = _indices[i].second;
-    const int& destOffsetT = srcOffset;
-    const int& destOffset = _indices[i].first;
-    const int& srcOffsetT = destOffset;
-
-    const typename SparseBlockMatrix<MatrixType>::SparseMatrixBlock* a = _sparseMat[i];
-    // destVec += *a * srcVec (according to the sub-vector parts)
-    internal::pcg_axpy(*a, src, srcOffset, dest, destOffset);
-    // destVec += *a.transpose() * srcVec (according to the sub-vector parts)
-    internal::pcg_atxpy(*a, src, srcOffsetT, dest, destOffsetT);
-  }
-}
diff --git a/g2o/solvers/pcg/solver_pcg.cpp b/g2o/solvers/pcg/solver_pcg.cpp
deleted file mode 100644
index a0297478..00000000
--- a/g2o/solvers/pcg/solver_pcg.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "linear_solver_pcg.h"
-
-#include "g2o/core/block_solver.h"
-#include "g2o/core/solver.h"
-#include "g2o/core/optimization_algorithm_factory.h"
-#include "g2o/stuff/macros.h"
-
-#include "g2o/core/optimization_algorithm_gauss_newton.h"
-#include "g2o/core/optimization_algorithm_levenberg.h"
-
-using namespace std;
-
-namespace g2o
-{
-  namespace
-  {
-    template<int p, int l>
-    std::unique_ptr<g2o::Solver> AllocateSolver()
-    {
-      std::cerr << "# Using PCG poseDim " << p << " landMarkDim " << l << std::endl;
-
-      return g2o::make_unique<BlockSolverPL<p, l>>(
-        g2o::make_unique<LinearSolverPCG<typename BlockSolverPL<p, l>::PoseMatrixType>>());
-    }
-  }
-
-  static OptimizationAlgorithm* createSolver(const std::string& fullSolverName)
-  {
-    static const std::map<std::string, std::function<std::unique_ptr<g2o::Solver>()>> solver_factories{
-        { "pcg", &AllocateSolver<-1, -1> },
-        { "pcg3_2", &AllocateSolver<3, 2> },
-        { "pcg6_3", &AllocateSolver<6, 3> },
-        { "pcg7_3", &AllocateSolver<7, 3> },
-    };
-
-    string solverName = fullSolverName.substr(3);
-    auto solverf = solver_factories.find(solverName);
-    if (solverf == solver_factories.end())
-      return nullptr;
-
-    string methodName = fullSolverName.substr(0, 2);
-
-    if (methodName == "gn") {
-      return new OptimizationAlgorithmGaussNewton(solverf->second());
-    }
-    else if (methodName == "lm") {
-      return new OptimizationAlgorithmLevenberg(solverf->second());
-    }
-
-    return nullptr;
-  }
-
-  class PCGSolverCreator : public AbstractOptimizationAlgorithmCreator
-  {
-    public:
-      explicit PCGSolverCreator(const OptimizationAlgorithmProperty& p) : AbstractOptimizationAlgorithmCreator(p) {}
-      virtual OptimizationAlgorithm* construct()
-      {
-        return createSolver(property().name);
-      }
-  };
-
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(pcg);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_pcg, new PCGSolverCreator(OptimizationAlgorithmProperty("gn_pcg", "Gauss-Newton: PCG solver using block-Jacobi pre-conditioner (variable blocksize)", "PCG", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_pcg3_2, new PCGSolverCreator(OptimizationAlgorithmProperty("gn_pcg3_2", "Gauss-Newton: PCG solver using block-Jacobi pre-conditioner (fixed blocksize)", "PCG", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_pcg6_3, new PCGSolverCreator(OptimizationAlgorithmProperty("gn_pcg6_3", "Gauss-Newton: PCG solver using block-Jacobi pre-conditioner (fixed blocksize)", "PCG", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(gn_pcg7_3, new PCGSolverCreator(OptimizationAlgorithmProperty("gn_pcg7_3", "Gauss-Newton: PCG solver using block-Jacobi pre-conditioner (fixed blocksize)", "PCG", true, 7, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_pcg, new PCGSolverCreator(OptimizationAlgorithmProperty("lm_pcg", "Levenberg: PCG solver using block-Jacobi pre-conditioner (variable blocksize)", "PCG", false, Eigen::Dynamic, Eigen::Dynamic)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_pcg3_2, new PCGSolverCreator(OptimizationAlgorithmProperty("lm_pcg3_2", "Levenberg: PCG solver using block-Jacobi pre-conditioner (fixed blocksize)", "PCG", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_pcg6_3, new PCGSolverCreator(OptimizationAlgorithmProperty("lm_pcg6_3", "Levenberg: PCG solver using block-Jacobi pre-conditioner (fixed blocksize)", "PCG", true, 6, 3)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(lm_pcg7_3, new PCGSolverCreator(OptimizationAlgorithmProperty("lm_pcg7_3", "Levenberg: PCG solver using block-Jacobi pre-conditioner (fixed blocksize)", "PCG", true, 7, 3)));
-}
diff --git a/g2o/solvers/slam2d_linear/CMakeLists.txt b/g2o/solvers/slam2d_linear/CMakeLists.txt
deleted file mode 100644
index 9d7b1952..00000000
--- a/g2o/solvers/slam2d_linear/CMakeLists.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-if(NOT G2O_USE_CSPARSE)
-  return()
-endif()
-
-add_library(solver_slam2d_linear ${G2O_LIB_TYPE}
-  slam2d_linear.cpp
-  solver_slam2d_linear.h solver_slam2d_linear.cpp
-  g2o_slam2d_linear_api.h
-)
-
-set_target_properties(solver_slam2d_linear PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_slam2d_linear)
-if (APPLE)
-  set_target_properties(solver_slam2d_linear PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-target_link_libraries(solver_slam2d_linear solver_eigen types_slam2d)
-
-install(TARGETS solver_slam2d_linear
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/slam2d_linear)
diff --git a/g2o/solvers/slam2d_linear/g2o_slam2d_linear_api.h b/g2o/solvers/slam2d_linear/g2o_slam2d_linear_api.h
deleted file mode 100644
index 6bbefaeb..00000000
--- a/g2o/solvers/slam2d_linear/g2o_slam2d_linear_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_SLAM2D_LINEAR_API_H
-#define G2O_SLAM2D_LINEAR_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef solver_slam2d_linear_EXPORTS
-#define G2O_SLAM2D_LINEAR_API __declspec(dllexport)
-#else
-#define G2O_SLAM2D_LINEAR_API __declspec(dllimport)
-#endif
-#else
-#define G2O_SLAM2D_LINEAR_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_SLAM2D_LINEAR_API
-#endif
-
-#endif // G2O_TYPES_SLAM2D_API_H
diff --git a/g2o/solvers/slam2d_linear/slam2d_linear.cpp b/g2o/solvers/slam2d_linear/slam2d_linear.cpp
deleted file mode 100644
index 16cb6253..00000000
--- a/g2o/solvers/slam2d_linear/slam2d_linear.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "solver_slam2d_linear.h"
-
-#include "g2o/solvers/eigen/linear_solver_eigen.h"
-
-#include "g2o/core/block_solver.h"
-#include "g2o/core/solver.h"
-#include "g2o/core/optimization_algorithm_factory.h"
-#include "g2o/core/sparse_optimizer.h"
-#include "g2o/core/optimization_algorithm.h"
-
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  namespace
-  {
-    template<int p, int l, bool blockorder>
-    std::unique_ptr<BlockSolverBase> AllocateSolver()
-    {
-      std::cerr << "# Using CSparse poseDim " << p << " landMarkDim " << l << " blockordering " << blockorder << std::endl;
-      auto linearSolver = g2o::make_unique<LinearSolverEigen<typename BlockSolverPL<p, l>::PoseMatrixType>>();
-      linearSolver->setBlockOrdering(blockorder);
-      return g2o::make_unique<BlockSolverPL<p, l>>(std::move(linearSolver));
-    }
-  }
-
-  /**
-   * helper function for allocating
-   */
-  static OptimizationAlgorithm* createSolver(const std::string& fullSolverName)
-  {
-    if (fullSolverName != "2dlinear")
-      return nullptr;
-
-    return new SolverSLAM2DLinear{ AllocateSolver<3, 2, true>() };
-  }
-
-  class SLAM2DLinearSolverCreator : public AbstractOptimizationAlgorithmCreator
-  {
-    public:
-      explicit SLAM2DLinearSolverCreator(const OptimizationAlgorithmProperty& p) : AbstractOptimizationAlgorithmCreator(p) {}
-      virtual OptimizationAlgorithm* construct()
-      {
-        return createSolver(property().name);
-      }
-  };
-
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(slam2d_linear);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(2dlinear, new SLAM2DLinearSolverCreator(OptimizationAlgorithmProperty("2dlinear", "Solve Orientation + Gauss-Newton: Works only on 2D pose graphs!!", "Eigen", false, 3, 3)));
-
-} // end namespace
diff --git a/g2o/solvers/slam2d_linear/solver_slam2d_linear.cpp b/g2o/solvers/slam2d_linear/solver_slam2d_linear.cpp
deleted file mode 100644
index b9bd6537..00000000
--- a/g2o/solvers/slam2d_linear/solver_slam2d_linear.cpp
+++ /dev/null
@@ -1,216 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "solver_slam2d_linear.h"
-
-#include <Eigen/Core>
-
-#include "g2o/core/sparse_block_matrix.h"
-#include "g2o/core/sparse_optimizer.h"
-#include "g2o/core/hyper_dijkstra.h"
-
-#include "g2o/types/slam2d/edge_se2.h"
-
-#include "g2o/stuff/misc.h"
-#include "g2o/stuff/scoped_pointer.h"
-
-#include "g2o/solvers/eigen/linear_solver_eigen.h"
-
-#include "g2o/core/solver.h"
-
-using namespace std;
-
-namespace g2o {
-
-  /**
-   * \brief compute the initial guess of theta while travelling along the MST
-   */
-  class ThetaTreeAction : public HyperDijkstra::TreeAction
-  {
-    public:
-      explicit ThetaTreeAction(number_t* theta) : HyperDijkstra::TreeAction(), _thetaGuess(theta) {}
-      virtual number_t perform(HyperGraph::Vertex* v, HyperGraph::Vertex* vParent, HyperGraph::Edge* e)
-      {
-        if (! vParent)
-          return 0.;
-        EdgeSE2* odom    = static_cast<EdgeSE2*>(e);
-        VertexSE2* from  = static_cast<VertexSE2*>(vParent);
-        VertexSE2* to    = static_cast<VertexSE2*>(v);
-        assert(to->hessianIndex() >= 0);
-        number_t fromTheta = from->hessianIndex() < 0 ? 0. : _thetaGuess[from->hessianIndex()];
-        bool direct      = odom->vertices()[0] == from;
-        if (direct)
-          _thetaGuess[to->hessianIndex()] = fromTheta + odom->measurement().rotation().angle();
-        else
-          _thetaGuess[to->hessianIndex()] = fromTheta - odom->measurement().rotation().angle();
-        return 1.;
-      }
-    protected:
-      number_t* _thetaGuess;
-  };
-
-  SolverSLAM2DLinear::SolverSLAM2DLinear(std::unique_ptr<Solver> solver)
-    : OptimizationAlgorithmGaussNewton(std::move(solver))
-  {}
-
-  SolverSLAM2DLinear::~SolverSLAM2DLinear()
-  {}
-
-  OptimizationAlgorithm::SolverResult SolverSLAM2DLinear::solve(int iteration, bool online)
-  {
-    if (iteration == 0) {
-      bool status = solveOrientation();
-      if (! status)
-        return OptimizationAlgorithm::Fail;
-    }
-
-    return OptimizationAlgorithmGaussNewton::solve(iteration, online);
-  }
-
-  bool SolverSLAM2DLinear::solveOrientation()
-  {
-    assert(_optimizer->indexMapping().size() + 1 == _optimizer->vertices().size() && "Needs to operate on full graph");
-    assert(_optimizer->vertex(0)->fixed() && "Graph is not fixed by vertex 0");
-    VectorX b, x; // will be used for theta and x/y update
-    b.setZero(_optimizer->indexMapping().size());
-    x.setZero(_optimizer->indexMapping().size());
-
-    typedef Eigen::Matrix<number_t, 1, 1, Eigen::ColMajor> ScalarMatrix;
-
-    ScopedArray<int> blockIndeces(new int[_optimizer->indexMapping().size()]);
-    for (size_t i = 0; i < _optimizer->indexMapping().size(); ++i)
-      blockIndeces[i] = i+1;
-
-    SparseBlockMatrix<ScalarMatrix> H(blockIndeces.get(), blockIndeces.get(), _optimizer->indexMapping().size(), _optimizer->indexMapping().size());
-
-    // building the structure, diagonal for each active vertex
-    for (size_t i = 0; i < _optimizer->indexMapping().size(); ++i) {
-      OptimizableGraph::Vertex* v = _optimizer->indexMapping()[i];
-      int poseIdx = v->hessianIndex();
-      ScalarMatrix* m = H.block(poseIdx, poseIdx, true);
-      m->setZero();
-    }
-
-    HyperGraph::VertexSet fixedSet;
-
-    // off diagonal for each edge
-    for (SparseOptimizer::EdgeContainer::const_iterator it = _optimizer->activeEdges().begin(); it != _optimizer->activeEdges().end(); ++it) {
-#    ifndef NDEBUG
-      EdgeSE2* e = dynamic_cast<EdgeSE2*>(*it);
-      assert(e && "Active edges contain non-odometry edge"); //
-#    else
-      EdgeSE2* e = static_cast<EdgeSE2*>(*it);
-#    endif
-      OptimizableGraph::Vertex* from = static_cast<OptimizableGraph::Vertex*>(e->vertices()[0]);
-      OptimizableGraph::Vertex* to   = static_cast<OptimizableGraph::Vertex*>(e->vertices()[1]);
-
-      int ind1 = from->hessianIndex();
-      int ind2 = to->hessianIndex();
-      if (ind1 == -1 || ind2 == -1) {
-        if (ind1 == -1) fixedSet.insert(from); // collect the fixed vertices
-        if (ind2 == -1) fixedSet.insert(to);
-        continue;
-      }
-
-      bool transposedBlock = ind1 > ind2;
-      if (transposedBlock){ // make sure, we allocate the upper triangle block
-        std::swap(ind1, ind2);
-      }
-
-      ScalarMatrix* m = H.block(ind1, ind2, true);
-      m->setZero();
-    }
-
-    // walk along the Minimal Spanning Tree to compute the guess for the robot orientation
-    assert(fixedSet.size() == 1);
-    VertexSE2* root = static_cast<VertexSE2*>(*fixedSet.begin());
-    VectorX thetaGuess;
-    thetaGuess.setZero(_optimizer->indexMapping().size());
-    UniformCostFunction uniformCost;
-    HyperDijkstra hyperDijkstra(_optimizer);
-    hyperDijkstra.shortestPaths(root, &uniformCost);
-
-    HyperDijkstra::computeTree(hyperDijkstra.adjacencyMap());
-    ThetaTreeAction thetaTreeAction(thetaGuess.data());
-    HyperDijkstra::visitAdjacencyMap(hyperDijkstra.adjacencyMap(), &thetaTreeAction);
-
-    // construct for the orientation
-    for (SparseOptimizer::EdgeContainer::const_iterator it = _optimizer->activeEdges().begin(); it != _optimizer->activeEdges().end(); ++it) {
-      EdgeSE2* e = static_cast<EdgeSE2*>(*it);
-      VertexSE2* from = static_cast<VertexSE2*>(e->vertices()[0]);
-      VertexSE2* to   = static_cast<VertexSE2*>(e->vertices()[1]);
-
-      number_t omega = e->information()(2,2);
-
-      number_t fromThetaGuess = from->hessianIndex() < 0 ? 0. : thetaGuess[from->hessianIndex()];
-      number_t toThetaGuess   = to->hessianIndex() < 0 ? 0. : thetaGuess[to->hessianIndex()];
-      number_t error          = normalize_theta(-e->measurement().rotation().angle() + toThetaGuess - fromThetaGuess);
-
-      bool fromNotFixed = !(from->fixed());
-      bool toNotFixed   = !(to->fixed());
-
-      if (fromNotFixed || toNotFixed) {
-        number_t omega_r = - omega * error;
-        if (fromNotFixed) {
-          b(from->hessianIndex()) -= omega_r;
-          (*H.block(from->hessianIndex(), from->hessianIndex()))(0,0) += omega;
-          if (toNotFixed) {
-            if (from->hessianIndex() > to->hessianIndex())
-              (*H.block(to->hessianIndex(), from->hessianIndex()))(0,0) -= omega;
-            else
-              (*H.block(from->hessianIndex(), to->hessianIndex()))(0,0) -= omega;
-          }
-        }
-        if (toNotFixed ) {
-          b(to->hessianIndex()) += omega_r;
-          (*H.block(to->hessianIndex(), to->hessianIndex()))(0,0) += omega;
-        }
-      }
-    }
-
-    // solve orientation
-    typedef LinearSolverEigen<ScalarMatrix> SystemSolver;
-    SystemSolver linearSystemSolver;
-    linearSystemSolver.init();
-    bool ok = linearSystemSolver.solve(H, x.data(), b.data());
-    if (!ok) {
-      cerr << __PRETTY_FUNCTION__ << "Failure while solving linear system" << endl;
-      return false;
-    }
-
-    // update the orientation of the 2D poses and set translation to 0, GN shall solve that
-    root->setToOrigin();
-    for (size_t i = 0; i < _optimizer->indexMapping().size(); ++i) {
-      VertexSE2* v = static_cast<VertexSE2*>(_optimizer->indexMapping()[i]);
-      int poseIdx = v->hessianIndex();
-      SE2 poseUpdate(0, 0, normalize_theta(thetaGuess(poseIdx) + x(poseIdx)));
-      v->setEstimate(poseUpdate);
-    }
-
-    return true;
-  }
-
-} // end namespace
diff --git a/g2o/solvers/slam2d_linear/solver_slam2d_linear.h b/g2o/solvers/slam2d_linear/solver_slam2d_linear.h
deleted file mode 100644
index 3f24009c..00000000
--- a/g2o/solvers/slam2d_linear/solver_slam2d_linear.h
+++ /dev/null
@@ -1,68 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SOLVER_SLAM2D_LINEAR
-#define G2O_SOLVER_SLAM2D_LINEAR
-
-#include "g2o/core/optimization_algorithm_gauss_newton.h"
-#include "g2o_slam2d_linear_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief Implementation of a linear approximation for 2D pose graph SLAM
-   *
-   * Needs to operate on the full graph, whereas the nodes connected by
-   * odometry are 0 -> 1 -> 2 -> ...
-   * Furthermore excactly one node should be the fixed vertex.
-   * Within the first iteration the orientation of the nodes is computed. In
-   * the subsequent iterations full non-linear GN is carried out.
-   * The linear approximation is correct, if the covariance of the constraints
-   * is a diagonal matrix.
-   *
-   * More or less the solver is an implementation of the approach described
-   * by Carlone et al, RSS'11.
-   */
-  class G2O_SLAM2D_LINEAR_API SolverSLAM2DLinear : public OptimizationAlgorithmGaussNewton
-  {
-    public:
-      /**
-       * Construct a Solver for solving 2D pose graphs. Within the first iteration
-       * the rotations are solved and afterwards standard non-linear Gauss Newton
-       * is carried out.
-       */
-      explicit SolverSLAM2DLinear(std::unique_ptr<Solver> solver);
-      virtual ~SolverSLAM2DLinear();
-
-      virtual OptimizationAlgorithm::SolverResult solve(int iteration, bool online = false);
-
-    protected:
-      bool solveOrientation();
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/solvers/structure_only/CMakeLists.txt b/g2o/solvers/structure_only/CMakeLists.txt
deleted file mode 100644
index 7def495c..00000000
--- a/g2o/solvers/structure_only/CMakeLists.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-add_library(solver_structure_only ${G2O_LIB_TYPE}
-  structure_only.cpp
-  structure_only_solver.h
-)
-
-set_target_properties(solver_structure_only PROPERTIES OUTPUT_NAME ${LIB_PREFIX}solver_structure_only)
-if (APPLE)
-  set_target_properties(solver_structure_only PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-target_link_libraries(solver_structure_only core)
-
-install(TARGETS solver_structure_only
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/solvers/structure_only)
diff --git a/g2o/solvers/structure_only/structure_only.cpp b/g2o/solvers/structure_only/structure_only.cpp
deleted file mode 100644
index b64f500a..00000000
--- a/g2o/solvers/structure_only/structure_only.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "structure_only_solver.h"
-
-#include "g2o/core/optimization_algorithm_factory.h"
-#include "g2o/core/optimization_algorithm.h"
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  /**
-   * helper function for allocating
-   */
-  static OptimizationAlgorithm* createSolver(const std::string& fullSolverName)
-  {
-    if (fullSolverName == "structure_only_2") {
-      OptimizationAlgorithm* optimizationAlgo = new StructureOnlySolver<2>;
-      return optimizationAlgo;
-    }
-    else if (fullSolverName == "structure_only_3") {
-      OptimizationAlgorithm* optimizationAlgo = new StructureOnlySolver<3>;
-      return optimizationAlgo;
-    }
-    else
-      return nullptr;
-  }
-
-  class StructureOnlyCreator : public AbstractOptimizationAlgorithmCreator {
-   public:
-    explicit StructureOnlyCreator(const OptimizationAlgorithmProperty& p) : AbstractOptimizationAlgorithmCreator(p) {}
-    virtual OptimizationAlgorithm* construct() { return createSolver(property().name); }
-  };
-
-  G2O_REGISTER_OPTIMIZATION_LIBRARY(structure_only);
-
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(structure_only_2, new StructureOnlyCreator(OptimizationAlgorithmProperty("structure_only_2", "Optimize the landmark poses (2D)", "Eigen", true, 3, 2)));
-  G2O_REGISTER_OPTIMIZATION_ALGORITHM(structure_only_3, new StructureOnlyCreator(OptimizationAlgorithmProperty("structure_only_3", "Optimize the landmark poses (3D)", "Eigen", true, 6, 3)));
-
-} // end namespace
diff --git a/g2o/solvers/structure_only/structure_only_solver.h b/g2o/solvers/structure_only/structure_only_solver.h
deleted file mode 100644
index 11ef9b7c..00000000
--- a/g2o/solvers/structure_only/structure_only_solver.h
+++ /dev/null
@@ -1,242 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// Copyright (C) 2012 R. Kuemmerle
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_STRUCTURE_ONLY_SOLVER_H
-#define G2O_STRUCTURE_ONLY_SOLVER_H
-
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/core/optimization_algorithm.h"
-#include "g2o/core/sparse_optimizer.h"
-
-namespace g2o
-{
-
-/**
- * \brief This is a solver for "structure-only" optimization"
- *
- * Given the problem of landmark-based SLAM or bundle adjustment, this class 
- * performs optimization on the landmarks while the poses are kept fixed. This 
- * can be done very efficiently, since the position on the landmarks are 
- * indepdented given the poses are known.
- *
- * This class slightly misuses the API of g2o. It is designed in a way, it can 
- * work on the very same graph which reflects the problem of landmark-based 
- * SLAM, bundle adjustment and which is meant to be solved using the Schur 
- * complement. Thus, it can be called just before or after joint-optimization 
- * without the need of additional setup. Call calc() with the point features you
- * want to optimize.
- *
- * This class is still considered as being experimentally!
- */
-template <int PointDoF>
-class StructureOnlySolver : public OptimizationAlgorithm
-{
-  public:
-    StructureOnlySolver()
-    {
-      _verbose = true;
-    }
-
-    virtual OptimizationAlgorithm::SolverResult solve(int iteration, bool online = false)
-    {
-      (void) iteration;
-      (void) online;
-      return calc(_points, 1);
-    }
-
-    OptimizationAlgorithm::SolverResult calc(OptimizableGraph::VertexContainer& vertices, int num_iters, int num_max_trials=10)
-    {
-      JacobianWorkspace auxWorkspace;
-      auxWorkspace.updateSize(2, 50);
-      auxWorkspace.allocate();
-
-      for (OptimizableGraph::VertexContainer::iterator it_v=vertices.begin(); it_v!=vertices.end(); ++it_v) {
-        bool stop = false;
-        g2o::OptimizableGraph::Vertex* v = dynamic_cast<OptimizableGraph::Vertex*>(*it_v);
-        assert(v->dimension() == PointDoF);
-        g2o::HyperGraph::EdgeSet& track = v->edges();
-        assert(track.size()>=2);
-        number_t chi2 = 0;
-        // TODO make these parameters
-        number_t mu = cst(0.01);
-        number_t nu = 2;
-
-        for (g2o::HyperGraph::EdgeSet::iterator it_t=track.begin(); it_t!=track.end(); ++it_t) {
-          g2o::OptimizableGraph::Edge* e = dynamic_cast<g2o::OptimizableGraph::Edge *>(*it_t);
-          e->computeError();
-          if (e->robustKernel())
-          {
-            Vector3 rho;
-            e->robustKernel()->robustify(e->chi2(), rho);
-            chi2 += rho[0];
-          }
-          else
-          {
-            chi2 += e->chi2();
-          }
-        }
-
-        if (v->fixed() == false) {
-          Eigen::Matrix<number_t, PointDoF, PointDoF, Eigen::ColMajor> H_pp;
-          H_pp.resize(v->dimension(), v->dimension());
-          v->mapHessianMemory(H_pp.data());
-          for (int i_g = 0; i_g < num_iters; ++i_g) {
-            H_pp.setZero();
-            v->clearQuadraticForm();
-
-            g2o::HyperGraph::EdgeSet& track = v->edges();
-            assert(track.size()>=1);
-
-            for (g2o::HyperGraph::EdgeSet::iterator it_t=track.begin(); it_t!=track.end(); ++it_t) {
-              g2o::OptimizableGraph::Edge* e = dynamic_cast<g2o::OptimizableGraph::Edge *>(*it_t);
-
-              // fix all the other vertices and remember their fix value
-#ifdef WINDOWS
-              std::vector<bool> remember_fix_status(e->vertices().size());
-#else
-              bool remember_fix_status[e->vertices().size()];
-#endif
-              for (size_t k = 0; k < e->vertices().size(); ++k) {
-                OptimizableGraph::Vertex* otherV = static_cast<OptimizableGraph::Vertex*>(e->vertex(k));
-                if (otherV != v) {
-                  remember_fix_status[k] = otherV->fixed();
-                  otherV->setFixed(true);
-                }
-              }
-
-              // build the matrix
-              e->computeError();
-              e->linearizeOplus(auxWorkspace);
-              e->constructQuadraticForm();
-
-              // Restore frame's initial fixed() values
-              for (size_t k = 0; k < e->vertices().size(); ++k) {
-                OptimizableGraph::Vertex* otherV = static_cast<g2o::OptimizableGraph::Vertex*>(e->vertex(k));
-                if (otherV != v) {
-                  otherV->setFixed(remember_fix_status[k]);
-                }
-              }
-            }
-
-            Eigen::Map<Eigen::Matrix<number_t,PointDoF,1,Eigen::ColMajor> > b(v->bData(), v->dimension());
-
-            if (b.norm()<0.001) {
-              stop = true;
-              break;
-            }
-
-            int trial=0;
-            do {
-              Eigen::Matrix<number_t,PointDoF,PointDoF,Eigen::ColMajor> H_pp_mu = H_pp;
-              H_pp_mu.diagonal().array() += mu;
-              Eigen::LDLT<Eigen::Matrix<number_t,PointDoF,PointDoF,Eigen::ColMajor> > chol_H_pp(H_pp_mu);
-              bool goodStep = false;
-              if (chol_H_pp.isPositive()) {
-                Eigen::Matrix<number_t,PointDoF,1,Eigen::ColMajor> delta_p = chol_H_pp.solve(b);
-                v->push();
-                v->oplus(delta_p.data());
-                number_t new_chi2 = 0;
-                for (g2o::HyperGraph::EdgeSet::iterator it_t=track.begin(); it_t!=track.end(); ++it_t) {
-                  g2o::OptimizableGraph::Edge* e = dynamic_cast<g2o::OptimizableGraph::Edge *>(*it_t);
-                  e->computeError();
-                  if (e->robustKernel())
-                  {
-                    Vector3 rho;
-                    e->robustKernel()->robustify(e->chi2(), rho);
-                    new_chi2 += rho[0];
-                  }
-                  else
-                  {
-                    new_chi2 += e->chi2();
-                  }
-                }
-                assert(g2o_isnan(new_chi2)==false && "Chi is NaN");
-                number_t rho = (chi2 - new_chi2);
-                if (rho > 0 && g2o_isfinite(new_chi2)) {
-                  goodStep = true;
-                  chi2 = new_chi2;
-                  v->discardTop();
-                } else {
-                  goodStep = false;
-                  v->pop();
-                }
-              }
-
-              // update the damping factor based on the result of the last increment
-              if (goodStep) {
-                mu *= cst(1./3.);
-                nu = 2.;
-                trial=0;
-                break;
-              } else {
-                mu *= nu;
-                nu *= 2.;
-                ++trial;
-                if (trial >= num_max_trials) {
-                  stop=true;
-                  break;
-                }
-              }
-            } while(!stop);
-            if (stop)
-              break;
-          }
-        }
-      }
-      return OK;
-    }
-
-    virtual bool init(bool )
-    { 
-      // collect the vertices
-      _points.clear();
-      for (OptimizableGraph::VertexContainer::const_iterator it =  optimizer()->activeVertices().begin(); it != optimizer()->activeVertices().end(); ++it) {
-        OptimizableGraph::Vertex* v = *it;
-        if (v->marginalized()) {
-          _points.push_back(v);
-        }
-      }
-      return true;
-    }
-
-    virtual bool computeMarginals(SparseBlockMatrix<MatrixX>&, const std::vector<std::pair<int, int> >&) { return false;}
-
-    virtual bool updateStructure(const std::vector<HyperGraph::Vertex*>& , const HyperGraph::EdgeSet& ) { return true;}
-
-    //! return the points of the optimization problem
-    OptimizableGraph::VertexContainer& points() { return _points;}
-    const OptimizableGraph::VertexContainer& points() const { return _points;}
-
-  protected:
-    bool _verbose;
-    OptimizableGraph::VertexContainer _points;
-};
-
-}
-
-#endif
diff --git a/g2o/stuff/CMakeLists.txt b/g2o/stuff/CMakeLists.txt
deleted file mode 100644
index 1698ed4b..00000000
--- a/g2o/stuff/CMakeLists.txt
+++ /dev/null
@@ -1,54 +0,0 @@
-add_library(stuff ${G2O_LIB_TYPE}
-  filesys_tools.h    string_tools.h
-  color_macros.h     macros.h         timeutil.cpp
-  command_args.cpp   misc.h           sparse_helper.cpp  timeutil.h
-  command_args.h     os_specific.c    sparse_helper.h
-  filesys_tools.cpp  os_specific.h    string_tools.cpp
-  property.cpp       property.h       
-  sampler.cpp        sampler.h        unscented.h
-  tictoc.cpp tictoc.h
-  g2o_stuff_api.h
-)
-
-set_target_properties(stuff PROPERTIES OUTPUT_NAME ${LIB_PREFIX}stuff)
-target_link_libraries(stuff PUBLIC ${G2O_EIGEN3_EIGEN_TARGET})
-
-if (APPLE)
-  set_target_properties(stuff PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-install(TARGETS stuff
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-# build our OpenGL helper library
-if(OPENGL_FOUND AND G2O_HAVE_OPENGL)
-  add_library(opengl_helper ${G2O_LIB_TYPE}
-    opengl_primitives.cpp opengl_primitives.h
-    )
-  if (APPLE)
-  set_target_properties(opengl_helper PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-  install(TARGETS opengl_helper
-    EXPORT ${G2O_TARGETS_EXPORT_NAME}
-    RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-    LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-    ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-    INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-    )
-
-  target_link_libraries(opengl_helper PUBLIC ${G2O_OPENGL_TARGET} ${G2O_EIGEN3_EIGEN_TARGET})
-  set_target_properties(opengl_helper PROPERTIES OUTPUT_NAME "${LIB_PREFIX}opengl_helper")
-endif()
-
-if(${CMAKE_SYSTEM_NAME} MATCHES "Linux" AND NOT ANDROID)
-  target_link_libraries(stuff PUBLIC rt)
-endif()
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/stuff)
diff --git a/g2o/stuff/command_args.cpp b/g2o/stuff/command_args.cpp
deleted file mode 100644
index b23d775a..00000000
--- a/g2o/stuff/command_args.cpp
+++ /dev/null
@@ -1,423 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "command_args.h"
-
-#include <cstdlib>
-#include <cstring>
-#include <fstream>
-#include <algorithm>
-#include <functional>
-
-#include "misc.h"
-#include "os_specific.h"
-#include "string_tools.h"
-using namespace std;
-
-namespace g2o {
-
-namespace {
-
-template <typename T>
-void readVector(const std::string& s, const std::function<T(const char*, char**)>& parser, std::vector<T>& v) {
-  v.clear();
-
-  const char* c = s.c_str();
-  char* caux = const_cast<char*>(c);
-
-  bool hasNextValue = true;
-  while (hasNextValue) {
-    T value = parser(c, &caux);
-    if (c != caux) {
-      c = caux;
-      c++;
-      v.push_back(value);
-    } else
-      hasNextValue = false;
-  }
-}
-
-template <typename T>
-std::string writeVectorAsString(const std::vector<T>& v) {
-  std::stringstream os;
-  if (v.size()) os << v[0];
-  for (size_t i = 1; i < v.size(); i++) os << "," << v[i];
-  return os.str();
-}
-
-template <typename T>
-void parseArgument(const std::string& input, CommandArgs::CommandArgument& ca) {
-  T aux;
-  bool convertStatus = convertString(input, aux);
-  if (convertStatus) {
-    T* data = static_cast<T*>(ca.data);
-    *data = aux;
-  }
-}
-
-template <typename T>
-void parseVector(const std::string& input, CommandArgs::CommandArgument& ca, std::function<T(const char*, char**)> parser) {
-  std::vector<T> aux;
-  readVector(input, parser, aux);
-  bool convertStatus = aux.size() > 0;
-  if (convertStatus) {
-    std::vector<T>* data = static_cast<std::vector<T>*>(ca.data);
-    *data = aux;
-  }
-}
-
-template <typename T>
-std::string argument2String(const CommandArgs::CommandArgument& ca) {
-  T* data = static_cast<T*>(ca.data);
-  stringstream auxStream;
-  auxStream << *data;
-  return auxStream.str();
-}
-
-}  // namespace
-
-enum CommandArgumentType { CAT_DOUBLE, CAT_FLOAT, CAT_INT, CAT_STRING, CAT_BOOL, CAT_VECTOR_INT, CAT_VECTOR_DOUBLE };
-
-CommandArgs::~CommandArgs() {}
-
-bool CommandArgs::parseArgs(int argc, char** argv, bool exitOnError) {
-  _progName = argv[0];
-  int i;
-  for (i = 1; i < argc; i++) {
-    string name = argv[i];
-
-    if (name[0] != '-') {  // each param has to start with at least one dash
-      // cerr << "Error: expecting parameter, got " << name << endl;
-      // printHelp(cerr);
-      // if (exitOnError)
-      // exit(1);
-      // return false;
-      break;
-    }
-    /* first check whether it's -- and we should not continue parsing */
-    if (name == "--") {
-      ++i;
-      break;
-    }
-
-    string::size_type dashPos = name.find_first_not_of('-');
-    if (dashPos != string::npos) name = name.substr(dashPos);
-
-    if (name == "help" || name == "h") {
-      printHelp(cout);
-      exit(0);
-    } else {
-      // command line argument parsing
-      std::vector<CommandArgument>::iterator it = _args.begin();
-      for (; it != _args.end(); ++it) {
-        if (it->name == name) {
-          if (it->type == CAT_BOOL) {
-            if (!it->parsed) {
-              bool* data = static_cast<bool*>(it->data);
-              *data = !(*data);
-            }
-            it->parsed = true;
-          } else {
-            if (i >= argc - 1) {
-              cerr << "Argument " << name << "needs value.\n";
-              printHelp(cerr);
-              if (exitOnError) exit(1);
-              return false;
-            }
-            i++;
-            str2arg(argv[i], *it);
-            it->parsed = true;
-          }
-          break;
-        }
-      }
-      if (it == _args.end()) {
-        cerr << "Error: Unknown Option '" << name << "' (use -help to get list of options).\n";
-        if (exitOnError) exit(1);
-        return false;
-      }
-    }
-  }  // for argv[i]
-
-  if ((int)_leftOvers.size() > argc - i) {
-    cerr << "Error: program requires parameters" << endl;
-    printHelp(cerr);
-    if (exitOnError) exit(1);
-    return false;
-  }
-  for (size_t j = 0; (i < argc && j < _leftOvers.size()); i++, j++) {
-    string* s = static_cast<string*>(_leftOvers[j].data);
-    *s = argv[i];
-    _leftOvers[j].parsed = true;
-  }
-
-  // the optional leftOvers
-  for (size_t j = 0; (i < argc && j < _leftOversOptional.size()); i++, j++) {
-    string* s = static_cast<string*>(_leftOversOptional[j].data);
-    *s = argv[i];
-    _leftOversOptional[j].parsed = true;
-  }
-
-  return true;
-}
-
-void CommandArgs::param(const std::string& name, bool& p, bool defValue, const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_BOOL;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::param(const std::string& name, int& p, int defValue, const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_INT;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::param(const std::string& name, float& p, float defValue, const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_FLOAT;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::param(const std::string& name, double& p, double defValue, const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_DOUBLE;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::param(const std::string& name, std::string& p, const std::string& defValue, const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_STRING;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::param(const std::string& name, std::vector<int>& p, const std::vector<int>& defValue,
-                        const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_VECTOR_INT;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::param(const std::string& name, std::vector<double>& p, const std::vector<double>& defValue,
-                        const std::string& desc) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_VECTOR_DOUBLE;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  p = defValue;
-  _args.push_back(ca);
-}
-
-void CommandArgs::printHelp(std::ostream& os) {
-  if (_banner.size()) os << _banner << endl;
-  os << "Usage: " << _progName << (_args.size() > 0 ? " [options] " : " ");
-  if (_leftOvers.size() > 0) {
-    for (size_t i = 0; i < _leftOvers.size(); ++i) {
-      if (i > 0) os << " ";
-      os << _leftOvers[i].name;
-    }
-  }
-  if (_leftOversOptional.size() > 0) {
-    if (_leftOvers.size() > 0) os << " ";
-    for (size_t i = 0; i < _leftOversOptional.size(); ++i) {
-      if (i > 0) os << " ";
-      os << "[" << _leftOversOptional[i].name << "]";
-    }
-  }
-  os << endl << endl;
-  os << "General options:" << endl;
-  os << "-------------------------------------------" << endl;
-  os << "-help / -h           Displays this help." << endl << endl;
-  if (_args.size() > 0) {
-    os << "Program Options:" << endl;
-    os << "-------------------------------------------" << endl;
-    // build up option string to print as table
-    vector<pair<string, string> > tableStrings;
-    tableStrings.reserve(_args.size());
-    size_t maxArgLen = 0;
-    for (size_t i = 0; i < _args.size(); ++i) {
-      if (_args[i].type != CAT_BOOL) {
-        string defaultValueStr = arg2str(_args[i]);
-        if (!defaultValueStr.empty())
-          tableStrings.push_back(make_pair(_args[i].name + " " + type2str(_args[i].type),
-                                           _args[i].description + " (default: " + defaultValueStr + ")"));
-        else
-          tableStrings.push_back(make_pair(_args[i].name + " " + type2str(_args[i].type), _args[i].description));
-      } else
-        tableStrings.push_back(make_pair(_args[i].name, _args[i].description));
-      maxArgLen = (std::max)(maxArgLen, tableStrings.back().first.size());
-    }
-    sort(tableStrings.begin(), tableStrings.end(), CmpPairFirst<string, string>());
-    maxArgLen += 3;
-    for (size_t i = 0; i < tableStrings.size(); ++i) {
-      os << "-" << tableStrings[i].first;
-      for (size_t l = tableStrings[i].first.size(); l < maxArgLen; ++l) os << " ";
-      os << tableStrings[i].second << endl;
-    }
-    // TODO should output description for leftOver params?
-  }
-}
-
-void CommandArgs::setBanner(const std::string& banner) { _banner = banner; }
-
-void CommandArgs::paramLeftOver(const std::string& name, std::string& p, const std::string& defValue,
-                                const std::string& desc, bool optional) {
-  CommandArgument ca;
-  ca.name = name;
-  ca.description = desc;
-  ca.type = CAT_STRING;
-  ca.data = static_cast<void*>(&p);
-  ca.parsed = false;
-  ca.optional = optional;
-  p = defValue;
-  if (optional)
-    _leftOversOptional.push_back(ca);
-  else
-    _leftOvers.push_back(ca);
-}
-
-const char* CommandArgs::type2str(int t) const {
-  switch (t) {
-    case CAT_DOUBLE:
-      return "<double>";
-    case CAT_FLOAT:
-      return "<float>";
-    case CAT_INT:
-      return "<int>";
-    case CAT_STRING:
-      return "<string>";
-    case CAT_BOOL:
-      return "<bool>";
-    case CAT_VECTOR_INT:
-      return "<vector_int>";
-    case CAT_VECTOR_DOUBLE:
-      return "<vector_double>";
-  }
-  return "";
-}
-
-void CommandArgs::str2arg(const std::string& input, CommandArgument& ca) const {
-  switch (ca.type) {
-    case CAT_FLOAT:
-      parseArgument<float>(input, ca);
-      break;
-    case CAT_DOUBLE:
-      parseArgument<double>(input, ca);
-      break;
-    case CAT_INT:
-      parseArgument<int>(input, ca);
-      break;
-    case CAT_BOOL:
-      parseArgument<bool>(input, ca);
-      break;
-    case CAT_STRING: {
-      string* data = static_cast<string*>(ca.data);
-      *data = input;
-    } break;
-    case CAT_VECTOR_INT: {
-      std::function<int(const char*, char**)> parser = [](const char* c, char** caux) -> int {
-        return static_cast<int>(strtol(c, caux, 10));
-      };
-      parseVector(input, ca, parser);
-    } break;
-    case CAT_VECTOR_DOUBLE: {
-      std::function<double(const char*, char**)> parser = [](const char* c, char** caux) -> double {
-        return strtod(c, caux);
-      };
-      parseVector(input, ca, parser);
-    } break;
-  }
-}
-
-std::string CommandArgs::arg2str(const CommandArgument& ca) const {
-  switch (ca.type) {
-    case CAT_FLOAT:
-      return argument2String<float>(ca);
-    case CAT_DOUBLE:
-      return argument2String<double>(ca);
-    case CAT_INT:
-      return argument2String<int>(ca);
-    case CAT_BOOL:
-      return argument2String<bool>(ca);
-    case CAT_STRING: {
-      string* data = static_cast<string*>(ca.data);
-      return *data;
-    }
-    case CAT_VECTOR_INT: {
-      std::vector<int>* data = static_cast<std::vector<int>*>(ca.data);
-      return writeVectorAsString(*data);
-    }
-    case CAT_VECTOR_DOUBLE: {
-      std::vector<double>* data = static_cast<std::vector<double>*>(ca.data);
-      return writeVectorAsString(*data);
-    }
-  }
-  return "";
-}
-
-bool CommandArgs::parsedParam(const std::string& param) const {
-  std::vector<CommandArgument>::const_iterator it = _args.begin();
-  for (; it != _args.end(); ++it) {
-    if (it->name == param) {
-      return it->parsed;
-    }
-  }
-  return false;
-}
-
-}  // end namespace g2o
diff --git a/g2o/stuff/command_args.h b/g2o/stuff/command_args.h
deleted file mode 100644
index 7a764ba1..00000000
--- a/g2o/stuff/command_args.h
+++ /dev/null
@@ -1,121 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_COMMAND_ARGS_H
-#define G2O_COMMAND_ARGS_H
-
-#include <string>
-#include <vector>
-#include <iostream>
-
-#include "g2o_stuff_api.h"
-
-namespace g2o {
-
-/**
- * \brief Command line parsing of argc and argv.
- *
- * Parse the command line to get the program options. Additionally,
- * we can store the config in a file and reload a parameter set from
- * this file.
- */
-class G2O_STUFF_API CommandArgs
-{
-  public:
-    struct CommandArgument
-    {
-      std::string name;
-      std::string description;
-      int type;
-      void* data;
-      bool parsed;
-      bool optional;
-      CommandArgument() : name(""), description(""), type(0), data(0), parsed(false), optional(false)
-      {}
-    };
-  public:
-    virtual ~CommandArgs();
-
-    /**
-     * parse the command line for the requested parameters.
-     * @param argc the number of params
-     * @param argv the value array
-     * @param exitOnError call exit() if the parsing fails
-     * @return true, if parsing was correct
-     */
-    bool parseArgs(int argc, char** argv, bool exitOnError = true);
-
-    /** add a bool parameter, if found on the command line, will toggle defValue */
-    void param(const std::string& name, bool& p, bool defValue, const std::string& desc);
-    /** add a int parameter */
-    void param(const std::string& name, int& p, int defValue, const std::string& desc);
-    /** add a float parameter */
-    void param(const std::string& name, float& p, float defValue, const std::string& desc);
-    /** add a float parameter */
-    void param(const std::string& name, double& p, double defValue, const std::string& desc);
-    /** add a string parameter */
-    void param(const std::string& name, std::string& p, const std::string& defValue, const std::string& desc);
-    /** add an int vector parameter */
-    void param(const std::string& name, std::vector<int>& p, const std::vector<int>& defValue, const std::string& desc);
-    /** add an vector of doubles as a parameter */
-    void param(const std::string& name, std::vector<double>& p, const std::vector<double>& defValue, const std::string& desc);
-    /** add a param wich is specified as a plain argument */
-    void paramLeftOver(const std::string& name, std::string& p, const std::string& defValue, const std::string& desc, bool optional = false);
-
-    /**
-     * print the value of all params to an ostream
-     */
-    void printParams(std::ostream& os);
-
-    //! return the banner string
-    const std::string& getBanner() const { return _banner; }
-    void setBanner(const std::string& banner);
-
-    /**
-     * print the help
-     */
-    void printHelp(std::ostream& os);
-
-    /**
-     * returns true, if the param was parsed via the command line
-     */
-    bool parsedParam(const std::string& paramFlag) const;
-
-  protected:
-    std::vector<CommandArgument> _args;
-    std::vector<CommandArgument> _leftOvers;
-    std::vector<CommandArgument> _leftOversOptional;
-    std::string _banner;
-    std::string _progName;
-
-    const char* type2str(int t) const;
-    void str2arg(const std::string& input, CommandArgument& ca) const;
-    std::string arg2str(const CommandArgument& ca) const;
-};
-
-} // end namespace
-
-#endif
diff --git a/g2o/stuff/filesys_tools.cpp b/g2o/stuff/filesys_tools.cpp
deleted file mode 100644
index 29e33fd0..00000000
--- a/g2o/stuff/filesys_tools.cpp
+++ /dev/null
@@ -1,164 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *            filesysTools.cpp
- *
- *  Fr 02 Mr 2007 23:14:08 CET
- *  Copyright 2007 Rainer Kmmerle
- *  Email rk@raikue.net
- ****************************************************************************/
-#include "filesys_tools.h"
-
-#include <sys/stat.h>
-#include <ctime>
-#include <sys/types.h>
-#include <cstdio>
-#include <iostream>
-
-#ifdef WINDOWS
-#include <windows.h>
-#include <winbase.h>
-#endif
-
-#if (defined (UNIX) || defined(CYGWIN)) && !defined(ANDROID)
-#include <wordexp.h>
-#endif
-
-#ifdef __APPLE__
-//#include <chrono>
-//#include <thread>
-#endif
-
-using namespace ::std;
-
-namespace g2o {
-
-std::string getFileExtension(const std::string& filename)
-{
-  std::string::size_type lastDot = filename.find_last_of('.');
-  if (lastDot != std::string::npos)
-    return filename.substr(lastDot + 1);
-  else
-    return "";
-}
-
-std::string getPureFilename(const std::string& filename)
-{
-  std::string::size_type lastDot = filename.find_last_of('.');
-  if (lastDot != std::string::npos)
-    return filename.substr(0, lastDot);
-  else
-    return filename;
-}
-
-std::string getBasename(const std::string& filename)
-{
-#ifdef WINDOWS
-  std::string::size_type lastSlash = filename.find_last_of('\\');
-#else
-  std::string::size_type lastSlash = filename.find_last_of('/');
-#endif
-  if (lastSlash != std::string::npos)
-    return filename.substr(lastSlash + 1);
-  else
-    return filename;
-}
-
-std::string getDirname(const std::string& filename)
-{
-#ifdef WINDOWS
-  std::string::size_type lastSlash = filename.find_last_of('\\');
-#else
-  std::string::size_type lastSlash = filename.find_last_of('/');
-#endif
-  if (lastSlash != std::string::npos)
-    return filename.substr(0, lastSlash);
-  else
-    return "";
-}
-
-std::string changeFileExtension(const std::string& filename, const std::string& newExt, bool stripDot)
-{
-  std::string::size_type lastDot = filename.find_last_of('.');
-  if (lastDot != std::string::npos) {
-    if (stripDot)
-      return filename.substr(0, lastDot) + newExt;
-    else
-      return filename.substr(0, lastDot + 1) + newExt;
-  } else
-    return filename;
-}
-
-bool fileExists(const char* filename)
-{
-  struct stat statInfo;
-  return (stat(filename, &statInfo) == 0);
-}
-
-std::vector<std::string> getFilesByPattern(const char* pattern)
-{
-  std::vector<std::string> result;
-
-#ifdef WINDOWS
-
-  HANDLE hFind;
-  WIN32_FIND_DATA FData;
-  if ((hFind = FindFirstFile(pattern, &FData)) != INVALID_HANDLE_VALUE) {
-    do {
-      result.push_back(FData.cFileName);
-    } while (FindNextFile(hFind, &FData));
-    FindClose(hFind);
-  }
-  
-#elif (defined (UNIX) || defined (CYGWIN)) && !defined(ANDROID)
-
-  wordexp_t p;
-  wordexp(pattern, &p, 0);
-
-  // For some reason, wordexp sometimes fails on an APPLE machine to
-  // return anything; therefore, run it several times until we do find
-  // something - or give up
-#ifdef __APPLE__
-  for (int k = 0; (k < 100) && (p.we_wordc == 0); k++) {
-    //chrono::milliseconds duration(20);
-    //this_thread::sleep_for(duration);
-    wordexp(pattern, &p, WRDE_APPEND);
-  }
-#endif
-
-  result.reserve(p.we_wordc);
-  for (size_t i = 0; i < p.we_wordc; ++i)
-    result.push_back(p.we_wordv[i]);
-  
-  wordfree(&p);
-
-#endif
-
-  return result;
-}
-
-}
diff --git a/g2o/stuff/filesys_tools.h b/g2o/stuff/filesys_tools.h
deleted file mode 100644
index 718e9cfd..00000000
--- a/g2o/stuff/filesys_tools.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *            filesysTools.h
- *
- *  Fr 02 Mr 2007 23:14:21 CET
- *  Copyright 2007 Rainer Kmmerle
- *  Email rk@raikue.net
- ****************************************************************************/
-
-#ifndef G2O_FILESYS_TOOLS_H
-#define G2O_FILESYS_TOOLS_H
-
-#include "g2o_stuff_api.h"
-
-/** @addtogroup utils **/
-// @{
-
-/** \file filesysTools.h
- * \brief utility functions for handling files, directory on Linux/Unix
- */
-
-#include <string>
-#include <vector>
-
-namespace g2o {
-
-/**
- * get filename extension (the part after the last .), e.g.
- * the extension of file.txt is txt
- */
-G2O_STUFF_API std::string getFileExtension(const std::string& filename);
-
-/**
- * get the filename without the extension.
- * file.txt -> file
- */
-G2O_STUFF_API std::string getPureFilename(const std::string& filename);
-
-/**
- * change the fileextension of a given filename.
- * Only if filename contains an extension, otherwise filename is returned.
- */
-G2O_STUFF_API std::string changeFileExtension(const std::string& filename, const std::string& newExt, bool stripDot = false);
-
-/**
- * return the basename of the given filename
- * /etc/fstab -> fstab
- */
-G2O_STUFF_API std::string getBasename(const std::string& filename);
-
-/**
- * return the directory of a given filename
- * /etc/fstab -> /etc
- */
-G2O_STUFF_API std::string getDirname(const std::string& filename);
-
-/**
- * check if file exists (note a directory is also a file)
- */
-G2O_STUFF_API bool fileExists(const char* filename);
-
-/**
- * return all files that match a given pattern, e.g., ~/blaa*.txt, /tmp/a*
- */
-G2O_STUFF_API std::vector<std::string> getFilesByPattern(const char* pattern);
-
-} // end namespace
-// @}
-#endif
diff --git a/g2o/stuff/g2o_stuff_api.h b/g2o/stuff/g2o_stuff_api.h
deleted file mode 100644
index fa9c6ad1..00000000
--- a/g2o/stuff/g2o_stuff_api.h
+++ /dev/null
@@ -1,59 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_STUFF_API_H
-#define G2O_STUFF_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-
-#ifdef G2O_SHARED_LIBS
-#ifdef stuff_EXPORTS
-#define G2O_STUFF_API __declspec(dllexport)
-#else
-#define G2O_STUFF_API __declspec(dllimport)
-#endif
-#else
-#define G2O_STUFF_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_STUFF_API
-#endif
-
-#endif // G2O_STUFF_API_H
diff --git a/g2o/stuff/macros.h b/g2o/stuff/macros.h
index 32aaaa14..be4a2451 100644
--- a/g2o/stuff/macros.h
+++ b/g2o/stuff/macros.h
@@ -47,9 +47,15 @@
 #  define G2O_ATTRIBUTE_WARNING(func) func __attribute__((warning))
 #  define G2O_ATTRIBUTE_DEPRECATED(func) func __attribute__((deprecated))
 
-#  define g2o_isnan(x)     std::isnan(x)
-#  define g2o_isinf(x)     std::isinf(x)
-#  define g2o_isfinite(x)  std::isfinite(x)
+#ifdef ANDROID
+# define g2o_isnan(x)     isnan(x)
+# define g2o_isinf(x)     isinf(x)
+# define g2o_isfinite(x)  isfinite(x)
+#else
+# define g2o_isnan(x)     std::isnan(x)
+# define g2o_isinf(x)     std::isinf(x)
+# define g2o_isfinite(x)  std::isfinite(x)
+#endif
 
 // MSVC on Windows
 #elif defined _MSC_VER
diff --git a/g2o/stuff/misc.h b/g2o/stuff/misc.h
index 3b239f0f..4fa4ff33 100644
--- a/g2o/stuff/misc.h
+++ b/g2o/stuff/misc.h
@@ -28,11 +28,11 @@
 #define G2O_STUFF_MISC_H
 
 #include "macros.h"
-#include "g2o/config.h"
-
 #include <cmath>
-#include <memory>
 
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
 
 /** @addtogroup utils **/
 // @{
@@ -45,34 +45,6 @@
 
 namespace g2o {
 
-/** Helper class to sort pair based on first elem */
-template <class T1, class T2, class Pred = std::less<T1> >
-struct CmpPairFirst {
-  bool operator()(const std::pair<T1, T2>& left, const std::pair<T1, T2>& right) {
-    return Pred()(left.first, right.first);
-  }
-};
-
-/**
- * helper function for creating an object in a unique_ptr.
- */
-template<typename T, typename ...ArgTs>
-std::unique_ptr<T> make_unique(ArgTs&& ...args)
-{
-  return std::unique_ptr<T>(new T(std::forward<ArgTs>(args)...));
-};
-
-/**
-* converts a number constant to a number_t constant at compile time
-* to avoid having to cast everything to avoid warnings.
-**/
-inline constexpr number_t cst(long double v)
-{
-  return (number_t)v;
-}
-
-constexpr number_t const_pi() { return cst(3.14159265358979323846); }
-
 /**
  * return the square value
  */
@@ -88,7 +60,7 @@ inline T square(T x)
 template <typename T>
 inline T hypot(T x, T y)
 {
-  return (T) (std::sqrt(x*x + y*y));
+  return (T) (sqrt(x*x + y*y));
 }
 
 /**
@@ -103,33 +75,33 @@ inline T hypot_sqr(T x, T y)
 /**
  * convert from degree to radian
  */
-inline number_t deg2rad(number_t degree)
+inline double deg2rad(double degree)
 {
-  return degree * cst(0.01745329251994329576);
+  return degree * 0.01745329251994329576;
 }
 
 /**
  * convert from radian to degree
  */
-inline number_t rad2deg(number_t rad)
+inline double rad2deg(double rad)
 {
-  return rad * cst(57.29577951308232087721);
+  return rad * 57.29577951308232087721;
 }
 
 /**
  * normalize the angle
  */
-inline number_t normalize_theta(number_t theta)
+inline double normalize_theta(double theta)
 {
-  if (theta >= -const_pi() && theta < const_pi())
+  if (theta >= -M_PI && theta < M_PI)
     return theta;
   
-  number_t multiplier = std::floor(theta / (2*const_pi()));
-  theta = theta - multiplier*2*const_pi();
-  if (theta >= const_pi())
-    theta -= 2*const_pi();
-  if (theta < -const_pi())
-    theta += 2*const_pi();
+  double multiplier = floor(theta / (2*M_PI));
+  theta = theta - multiplier*2*M_PI;
+  if (theta >= M_PI)
+    theta -= 2*M_PI;
+  if (theta < -M_PI)
+    theta += 2*M_PI;
 
   return theta;
 }
@@ -137,20 +109,20 @@ inline number_t normalize_theta(number_t theta)
 /**
  * inverse of an angle, i.e., +180 degree
  */
-inline number_t inverse_theta(number_t th)
+inline double inverse_theta(double th)
 {
-  return normalize_theta(th + const_pi());
+  return normalize_theta(th + M_PI);
 }
 
 /**
  * average two angles
  */
-inline number_t average_angle(number_t theta1, number_t theta2)
+inline double average_angle(double theta1, double theta2)
 {
-  number_t x, y;
+  double x, y;
 
-  x = std::cos(theta1) + std::cos(theta2);
-  y = std::sin(theta1) + std::sin(theta2);
+  x = cos(theta1) + cos(theta2);
+  y = sin(theta1) + sin(theta2);
   if(x == 0 && y == 0)
     return 0;
   else
@@ -202,7 +174,7 @@ inline T wrap(T l, T x, T u)
 /**
  * tests whether there is a NaN in the array
  */
-inline bool arrayHasNaN(const number_t* array, int size, int* nanIndex = 0)
+inline bool arrayHasNaN(const double* array, int size, int* nanIndex = 0)
 {
   for (int i = 0; i < size; ++i)
     if (g2o_isnan(array[i])) {
diff --git a/g2o/stuff/opengl_primitives.cpp b/g2o/stuff/opengl_primitives.cpp
deleted file mode 100644
index b7008677..00000000
--- a/g2o/stuff/opengl_primitives.cpp
+++ /dev/null
@@ -1,308 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-//
-// This file is part of g2o.
-// 
-// g2o is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-// 
-// g2o is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with g2o.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "opengl_primitives.h"
-
-#include <cstdlib>
-#include <cmath>
-
-#ifdef __APPLE__
-# include <OpenGL/glu.h>
-#else
-# include <GL/glu.h>
-#endif
-
-namespace g2o {
-namespace opengl {
-
-/**
- * \brief handle the GLU quadratic
- */
-class GLUWrapper
-{
-  public:
-    static GLUquadricObj* getQuadradic()
-    {
-      static GLUWrapper inst;
-      return inst._quadratic;
-    }
-  protected:
-    GLUWrapper()
-    {
-      //std::cerr << __PRETTY_FUNCTION__ << std::endl;
-      _quadratic = gluNewQuadric();              // Create A Pointer To The Quadric Object ( NEW )
-      gluQuadricNormals(_quadratic, GLU_SMOOTH); // Create Smooth Normals ( NEW )
-    }
-    ~GLUWrapper()
-    {
-      //std::cerr << __PRETTY_FUNCTION__ << std::endl;
-      gluDeleteQuadric(_quadratic);
-    }
-    GLUquadricObj* _quadratic;;
-};
-
-void drawArrow2D(float len, float head_width, float head_len)
-{
-  glBegin(GL_LINES);
-  glVertex2f(0.f, 0.f);
-  glVertex2f(len, 0.f);
-  glEnd();
-
-  glNormal3f(0.f,0.f,1.f);
-  glBegin(GL_TRIANGLES);
-  glVertex2f(len, 0.f);
-  glVertex2f(len - head_len,  0.5f*head_width);
-  glVertex2f(len - head_len, -0.5f*head_width);
-  glEnd();
-}
-
-void drawPoseBox()
-{
-  glPushMatrix();
-  glScalef(0.5f,1.f,1.f);
-  glPushMatrix();
-  glScalef(1.f,0.25f,0.5f);
-  glTranslatef(-0.5f,0.5f,0.f);
-  glColor3f(1.0f, 0.3f, 0.3f);
-  drawBox(1.f, 1.f, 1.f);
-  glPopMatrix();
-
-  glPushMatrix();
-  glScalef(1.f,0.25f,0.5f);
-  glTranslatef(-0.5f,-0.5f,0.f);
-  glColor3f(1.0f, 0.1f, 0.1f);
-  drawBox(1.f, 1.f, 1.f);
-  glPopMatrix();
-
-  glPushMatrix();
-  glScalef(1.f,0.25f,0.5f);
-  glTranslatef(+0.5f,0.5f,0.f);
-  glColor3f(0.3f, 0.3f, 1.0f);
-  drawBox(1.f, 1.f, 1.f);
-  glPopMatrix();
-
-  glPushMatrix();
-  glScalef(1.f,0.25f,0.5f);
-  glTranslatef(+0.5f,-0.5f,0.f);
-  glColor3f(0.1f, 0.1f, 1.f);
-  drawBox(1.f, 1.f, 1.f);
-  glPopMatrix();
-  glPopMatrix();
-}
-
-void drawBox(GLfloat l, GLfloat w, GLfloat h)
-{
-  GLfloat sx = l*0.5f;
-  GLfloat sy = w*0.5f;
-  GLfloat sz = h*0.5f;
-
-  glBegin(GL_QUADS);
-  // bottom
-  glNormal3f( 0.0f, 0.0f,-1.0f);
-  glVertex3f(-sx, -sy, -sz);
-  glVertex3f(-sx, sy, -sz);
-  glVertex3f(sx, sy, -sz);
-  glVertex3f(sx, -sy, -sz);
-  // top
-  glNormal3f( 0.0f, 0.0f,1.0f);
-  glVertex3f(-sx, -sy, sz);
-  glVertex3f(-sx, sy, sz);
-  glVertex3f(sx, sy, sz);
-  glVertex3f(sx, -sy, sz);
-  // back
-  glNormal3f(-1.0f, 0.0f, 0.0f);
-  glVertex3f(-sx, -sy, -sz);
-  glVertex3f(-sx, sy, -sz);
-  glVertex3f(-sx, sy, sz);
-  glVertex3f(-sx, -sy, sz);
-  // front
-  glNormal3f( 1.0f, 0.0f, 0.0f);
-  glVertex3f(sx, -sy, -sz);
-  glVertex3f(sx, sy, -sz);
-  glVertex3f(sx, sy, sz);
-  glVertex3f(sx, -sy, sz);
-  // left
-  glNormal3f( 0.0f, -1.0f, 0.0f);
-  glVertex3f(-sx, -sy, -sz);
-  glVertex3f(sx, -sy, -sz);
-  glVertex3f(sx, -sy, sz);
-  glVertex3f(-sx, -sy, sz);
-  //right
-  glNormal3f( 0.0f, 1.0f, 0.0f);
-  glVertex3f(-sx, sy, -sz);
-  glVertex3f(sx, sy, -sz);
-  glVertex3f(sx, sy, sz);
-  glVertex3f(-sx, sy, sz);
-  glEnd();
-}
-
-void drawPlane(GLfloat l, GLfloat w)
-{
-  GLfloat sx = l*0.5f;
-  GLfloat sy = w*0.5f;
-
-  glBegin(GL_QUADS);
-  glNormal3f( 0.0f, 0.0f, 1.0f);
-  glVertex3f(-sx, -sy, 0.f);
-  glVertex3f(-sx, sy, 0.f);
-  glVertex3f(sx, sy, 0.f);
-  glVertex3f(sx, -sy, 0.f);
-  glEnd();
-}
-
-void drawSphere(GLfloat radius)
-{
-  gluSphere(GLUWrapper::getQuadradic(), radius, 32, 32);
-}
-
-void drawEllipsoid(GLfloat r1, GLfloat r2, GLfloat r3)
-{
-  GLboolean hasNormalization = glIsEnabled(GL_NORMALIZE);
-  if (!hasNormalization)
-    glEnable(GL_NORMALIZE);
-  glPushMatrix();
-  glScalef(r1, r2, r3);
-  gluSphere(GLUWrapper::getQuadradic(), 1.0f, 32, 32);
-  glPopMatrix();
-  if (!hasNormalization)
-    glDisable(GL_NORMALIZE);
-}
-
-void drawCone(GLfloat radius, GLfloat height)
-{
-  glPushMatrix();
-  glRotatef(-90.f, 1.f, 0.f, 0.f);
-  glTranslatef(0.f, 0.f, - height/2.0f);
-  gluCylinder(GLUWrapper::getQuadradic(), radius, 0.f, height, 32, 1);
-  gluDisk(GLUWrapper::getQuadradic(), 0, radius, 32, 1);
-  glPopMatrix();
-}
-
-void drawCylinder(GLfloat radius, GLfloat height)
-{
-  glPushMatrix();
-  glRotatef(-90, 1.f, 0.f, 0.f);
-  glTranslatef(0.f, 0.f, + height/2.0f);
-  gluDisk(GLUWrapper::getQuadradic(), 0.f, radius, 32, 1);
-  glTranslatef(0, 0, - height);
-  gluCylinder(GLUWrapper::getQuadradic(), radius, radius, height, 32, 1);
-  glRotatef(180, 1.f, 0.f, 0.f);
-  gluDisk(GLUWrapper::getQuadradic(), 0, radius, 32, 1);
-  glPopMatrix();
-}
-
-void drawDisk(GLfloat radius)
-{
-  glRotatef(90, 0.f, 1.f, 0.f);
-  gluDisk(GLUWrapper::getQuadradic(), 0, radius, 32, 1);
-}
-
-void drawPyramid(GLfloat length, GLfloat height)
-{
-  glPushMatrix();
-  glTranslatef(0.f, 0.f, - height/2.0f);
-  glRotatef(45, 0.f, 0.f, 1.f);
-  gluCylinder(GLUWrapper::getQuadradic(), length, 0.f, height, 4, 1);
-  gluDisk(GLUWrapper::getQuadradic(), 0, length, 4, 1);
-  glPopMatrix();
-}
-
-void drawRangeRing(GLfloat range, GLfloat fov, GLfloat range_width)
-{
-  glPushMatrix();
-  glRotatef((fov/2.0f) - 90, 0.f, 0.f, 1.f);
-  gluPartialDisk(GLUWrapper::getQuadradic(), range, range + range_width, 32, 1, 0.f, fov);
-  glPopMatrix();
-}
-
-void drawSlice(GLfloat radius, GLfloat height, GLfloat fov, int slices_per_circle)
-{
-  double fov_rad = fov/180.*M_PI; // convert to rad
-  int num_slices = int(slices_per_circle * (fov_rad / (2*M_PI))) + 1;
-  double angle_step = fov_rad / num_slices;
-  double angle_step_half = angle_step * 0.5;
-
-  GLfloat height_half = height * 0.5f;
-  GLfloat lower_z = -height_half;
-  GLfloat upper_z =  height_half;
-
-  GLfloat last_x = float(std::cos(-fov_rad * 0.5f) * radius);
-  GLfloat last_y = float(std::sin(-fov_rad * 0.5f) * radius);
-
-  glPushMatrix();
-  glBegin(GL_TRIANGLES);
-  glNormal3f((float)std::sin(-fov_rad * 0.5), (float)-std::cos(-fov_rad * 0.5), 0.f);
-  glVertex3f(0.f, 0.f, upper_z);
-  glVertex3f(0.f, 0.f, lower_z);
-  glVertex3f(last_x, last_y, upper_z);
-  glVertex3f(last_x, last_y, upper_z);
-  glVertex3f(last_x, last_y, lower_z);
-  glVertex3f(0.f, 0.f, lower_z);
-
-  double start_angle = -0.5*fov_rad + angle_step;
-  double angle       = start_angle;
-  for (int i = 0; i < num_slices; ++i) {
-    GLfloat x = float(std::cos(angle) * radius);
-    GLfloat y = float(std::sin(angle) * radius);
-    GLfloat front_normal_x = (float)std::cos(angle + angle_step_half);
-    GLfloat front_normal_y = (float)std::sin(angle + angle_step_half);
-
-    // lower triangle
-    glNormal3f(0.f, 0.f, -1.f);
-    glVertex3f(0.f, 0.f, lower_z);
-    glVertex3f(x, y, lower_z);
-    glVertex3f(last_x, last_y, lower_z);
-    // upper
-    glNormal3f(0.f, 0.f, 1.f);
-    glVertex3f(0.f, 0.f, upper_z);
-    glVertex3f(x, y, upper_z);
-    glVertex3f(last_x, last_y, upper_z);
-    //front rectangle (we use two triangles)
-    glNormal3f(front_normal_x, front_normal_y, 0.f);
-    glVertex3f(last_x, last_y, upper_z);
-    glVertex3f(last_x, last_y, lower_z);
-    glVertex3f(x, y, upper_z);
-    glVertex3f(x, y, upper_z);
-    glVertex3f(x, y, lower_z);
-    glVertex3f(last_x, last_y, lower_z);
-
-    last_x = x;
-    last_y = y;
-    angle += angle_step;
-  }
-
-  glNormal3f(float(-std::sin(fov_rad * 0.5)), float(std::cos(fov_rad * 0.5)), -0.f);
-  glVertex3f(0.f, 0.f, upper_z);
-  glVertex3f(0.f, 0.f, lower_z);
-  glVertex3f(last_x, last_y, upper_z);
-  glVertex3f(last_x, last_y, upper_z);
-  glVertex3f(last_x, last_y, lower_z);
-  glVertex3f(0.f, 0.f, lower_z);
-
-  glEnd();
-  glPopMatrix();
-}
-
-  void drawPoint(float pointSize){
-    glPointSize(pointSize);
-    glBegin(GL_POINTS);
-    glVertex3f(0,0,0);
-    glEnd();
-  }
-} // end namespace
-} // end namespace
diff --git a/g2o/stuff/opengl_primitives.h b/g2o/stuff/opengl_primitives.h
deleted file mode 100644
index d0d0e023..00000000
--- a/g2o/stuff/opengl_primitives.h
+++ /dev/null
@@ -1,149 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-//
-// This file is part of g2o.
-// 
-// g2o is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-// 
-// g2o is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with g2o.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef G2O_OPENGL_PRIMITIVES_H
-#define G2O_OPENGL_PRIMITIVES_H
-
-/** @addtogroup viewer libviewer **/
-// @{
-
-/** \file primitives.h
- * \brief draw primitives with OpenGL
- */
-
-#include "opengl_wrapper.h"
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-#  ifdef G2O_SHARED_LIBS
-#    ifdef opengl_helper_EXPORTS
-#      define G2O_OPENGL_API __declspec(dllexport)
-#    else
-#      define G2O_OPENGL_API __declspec(dllimport)
-#    endif
-#  else
-#    define G2O_OPENGL_API
-#  endif
-#else
-#  define G2O_OPENGL_API
-#endif
-
-namespace g2o {
-namespace opengl {
-
-/**
- * draw a box that is centered in the current coordinate frame
- * @param l length of the box (x dimension)
- * @param w width of the box (y dimension)
- * @param h height of the box (z dimension)
- */
-void G2O_OPENGL_API drawBox(GLfloat l, GLfloat w, GLfloat h);
-
-/**
- * draw a plane in x-y dimension with a height of zero
- * @param l length in x
- * @param w width in y
- */
-void G2O_OPENGL_API drawPlane(GLfloat l, GLfloat w);
-
-/**
- * draw a sphere whose center is in the origin of the current coordinate frame
- * @param radius the radius of the sphere
- */
-void G2O_OPENGL_API drawSphere(GLfloat radius);
-
-/**
- * draw a ellipsoid whose center is in the origin of the current coordinate frame
- * @param r1 radius along x axis
- * @param r2 radius along y axis
- * @param r3 radius along z axis
- */
-void G2O_OPENGL_API drawEllipsoid(GLfloat r1, GLfloat r2, GLfloat r3);
-
-/**
- * draw a cone
- */
-void G2O_OPENGL_API drawCone(GLfloat radius, GLfloat height);
-
-/**
- * draw a disk
- */
-void G2O_OPENGL_API drawDisk(GLfloat radius);
-
-/**
- * draw a (closed) cylinder
- * @param radius the radius of the cylinder
- * @param height the height of the cylinder
- */
-void G2O_OPENGL_API drawCylinder(GLfloat radius, GLfloat height);
-
-/**
- * draw a pyramid
- */
-void G2O_OPENGL_API drawPyramid(GLfloat length, GLfloat height);
-
-/**
- * draw a range ring
- * @param range the range (radius) of the partial ring
- * @param fov Field Of View of the range sensor
- * @param range_width specify how thick the ring should be drawn
- */
-void G2O_OPENGL_API drawRangeRing(GLfloat range, GLfloat fov, GLfloat range_width = 0.05);
-
-/**
- * draw a slice of a cylinder (approximated with slices_per_circle triangles for the complete circle)
- * @param radius the radius of the cylinder
- * @param height the height of the cylinder
- * @param fov the "fov" of the slice (om degree)
- * @param slices_per_circle the number of triangle used to approximate the fulle circle
- */
-void G2O_OPENGL_API drawSlice(GLfloat radius, GLfloat height, GLfloat fov, int slices_per_circle = 32);
-
-/**
- * draws a box used to represent a 6d pose
- */
-void G2O_OPENGL_API drawPoseBox();
-
-/**
- * draw a 2D arrow along the x axis with the given len
- */
-void G2O_OPENGL_API drawArrow2D(float len, float head_width, float head_len);
-
-/**
- * draw a point in the origin, having a size of pointSize
- */
-void G2O_OPENGL_API drawPoint(float  pointSize);
-
-
-// @}
-
-#define POSE_VERTEX_COLOR 0.5f,0.5f,0.8f
-#define POSE_PARAMETER_COLOR 0.5f,0.5f,0.8f
-#define POSE_EDGE_COLOR 0.4f,0.4f,0.7f
-#define POSE_EDGE_GHOST_COLOR 0.4f,0.4f,0.7f
-
-#define LANDMARK_VERTEX_COLOR 0.8f,0.5f,0.3f
-#define LANDMARK_EDGE_COLOR   0.7f,0.4f,0.2f
-#define LANDMARK_EDGE_GHOST_COLOR   0.7f,0.4f,0.2f
-
-
-} // end namespace
-} // end namespace
-
-#endif
diff --git a/g2o/stuff/opengl_wrapper.h b/g2o/stuff/opengl_wrapper.h
deleted file mode 100644
index f17a0100..00000000
--- a/g2o/stuff/opengl_wrapper.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_OPENGL_WRAPPER_H
-#define G2O_OPENGL_WRAPPER_H
-
-#include "g2o/config.h"
-
-#ifdef WINDOWS
-#include <windows.h>
-#endif
-
-#ifdef G2O_OPENGL_FOUND
-# ifdef __APPLE__
-#  include <OpenGL/gl.h>
-# else
-#  include <GL/gl.h>
-# endif
-#endif
-
-#endif
diff --git a/g2o/stuff/os_specific.c b/g2o/stuff/os_specific.c
index 4f12cb97..9a18673b 100644
--- a/g2o/stuff/os_specific.c
+++ b/g2o/stuff/os_specific.c
@@ -30,18 +30,19 @@
 
 int vasprintf(char** strp, const char* fmt, va_list ap)
 {
+  int n;
   int size = 100;
   char* p;
   char* np;
 
-  if ((p = (char*)malloc(size * sizeof(char))) == NULL)
+  if ((p = (char*)malloc(size * sizeof(char))) == nullptr)
     return -1;
 
   while (1) {
 #ifdef _MSC_VER
-    int n = vsnprintf_s(p, size, size - 1, fmt, ap);
+    n = vsnprintf_s(p, size, size - 1, fmt, ap);
 #else
-    int n = vsnprintf(p, size, fmt, ap);
+    n = vsnprintf(p, size, fmt, ap);
 #endif
     if (n > -1 && n < size) {
       *strp = p;
@@ -51,7 +52,7 @@ int vasprintf(char** strp, const char* fmt, va_list ap)
       size = n+1;
     else
       size *= 2;
-    if ((np = (char*)realloc (p, size * sizeof(char))) == NULL) {
+    if ((np = (char*)realloc (p, size * sizeof(char))) == nullptr) {
       free(p);
       return -1;
     } else
diff --git a/g2o/stuff/os_specific.h b/g2o/stuff/os_specific.h
index f8057b40..89dd0ccc 100644
--- a/g2o/stuff/os_specific.h
+++ b/g2o/stuff/os_specific.h
@@ -34,7 +34,7 @@
 #ifndef _WINDOWS
 #include <sys/time.h>
 #endif
-#define drand48() ((number_t) rand()/(number_t)RAND_MAX)
+#define drand48() ((double) rand()/(double)RAND_MAX)
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/g2o/stuff/property.cpp b/g2o/stuff/property.cpp
index 8a15e03a..df5aae60 100644
--- a/g2o/stuff/property.cpp
+++ b/g2o/stuff/property.cpp
@@ -32,17 +32,17 @@
 #include "macros.h"
 
 #include "string_tools.h"
-using namespace std;
+
 
 namespace g2o {
 
-  BaseProperty::BaseProperty(const std::string& name_) :_name(name_){
+  BaseProperty::BaseProperty(const std::string name_) :_name(name_){
   }
 
   BaseProperty::~BaseProperty(){}
 
   bool PropertyMap::addProperty(BaseProperty* p) {
-    std::pair<PropertyMapIterator,bool> result = insert(make_pair(p->name(), p));
+    std::pair<PropertyMapIterator,bool> result = insert(std::make_pair(p->name(), p));
     return result.second;
   }
 
@@ -56,7 +56,7 @@ namespace g2o {
   }
 
   PropertyMap::~PropertyMap() {
-    for (PropertyMapIterator it=begin(); it!=end(); ++it){
+    for (PropertyMapIterator it=begin(); it!=end(); it++){
       if (it->second)
         delete it->second;
     }
@@ -73,12 +73,12 @@ namespace g2o {
 
   void PropertyMap::writeToCSV(std::ostream& os) const
   {
-    for (PropertyMapConstIterator it=begin(); it!=end(); ++it){
+    for (PropertyMapConstIterator it=begin(); it!=end(); it++){
       BaseProperty* p =it->second;
       os << p->name() << ", ";
     }
     os << std::endl;
-    for (PropertyMapConstIterator it=begin(); it!=end(); ++it){
+    for (PropertyMapConstIterator it=begin(); it!=end(); it++){
       BaseProperty* p =it->second;
       os << p->toString() << ", ";
     }
@@ -88,15 +88,15 @@ namespace g2o {
   bool PropertyMap::updateMapFromString(const std::string& values)
   {
     bool status = true;
-    vector<string> valuesMap = strSplit(values, ",");
+    std::vector<std::string> valuesMap = strSplit(values, ",");
     for (size_t i = 0; i < valuesMap.size(); ++i) {
-      vector<string> m = strSplit(valuesMap[i], "=");
+      std::vector<std::string> m = strSplit(valuesMap[i], "=");
       if (m.size() != 2) {
-        cerr << __PRETTY_FUNCTION__ << ": unable to extract name=value pair from " << valuesMap[i] << endl;
+        std::cerr << __PRETTY_FUNCTION__ << ": unable to extract name=value pair from " << valuesMap[i] << std::endl;
         continue;
       }
-      string name = trim(m[0]);
-      string value = trim(m[1]);
+      std::string name = trim(m[0]);
+      std::string value = trim(m[1]);
       status = status && updatePropertyFromString(name, value);
     }
     return status;
diff --git a/g2o/stuff/property.h b/g2o/stuff/property.h
index c915d445..7b638780 100644
--- a/g2o/stuff/property.h
+++ b/g2o/stuff/property.h
@@ -32,13 +32,12 @@
 #include <sstream>
 
 #include "string_tools.h"
-#include "g2o_stuff_api.h"
 
 namespace g2o {
 
-  class G2O_STUFF_API BaseProperty {
+  class  BaseProperty {
     public:
-      BaseProperty(const std::string& name_);
+      BaseProperty(const std::string name_);
       virtual ~BaseProperty();
       const std::string& name() {return _name;}
       virtual std::string toString() const = 0;
@@ -73,7 +72,7 @@ namespace g2o {
   /**
    * \brief a collection of properties mapping from name to the property itself
    */
-  class G2O_STUFF_API PropertyMap : protected std::map<std::string, BaseProperty*>
+  class  PropertyMap : protected std::map<std::string, BaseProperty*>
   {
     public:
       typedef std::map<std::string, BaseProperty*>        BaseClass;
@@ -100,7 +99,7 @@ namespace g2o {
       {
         PropertyMapIterator it=find(name_);
         if (it==end())
-          return nullptr;
+          return 0;
         return dynamic_cast<P*>(it->second);
       }
       template <typename P> 
@@ -108,7 +107,7 @@ namespace g2o {
       {
         PropertyMapConstIterator it=find(name_);
         if (it==end())
-          return nullptr;
+          return 0;
         return dynamic_cast<P*>(it->second);
       }
 
diff --git a/g2o/stuff/sampler.cpp b/g2o/stuff/sampler.cpp
deleted file mode 100644
index afd8824c..00000000
--- a/g2o/stuff/sampler.cpp
+++ /dev/null
@@ -1,47 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "sampler.h"
-
-namespace g2o {
-
-  static std::normal_distribution<number_t> _univariateSampler(0., 1.);
-  static std::uniform_real_distribution<number_t> _uniformReal;
-  static std::mt19937 _gen_real;
- 
-  number_t sampleUniform(number_t min, number_t max, std::mt19937* generator){
-    if (generator)
-      return _uniformReal(*generator)*(max-min)+min;
-    return _uniformReal(_gen_real)*(max-min)+min;
-  }
-
-  number_t sampleGaussian(std::mt19937* generator){
-    if (generator)
-      return _univariateSampler(*generator);
-    return _univariateSampler(_gen_real);
-  }
-
-}
diff --git a/g2o/stuff/sampler.h b/g2o/stuff/sampler.h
deleted file mode 100644
index d631aa55..00000000
--- a/g2o/stuff/sampler.h
+++ /dev/null
@@ -1,113 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_GAUSSIAN_SAMPLER_
-#define G2O_GAUSSIAN_SAMPLER_
-
-#include <Eigen/Core>
-#include <cassert>
-#include <cmath>
-#include <cstdlib>
-#include <ctime>
-#include <memory>
-#include <random>
-
-#include "g2o_stuff_api.h"
-
-namespace g2o {
-
-number_t G2O_STUFF_API sampleUniform(number_t min = 0, number_t max = 1, std::mt19937* generator = 0);
-number_t G2O_STUFF_API sampleGaussian(std::mt19937* generator = 0);
-
-template <class SampleType, class CovarianceType>
-class GaussianSampler {
- public:
-  GaussianSampler(GaussianSampler const&) = delete;
-  GaussianSampler& operator=(const GaussianSampler&) = delete;
-  GaussianSampler(bool hasGenerator = true) : _generator(hasGenerator ? new std::mt19937 : nullptr) {}
-  void setDistribution(const CovarianceType& cov) {
-    Eigen::LLT<CovarianceType> cholDecomp;
-    cholDecomp.compute(cov);
-    if (cholDecomp.info() == Eigen::NumericalIssue) {
-      assert(false && "Cholesky decomposition on the covariance matrix failed");
-      return;
-    }
-    _cholesky = cholDecomp.matrixL();
-  }
-  //! return a sample of the Gaussian distribution
-  SampleType generateSample() {
-    SampleType s;
-    for (int i = 0; i < s.size(); i++) {
-      s(i) = (_generator) ? sampleGaussian(_generator.get()) : sampleGaussian();
-    }
-    return _cholesky * s;
-  }
-  //! seed the random number generator, returns false if not having an own generator.
-  bool seed(int s) {
-    if (!_generator) return false;
-    _generator->seed(s);
-    return true;
-  }
-
- protected:
-  CovarianceType _cholesky;
-  std::unique_ptr<std::mt19937> _generator;
-};
-
-class G2O_STUFF_API Sampler {
- public:
-  /**
-   * Gaussian random with a mean and standard deviation. Uses the
-   * Polar method of Marsaglia.
-   */
-  static number_t gaussRand(number_t mean, number_t sigma) {
-    number_t y, r2;
-    do {
-      number_t x = -1.0 + 2.0 * uniformRand(0.0, 1.0);
-      y = -1.0 + 2.0 * uniformRand(0.0, 1.0);
-      r2 = x * x + y * y;
-    } while (r2 > 1.0 || r2 == 0.0);
-    return mean + sigma * y * std::sqrt(-2.0 * log(r2) / r2);
-  }
-
-  /**
-   * sample a number from a uniform distribution
-   */
-  static number_t uniformRand(number_t lowerBndr, number_t upperBndr) {
-    return lowerBndr + ((number_t)std::rand() / (RAND_MAX + 1.0)) * (upperBndr - lowerBndr);
-  }
-  /**
-   * default seed function using the current time in seconds
-   */
-  static void seedRand() { seedRand(static_cast<unsigned int>(std::time(NULL))); }
-
-  /** seed the random number generator */
-  static void seedRand(unsigned int seed) { std::srand(seed); }
-};
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/stuff/scoped_pointer.h b/g2o/stuff/scoped_pointer.h
deleted file mode 100644
index 221cd16d..00000000
--- a/g2o/stuff/scoped_pointer.h
+++ /dev/null
@@ -1,137 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SCOPED_POINTER_H
-#define G2O_SCOPED_POINTER_H
-
-#include <cassert>
-
-namespace g2o {
-
-namespace {
-struct ScopedPointerDeleter {
-  template <typename T>
-  void operator()(T* t) {
-    delete t;
-  }
-};
-}  // namespace
-
-/**
- * \brief a scoped pointer for an objectarray, i.e., object will be deleted on leaving the scope
- */
-template <typename T, typename Del = ScopedPointerDeleter>
-class ScopedPointer {
- public:
-  ScopedPointer(T* t = 0) : _pointer(t) {}
-
-  ~ScopedPointer() {
-    Del deleter;
-    deleter(_pointer);
-  }
-
-  //! dereference the pointer
-  T& operator*() const { return *_pointer; }
-  //! access the pointer via ->
-  T* operator->() const { return _pointer; }
-  //! return the pointer
-  T* get() const { return _pointer; }
-
-  /**
-   * store another pointer inside
-   */
-  void reset(T* p) {
-    assert((p == 0 || p != _pointer) && "ScopedPointer should not reset with itself");
-    ScopedPointer aux(p);
-    swap(aux);
-  }
-
-  /**
-   * swap with another pointer
-   */
-  void swap(ScopedPointer& b) {
-    T* aux = b._pointer;
-    b._pointer = _pointer;
-    _pointer = aux;
-  }
-
- protected:
-  T* _pointer;
-
-  // do not allow to copy the object
- private:
-  ScopedPointer(const ScopedPointer&);
-  const ScopedPointer& operator=(const ScopedPointer&);
-};
-
-/**
- * \brief a scoped pointer for an array, i.e., array will be deleted on leaving the scope
- */
-template <typename T>
-class ScopedArray {
- public:
-  ScopedArray(T* t = 0) : _pointer(t) {}
-
-  ~ScopedArray() { delete[] _pointer; }
-
-  T& operator[](std::ptrdiff_t i) const {
-    assert(_pointer != 0 && i >= 0);
-    return _pointer[i];
-  }
-
-  //! return the pointer
-  T* get() const { return _pointer; }
-
-  /**
-   * store another array pointer inside
-   */
-  void reset(T* p) {
-    assert((p == 0 || p != _pointer) && "ScopedArray should not reset with itself");
-    ScopedArray aux(p);
-    swap(aux);
-  }
-
-  /**
-   * swap with another pointer
-   */
-  void swap(ScopedArray& b) {
-    T* aux = b._pointer;
-    b._pointer = _pointer;
-    _pointer = aux;
-  }
-
- protected:
-  T* _pointer;
-
-  // do not allow to copy the object
- private:
-  ScopedArray(const ScopedArray&);
-  const ScopedArray& operator=(const ScopedArray&);
-};
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/stuff/sparse_helper.cpp b/g2o/stuff/sparse_helper.cpp
deleted file mode 100644
index 441ffc99..00000000
--- a/g2o/stuff/sparse_helper.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "sparse_helper.h"
-
-#include <algorithm>
-#include <fstream>
-#include <iomanip>
-#include <string>
-#include <vector>
-
-using namespace std;
-
-namespace g2o {
-
-static bool writeTripletEntries(const std::string& filename, int rows, int cols,
-                                const std::vector<TripletEntry>& triplets) {
-  string name = filename;
-  std::string::size_type lastDot = name.find_last_of('.');
-  if (lastDot != std::string::npos) name = name.substr(0, lastDot);
-
-  std::ofstream fout(filename.c_str());
-  fout << "# name: " << name << std::endl;
-  fout << "# type: sparse matrix" << std::endl;
-  fout << "# nnz: " << triplets.size() << std::endl;
-  fout << "# rows: " << rows << std::endl;
-  fout << "# columns: " << cols << std::endl;
-  // fout << fixed;
-  fout << setprecision(9) << endl;
-  for (const TripletEntry& entry : triplets) {
-    fout << entry.r + 1 << " " << entry.c + 1 << " " << entry.x << std::endl;
-  }
-  return fout.good();
-}
-
-bool writeVector(const string& filename, const number_t* v, int n) {
-  ofstream os(filename.c_str());
-  os << fixed;
-  for (int i = 0; i < n; i++) os << *v++ << endl;
-  return os.good();
-}
-
-bool writeCCSMatrix(const string& filename, int rows, int cols, const int* Ap, const int* Ai,
-                    const double* Ax, bool upperTriangleSymmetric) {
-  vector<TripletEntry> entries;
-  entries.reserve((size_t)Ap[cols]);
-  for (int i = 0; i < cols; i++) {
-    const int& rbeg = Ap[i];
-    const int& rend = Ap[i + 1];
-    for (int j = rbeg; j < rend; j++) {
-      entries.emplace_back(TripletEntry(Ai[j], i, Ax[j]));
-      if (upperTriangleSymmetric && Ai[j] != i) entries.emplace_back(TripletEntry(i, Ai[j], Ax[j]));
-    }
-  }
-  sort(entries.begin(), entries.end(), TripletColSort());
-  return writeTripletEntries(filename, rows, cols, entries);
-}
-
-bool writeTripletMatrix(const std::string& filename, int nz, int rows, int cols, const int* Ai,
-                        const int* Aj, const double* Ax, bool upperTriangleSymmetric) {
-  vector<TripletEntry> entries;
-  entries.reserve(nz);
-  for (int i = 0; i < nz; ++i) {
-    entries.emplace_back(TripletEntry(Ai[i], Aj[i], Ax[i]));
-    if (upperTriangleSymmetric && Ai[i] != Aj[i])
-      entries.emplace_back(TripletEntry(Aj[i], Ai[i], Ax[i]));
-  }
-  sort(entries.begin(), entries.end(), TripletColSort());
-  return writeTripletEntries(filename, rows, cols, entries);
-}
-
-}  // namespace g2o
diff --git a/g2o/stuff/sparse_helper.h b/g2o/stuff/sparse_helper.h
deleted file mode 100644
index 910d1be7..00000000
--- a/g2o/stuff/sparse_helper.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SPARSE_HELPER_H
-#define G2O_SPARSE_HELPER_H
-
-#include <string>
-
-#include "g2o/config.h"
-#include "g2o_stuff_api.h"
-
-namespace g2o {
-
-struct TripletEntry {
-  int r, c;
-  number_t x;
-  TripletEntry(int r_, int c_, number_t x_) : r(r_), c(c_), x(x_) {}
-};
-struct TripletColSort {
-  bool operator()(const TripletEntry& e1, const TripletEntry& e2) const {
-    return e1.c < e2.c || (e1.c == e2.c && e1.r < e2.r);
-  }
-};
-
-/**
- * write an array to a file, debugging
- */
-G2O_STUFF_API bool writeVector(const std::string& filename, const number_t* v, int n);
-
-/**
- * write a CCS matrix given by pointer to column, row, and values
- */
-G2O_STUFF_API bool writeCCSMatrix(const std::string& filename, int rows, int cols, const int* p, const int* i,
-                                  const double* v, bool upperTriangleSymmetric = true);
-
-/**
- * write a triplet matrix given by pointers
- * @param filename filename to write to
- * @param nz number of elements
- * @param rows number of rows of the matrix
- * @param cols number of colmuns of the matrix
- * @param Ai pointer to the row index (nz elements)
- * @param Aj pointer to the column index (nz elements)
- * @param Ax pointer to the vlaues index (nz elements)
- */
-G2O_STUFF_API bool writeTripletMatrix(const std::string& filename, int nz, int rows, int cols,
-                                      const int* Ai, const int* Aj, const double* Ax,
-                                      bool upperTriangleSymmetric = true);
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/stuff/string_tools.cpp b/g2o/stuff/string_tools.cpp
index 9077e53f..7addc750 100644
--- a/g2o/stuff/string_tools.cpp
+++ b/g2o/stuff/string_tools.cpp
@@ -43,15 +43,15 @@
 
 namespace g2o {
 
-using namespace std;
+
 
 std::string trim(const std::string& s)
 {
   if(s.length() == 0)
     return s;
-  string::size_type b = s.find_first_not_of(" \t\n");
-  string::size_type e = s.find_last_not_of(" \t\n");
-  if(b == string::npos)
+  std::string::size_type b = s.find_first_not_of(" \t\n");
+  std::string::size_type e = s.find_last_not_of(" \t\n");
+  if(b == std::string::npos)
     return "";
   return std::string(s, b, e - b + 1);
 }
@@ -60,9 +60,9 @@ std::string trimLeft(const std::string& s)
 {
   if(s.length() == 0)
     return s;
-  string::size_type b = s.find_first_not_of(" \t\n");
-  string::size_type e = s.length() - 1;
-  if(b == string::npos)
+  std::string::size_type b = s.find_first_not_of(" \t\n");
+  std::string::size_type e = s.length() - 1;
+  if(b == std::string::npos)
     return "";
   return std::string(s, b, e - b + 1);
 }
@@ -71,39 +71,39 @@ std::string trimRight(const std::string& s)
 {
   if(s.length() == 0)
     return s;
-  string::size_type b = 0;
-  string::size_type e = s.find_last_not_of(" \t\n");
-  if(e == string::npos)
+  std::string::size_type b = 0;
+  std::string::size_type e = s.find_last_not_of(" \t\n");
+  if(b == std::string::npos)
     return "";
   return std::string(s, b, e - b + 1);
 }
 
 std::string strToLower(const std::string& s)
 {
-  string ret;
+  std::string ret;
   std::transform(s.begin(), s.end(), back_inserter(ret), (int(*)(int)) std::tolower);
   return ret;
 }
 
 std::string strToUpper(const std::string& s)
 {
-  string ret;
+  std::string ret;
   std::transform(s.begin(), s.end(), back_inserter(ret), (int(*)(int)) std::toupper);
   return ret;
 }
 
 std::string formatString(const char* fmt, ...)
 {
-  char* auxPtr = NULL;
+  char* auxPtr = nullptr;
   va_list arg_list;
   va_start(arg_list, fmt);
   int numChar = vasprintf(&auxPtr, fmt, arg_list);
   va_end(arg_list);
-  string retString;
+  std::string retString;
   if (numChar != -1)
     retString = auxPtr;
   else {
-    cerr << __PRETTY_FUNCTION__ << ": Error while allocating memory" << endl;
+    std::cerr << __PRETTY_FUNCTION__ << ": Error while allocating memory" << std::endl;
   }
   free(auxPtr);
   return retString;
@@ -111,7 +111,7 @@ std::string formatString(const char* fmt, ...)
 
 int strPrintf(std::string& str, const char* fmt, ...)
 {
-  char* auxPtr = NULL;
+  char* auxPtr = nullptr;
   va_list arg_list;
   va_start(arg_list, fmt);
   int numChars = vasprintf(&auxPtr, fmt, arg_list);
@@ -124,7 +124,7 @@ int strPrintf(std::string& str, const char* fmt, ...)
 std::string strExpandFilename(const std::string& filename)
 {
 #if (defined (UNIX) || defined(CYGWIN)) && !defined(ANDROID)
-  string result = filename;
+  std::string result = filename;
   wordexp_t p;
 
   wordexp(filename.c_str(), &p, 0);
@@ -143,14 +143,14 @@ std::string strExpandFilename(const std::string& filename)
 std::vector<std::string> strSplit(const std::string& str, const std::string& delimiters)
 {
   std::vector<std::string> tokens;
-  string::size_type lastPos = 0;
-  string::size_type pos     = 0;
+  std::string::size_type lastPos = 0;
+  std::string::size_type pos     = 0;
 
   do {
     pos = str.find_first_of(delimiters, lastPos);
     tokens.push_back(str.substr(lastPos, pos - lastPos));
     lastPos = pos + 1;
-  }  while (string::npos != pos);
+  }  while (std::string::npos != pos);
 
   return tokens;
 }
diff --git a/g2o/stuff/string_tools.h b/g2o/stuff/string_tools.h
index e125b6d4..226208ff 100644
--- a/g2o/stuff/string_tools.h
+++ b/g2o/stuff/string_tools.h
@@ -33,7 +33,6 @@
 #include <vector>
 
 #include "macros.h"
-#include "g2o_stuff_api.h"
 
 namespace g2o {
 
@@ -47,27 +46,27 @@ namespace g2o {
 /**
  * remove whitespaces from the start/end of a string
  */
-G2O_STUFF_API std::string trim(const std::string& s);
+ std::string trim(const std::string& s);
 
 /**
  * remove whitespaces from the left side of the string
  */
-G2O_STUFF_API std::string trimLeft(const std::string& s);
+ std::string trimLeft(const std::string& s);
 
 /**
  * remove whitespaced from the right side of the string
  */
-G2O_STUFF_API std::string trimRight(const std::string& s);
+ std::string trimRight(const std::string& s);
 
 /**
  * convert the string to lower case
  */
-G2O_STUFF_API std::string strToLower(const std::string& s);
+ std::string strToLower(const std::string& s);
 
 /**
  * convert a string to upper case
  */
-G2O_STUFF_API std::string strToUpper(const std::string& s);
+ std::string strToUpper(const std::string& s);
 
 /**
  * read integer values (seperated by spaces) from a string and store
@@ -79,7 +78,7 @@ OutputIterator readInts(const char* str, OutputIterator out)
   char* cl  = (char*)str;
   char* cle = cl;
   while (1) {
-    long int id = strtol(cl, &cle, 10);
+    int id = strtol(cl, &cle, 10);
     if (cl == cle)
       break;
     *out++ = id;
@@ -98,7 +97,7 @@ OutputIterator readFloats(const char* str, OutputIterator out)
   char* cl  = (char*)str;
   char* cle = cl;
   while (1) {
-    number_t val = strtod(cl, &cle);
+    double val = strtod(cl, &cle);
     if (cl == cle)
       break;
     *out++ = val;
@@ -111,12 +110,12 @@ OutputIterator readFloats(const char* str, OutputIterator out)
  * format a string and return a std::string.
  * Format is just like printf, see man 3 printf
  */
-G2O_STUFF_API std::string formatString(const char* fmt, ...) G2O_ATTRIBUTE_FORMAT12;
+ std::string formatString(const char* fmt, ...) G2O_ATTRIBUTE_FORMAT12;
 
 /**
  * replacement function for sprintf which fills a std::string instead of a char*
  */
-G2O_STUFF_API int strPrintf(std::string& str, const char* fmt, ...) G2O_ATTRIBUTE_FORMAT23;
+ int strPrintf(std::string& str, const char* fmt, ...) G2O_ATTRIBUTE_FORMAT23;
 
 /**
  * convert a string into an other type.
@@ -146,29 +145,29 @@ T stringToType(const std::string& s, bool failIfLeftoverChars = true)
 /**
  * return true, if str starts with substr
  */
-G2O_STUFF_API bool strStartsWith(const std::string & str, const std::string& substr);
+ bool strStartsWith(const std::string & str, const std::string& substr);
 
 /**
  * return true, if str ends with substr
  */
-G2O_STUFF_API bool strEndsWith(const std::string & str, const std::string& substr);
+ bool strEndsWith(const std::string & str, const std::string& substr);
 
 /**
  * expand the given filename like a posix shell, e.g., ~ $CARMEN_HOME and other will get expanded.
  * Also command substitution, e.g. `pwd` will give the current directory.
  */
-G2O_STUFF_API std::string strExpandFilename(const std::string& filename);
+ std::string strExpandFilename(const std::string& filename);
 
 /**
  * split a string into token based on the characters given in delim
  */
-G2O_STUFF_API std::vector<std::string> strSplit(const std::string& s, const std::string& delim);
+ std::vector<std::string> strSplit(const std::string& s, const std::string& delim);
 
 /**
  * read a line from is into currentLine.
  * @return the number of characters read into currentLine (excluding newline), -1 on eof()
  */
-G2O_STUFF_API int readLine(std::istream& is, std::stringstream& currentLine);
+ int readLine(std::istream& is, std::stringstream& currentLine);
 
 // @}
 
diff --git a/g2o/stuff/tictoc.cpp b/g2o/stuff/tictoc.cpp
deleted file mode 100644
index b6d7dff3..00000000
--- a/g2o/stuff/tictoc.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "tictoc.h"
-
-#include "timeutil.h"
-
-#include "misc.h"
-
-#include <map>
-#include <limits>
-#include <algorithm>
-#include <vector>
-#include <cstdio>
-#include <cstdlib>
-
-namespace g2o {
-
-  /**
-   * \brief Internal structure of the tictoc profiling
-   */
-  struct TicTocElement
-  {
-    number_t ticTime;                         ///< the time of the last tic
-    number_t totalTime;                       ///< the total time of this part of the algorithm
-    int numCalls;                           ///< the number of calls
-    number_t minTime;
-    number_t maxTime;
-    number_t exponentialMovingAverage;        ///< exponential moving average with alpha = 0.01
-    std::string algorithmPart;              ///< name / description of the code block
-    bool clockIsRunning;
-    TicTocElement() :
-      ticTime(0.), totalTime(0.), numCalls(0),
-      minTime(std::numeric_limits<number_t>::max()),
-      maxTime(0.), exponentialMovingAverage(0.),
-      clockIsRunning(true)
-    {}
-    bool operator<(const TicTocElement& other) const
-    {
-      return totalTime < other.totalTime;
-    }
-  };
-  typedef std::map<std::string, TicTocElement> TicTocMap;
-
-  /**
-   * \brief helper for printing the struct at the end of the lifetime of the program
-   */
-  struct TicTocInitializer
-  {
-    TicTocMap tictocElements;
-    bool enabled;
-    TicTocInitializer()
-    {
-      enabled = getenv("G2O_ENABLE_TICTOC") != NULL;
-    }
-    ~TicTocInitializer()
-    {
-      if (!enabled) {
-        return;
-      }
-
-      if (tictocElements.size() > 0) {
-        int longestName = 0;
-        // sort the elements according to the total time and print a table
-        std::vector<TicTocElement> sortedElements;
-        sortedElements.reserve(tictocElements.size());
-        for (TicTocMap::const_iterator it = tictocElements.begin(); it != tictocElements.end(); ++it) {
-          if (it->second.numCalls == 0)
-            continue;
-          longestName = std::max(longestName, (int)it->first.size());
-          sortedElements.push_back(it->second);
-        }
-        std::sort(sortedElements.begin(), sortedElements.end());
-
-        longestName += 4;
-
-        // now print the table to stdout
-        printf("------------------------------------------\n");
-        printf("|          TICTOC STATISTICS             |\n");
-        printf("------------------------------------------\n");
-        for(std::vector<TicTocElement>::const_iterator it = sortedElements.begin(); it != sortedElements.end(); ++it) {
-          number_t avgTime = it->totalTime / it->numCalls;
-          printf("%s", it->algorithmPart.c_str());
-          for (int i = it->algorithmPart.size(); i < longestName; ++i)
-            putchar(' ');
-          printf("numCalls= %d\t total= %.4f\t avg= %.4f\t min= %.4f\t max= %.4f\t ema= %.4f\n",
-              it->numCalls, it->totalTime, avgTime, it->minTime, it->maxTime, it->exponentialMovingAverage);
-        }
-        printf("------------------------------------------\n");
-      }
-    }
-  };
-
-  number_t tictoc(const char* algorithmPart)
-  {
-    static TicTocInitializer initializer;
-    if (! initializer.enabled)
-      return 0.;
-
-    TicTocMap& tictocElements = initializer.tictocElements;
-    static number_t alpha = cst(0.01);
-    number_t now = get_monotonic_time();
-
-    number_t dt = 0.;
-    TicTocMap::iterator foundIt = tictocElements.find(algorithmPart);
-    if (foundIt == tictocElements.end()) {
-      // insert element
-      TicTocElement e;
-      e.ticTime = now;
-      e.algorithmPart = algorithmPart;
-      tictocElements[e.algorithmPart] = e;
-    } else {
-      if (foundIt->second.clockIsRunning) {
-        dt = now - foundIt->second.ticTime;
-        foundIt->second.totalTime += dt;
-        foundIt->second.minTime = std::min(foundIt->second.minTime, dt);
-        foundIt->second.maxTime = std::max(foundIt->second.maxTime, dt);
-        if (foundIt->second.numCalls == 0)
-          foundIt->second.exponentialMovingAverage = dt;
-        else
-          foundIt->second.exponentialMovingAverage = (1. - alpha) * foundIt->second.exponentialMovingAverage + alpha*dt;
-        foundIt->second.numCalls++;
-      } else {
-        foundIt->second.ticTime = now;
-      }
-      foundIt->second.clockIsRunning = !foundIt->second.clockIsRunning;
-    }
-    return dt;
-  }
-
-  ScopedTictoc::ScopedTictoc(const char* algorithmPart) :
-    _algorithmPart(algorithmPart)
-  {
-    tictoc(_algorithmPart.c_str());
-  }
-
-  ScopedTictoc::~ScopedTictoc()
-  {
-    tictoc(_algorithmPart.c_str());
-  }
-
-} // end namespace
diff --git a/g2o/stuff/tictoc.h b/g2o/stuff/tictoc.h
deleted file mode 100644
index 82047bcd..00000000
--- a/g2o/stuff/tictoc.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TICTOC_H
-#define G2O_TICTOC_H
-
-#include "g2o_stuff_api.h"
-
-#include <string>
-
-namespace g2o {
-
-  /**
-   * \brief Profile the timing of certain parts of your algorithm.
-   *
-   * Profile the timing of certain parts of your algorithm.
-   * A typical use-case is as follows:
-   *
-   * tictoc("doSomething");
-   * // place the code here.
-   * tictoc("doSomething");
-   *
-   * This will calculate statistics for the operations within
-   * the two calls to tictoc()
-   *
-   * If the environment variable G2O_ENABLE_TICTOC is defined, the timing will
-   * be performed.
-   */
-   G2O_STUFF_API number_t tictoc(const char* algorithmPart);
-
-   /**
-    * \brief Simplify calls to tictoc() for a whole scope
-    *
-    * See also the macro G2O_SCOPED_TICTOC below.
-    */
-   class G2O_STUFF_API ScopedTictoc
-   {
-     public:
-       ScopedTictoc(const char* algorithmPart);
-       ~ScopedTictoc();
-     protected:
-       std::string _algorithmPart;
-   };
-
-} // end namespace
-
-#ifndef G2O_SCOPED_TICTOC
-#define G2O_SCOPED_TICTOC(s) \
-  g2o::ScopedTictoc scopedTictoc (s)
-#endif
-
-#endif
diff --git a/g2o/stuff/timeutil.cpp b/g2o/stuff/timeutil.cpp
index c2b7eaf8..ec190519 100644
--- a/g2o/stuff/timeutil.cpp
+++ b/g2o/stuff/timeutil.cpp
@@ -27,17 +27,98 @@
 #include "timeutil.h"
 #include <iostream>
 
+#ifdef _WINDOWS
+#include <time.h>
+#include <windows.h>
+#endif
+
+#ifdef UNIX
+#include <unistd.h>
+#endif
+
 namespace g2o {
 
-  ScopeTime::ScopeTime(const char* title) : _title(title), _startTime(get_monotonic_time()) {}
+#ifdef _WINDOWS
+#if defined(_MSC_VER) || defined(_MSC_EXTENSIONS)
+  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64
+#else
+  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL
+#endif
 
-  ScopeTime::~ScopeTime() {
-    std::cerr << _title<<" took "<<1000*(get_monotonic_time()-_startTime)<<"ms.\n";
-  }
+struct timezone
+{
+  int  tz_minuteswest; /* minutes W of Greenwich */
+  int  tz_dsttime;     /* type of dst correction */
+};
+
+int gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+// Define a structure to receive the current Windows filetime
+  FILETIME ft;
+ 
+// Initialize the present time to 0 and the timezone to UTC
+  unsigned __int64 tmpres = 0;
+  static int tzflag = 0;
  
-  number_t get_monotonic_time()
+  if (NULL != tv)
   {
-    return seconds{ std::chrono::steady_clock::now().time_since_epoch() }.count();
+    GetSystemTimeAsFileTime(&ft);
+ 
+// The GetSystemTimeAsFileTime returns the number of 100 nanosecond 
+// intervals since Jan 1, 1601 in a structure. Copy the high bits to 
+// the 64 bit tmpres, shift it left by 32 then or in the low 32 bits.
+    tmpres |= ft.dwHighDateTime;
+    tmpres <<= 32;
+    tmpres |= ft.dwLowDateTime;
+ 
+// Convert to microseconds by dividing by 10
+    tmpres /= 10;
+ 
+// The Unix epoch starts on Jan 1 1970.  Need to subtract the difference 
+// in seconds from Jan 1 1601.
+    tmpres -= DELTA_EPOCH_IN_MICROSECS;
+ 
+// Finally change microseconds to seconds and place in the seconds value. 
+// The modulus picks up the microseconds.
+    tv->tv_sec = (long)(tmpres / 1000000UL);
+    tv->tv_usec = (long)(tmpres % 1000000UL);
   }
  
+  if (NULL != tz) {
+    if (!tzflag) {
+      _tzset();
+      tzflag++;
+    }
+
+    long sec;
+    int hours;
+    _get_timezone(&sec);
+    _get_daylight(&hours);
+  
+// Adjust for the timezone west of Greenwich
+    tz->tz_minuteswest = sec / 60;
+    tz->tz_dsttime = hours;
+  }
+ 
+  return 0;
+}
+#endif
+
+ScopeTime::ScopeTime(const char* title) : _title(title), _startTime(get_monotonic_time()) {}
+
+ScopeTime::~ScopeTime() {
+  std::cerr << _title<<" took "<<1000*(get_monotonic_time()-_startTime)<<"ms.\n";
+}
+
+double get_monotonic_time()
+{
+#if (defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0) && defined(_POSIX_MONOTONIC_CLOCK))
+  struct timespec ts;
+  clock_gettime(CLOCK_MONOTONIC, &ts);
+  return ts.tv_sec + ts.tv_nsec*1e-9;
+#else
+  return get_time();
+#endif
+}
+
 } // end namespace
diff --git a/g2o/stuff/timeutil.h b/g2o/stuff/timeutil.h
index 90bc4d99..bde8e318 100644
--- a/g2o/stuff/timeutil.h
+++ b/g2o/stuff/timeutil.h
@@ -27,11 +27,14 @@
 #ifndef G2O_TIMEUTIL_H
 #define G2O_TIMEUTIL_H
 
+#ifdef _WINDOWS
+#include <time.h>
+#else
+#include <sys/time.h>
+#endif
+
 #include <string>
-#include <chrono>
 
-#include "g2o_stuff_api.h"
-#include "g2o/stuff/misc.h"
 
 /** @addtogroup utils **/
 // @{
@@ -45,8 +48,8 @@
 #ifndef DO_EVERY_TS
 #define DO_EVERY_TS(secs, currentTime, code) \
 if (1) {\
-  static number_t s_lastDone_ = (currentTime); \
-  number_t s_now_ = (currentTime); \
+  static double s_lastDone_ = (currentTime); \
+  double s_now_ = (currentTime); \
   if (s_lastDone_ > s_now_) \
     s_lastDone_ = s_now_; \
   if (s_now_ - s_lastDone_ > (secs)) { \
@@ -65,31 +68,42 @@ if (1) {\
 #ifndef MEASURE_TIME
 #define MEASURE_TIME(text, code) \
   if(1) { \
-    number_t _start_time_ = g2o::get_time(); \
+    double _start_time_ = g2o::get_time(); \
     code; \
-    std::cerr << text << " took " << g2o::get_time() - _start_time_ << " sec" << std::endl; \
+    fprintf(stderr, "%s took %f sec\n", text, g2o::get_time() - _start_time_); \
   } else \
     (void) 0
 #endif
 
 namespace g2o {
 
-using seconds = std::chrono::duration<number_t>;
+#ifdef _WINDOWS
+typedef struct timeval {
+  long tv_sec;
+  long tv_usec;
+} timeval;
+ int gettimeofday(struct timeval *tv, struct timezone *tz);
+#endif
 
 /**
  * return the current time in seconds since 1. Jan 1970
  */
-inline number_t get_time() 
+inline double get_time() 
 {
-  return seconds{ std::chrono::system_clock::now().time_since_epoch() }.count();
+  struct timeval ts;
+  gettimeofday(&ts,0);
+  return ts.tv_sec + ts.tv_usec*1e-6;
 }
 
 /**
  * return a monotonic increasing time which basically does not need to
  * have a reference point. Consider this for measuring how long some
  * code fragments required to execute.
+ *
+ * On Linux we call clock_gettime() on other systems we currently
+ * call get_time().
  */
-G2O_STUFF_API number_t get_monotonic_time();
+ double get_monotonic_time();
 
 /**
  * \brief Class to measure the time spent in a scope
@@ -97,13 +111,13 @@ G2O_STUFF_API number_t get_monotonic_time();
  * To use this class, e.g. to measure the time spent in a function,
  * just create and instance at the beginning of the function.
  */
-class G2O_STUFF_API ScopeTime {
+class  ScopeTime {
   public: 
     ScopeTime(const char* title);
     ~ScopeTime();
   private:
     std::string _title;
-    number_t _startTime;
+    double _startTime;
 };
 
 } // end namespace
diff --git a/g2o/stuff/unscented.h b/g2o/stuff/unscented.h
deleted file mode 100644
index 015cf4f4..00000000
--- a/g2o/stuff/unscented.h
+++ /dev/null
@@ -1,93 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_UNSCENTED_
-#define G2O_UNSCENTED_
-
-#include <Eigen/Core>
-#include <Eigen/Cholesky>
-
-namespace g2o {
-  
-  template <class SampleType>
-  struct SigmaPoint {
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    SigmaPoint(const SampleType& sample, number_t wi, number_t wp):
-      _sample(sample), _wi(wi), _wp(wp){}
-    SigmaPoint(): _wi(0), _wp(0) {}
-    SampleType _sample;
-    number_t _wi;
-    number_t _wp;
-  };
-  
-  
-  template <class SampleType, class CovarianceType>
-  bool sampleUnscented(std::vector<SigmaPoint <SampleType>, Eigen::aligned_allocator<SigmaPoint <SampleType> > >& sigmaPoints, const SampleType& mean, const CovarianceType& covariance){
-
-    const int dim = mean.size();
-    const int numPoints = 2 * dim + 1;
-    assert (covariance.rows() == covariance.cols() && covariance.cols() == mean.size() && "Dimension Mismatch");
-    const number_t alpha = cst(1e-3);
-    const number_t beta  = 2;
-    const number_t lambda = alpha * alpha * dim;
-    const number_t wi = cst(1) / (2 * (dim + lambda) );
-    
-    sigmaPoints.resize(numPoints);
-    sigmaPoints[0] = SigmaPoint<SampleType>(mean, 
-              lambda/(dim + lambda), 
-              lambda/(dim + lambda) + (1.-alpha*alpha+beta) ); 
-    Eigen::LLT<CovarianceType> cholDecomp;
-    cholDecomp.compute(covariance*(dim+lambda));
-    if (cholDecomp.info()==Eigen::NumericalIssue)
-      return false;
-    const CovarianceType& L=cholDecomp.matrixL();
-    int k=1;
-    for (int i=0; i<dim; i++) {
-      SampleType s(L.col(i));
-      sigmaPoints[k++]=SigmaPoint<SampleType>(mean + s, wi, wi);
-      sigmaPoints[k++]=SigmaPoint<SampleType>(mean - s, wi, wi);
-    }
-    return true;
-  }
-
-  template <class SampleType, class CovarianceType>
-  void reconstructGaussian(SampleType& mean, CovarianceType& covariance,
-			   const std::vector<SigmaPoint<SampleType>, Eigen::aligned_allocator<SigmaPoint <SampleType> > >& sigmaPoints){
-
-    mean.fill(0);
-    covariance.fill(0);
-    for (size_t i=0; i<sigmaPoints.size(); i++){
-      mean += sigmaPoints[i]._wi * sigmaPoints[i]._sample;
-    }
-    for (size_t i=0; i<sigmaPoints.size(); i++){
-      SampleType delta = sigmaPoints[i]._sample - mean;
-      covariance += sigmaPoints[i]._wp * ( delta* delta.transpose() ) ;
-    }
-
-  }
-}
-
-#endif
diff --git a/g2o/types/CMakeLists.txt b/g2o/types/CMakeLists.txt
deleted file mode 100644
index 20afb287..00000000
--- a/g2o/types/CMakeLists.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-# Pre-canned types
-add_subdirectory(data)
-add_subdirectory(slam2d)
-add_subdirectory(slam3d)
-add_subdirectory(sba)
-add_subdirectory(sim3)
-add_subdirectory(icp)
-add_subdirectory(sclam2d)
-
-add_subdirectory(slam2d_addons)
-add_subdirectory(slam3d_addons)
diff --git a/g2o/types/data/CMakeLists.txt b/g2o/types/data/CMakeLists.txt
deleted file mode 100644
index ba4d1b21..00000000
--- a/g2o/types/data/CMakeLists.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-add_library(types_data ${G2O_LIB_TYPE}
-  types_data.cpp
-  robot_data.cpp robot_data.h
-  vertex_tag.cpp vertex_tag.h
-  vertex_ellipse.cpp vertex_ellipse.h
-  laser_parameters.cpp laser_parameters.h
-  raw_laser.cpp raw_laser.h
-  robot_laser.cpp robot_laser.h
-  data_queue.cpp data_queue.h
-  g2o_types_data_api.h
-)
-
-set_target_properties(types_data PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_data)
-if (APPLE)
-  set_target_properties(types_data PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-
-
-target_link_libraries(types_data core types_slam2d)
-if(G2O_HAVE_OPENGL)
-  target_link_libraries(types_data freeglut_minimal opengl_helper)
-endif()
-
-install(TARGETS types_data
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/data)
diff --git a/g2o/types/data/data_queue.cpp b/g2o/types/data/data_queue.cpp
deleted file mode 100644
index 97c1f4b7..00000000
--- a/g2o/types/data/data_queue.cpp
+++ /dev/null
@@ -1,81 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "data_queue.h"
-
-#include "g2o/types/data/robot_data.h"
-
-namespace g2o {
-
-  DataQueue::DataQueue()
-  {
-  }
-
-  DataQueue::~DataQueue()
-  {
-  }
-
-  RobotData* DataQueue::findClosestData(number_t timestamp) const
-  {
-    if (_buffer.rbegin()->first < timestamp)
-      return _buffer.rbegin()->second;
-    if (_buffer.begin()->first > timestamp)
-      return _buffer.begin()->second;
-
-    Buffer::const_iterator ub = _buffer.upper_bound(timestamp);
-    Buffer::const_iterator lb = ub;
-    --lb;
-    if (fabs(lb->first - timestamp) < fabs(ub->first - timestamp))
-      return lb->second;
-    else
-      return ub->second;
-  }
-
-  RobotData* DataQueue::before(number_t timestamp) const
-  {
-    if (_buffer.size() == 0 || _buffer.begin()->first > timestamp)
-      return nullptr;
-    Buffer::const_iterator lb = _buffer.upper_bound(timestamp);
-    --lb; // now it's the lower bound
-    return lb->second;
-  }
-
-  RobotData* DataQueue::after(number_t timestamp) const
-  {
-    if (_buffer.size() == 0 || _buffer.rbegin()->first < timestamp)
-      return nullptr;
-    Buffer::const_iterator ub = _buffer.upper_bound(timestamp);
-    if (ub == _buffer.end())
-      return nullptr;
-    return ub->second;
-  }
-
-  void DataQueue::add(RobotData* rd)
-  {
-    _buffer[rd->timestamp()] = rd;
-  }
-
-} // end namespace
diff --git a/g2o/types/data/data_queue.h b/g2o/types/data/data_queue.h
deleted file mode 100644
index e39d7925..00000000
--- a/g2o/types/data/data_queue.h
+++ /dev/null
@@ -1,64 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_DATA_QUEUE_H
-#define G2O_DATA_QUEUE_H
-
-#include <map>
-#include "g2o_types_data_api.h"
-
-namespace g2o {
-
-  class RobotData;
-
-  /**
-   * \brief a simple queue to store data and retrieve based on a timestamp
-   */
-  class G2O_TYPES_DATA_API DataQueue
-  {
-    public:
-      typedef std::map<number_t, RobotData*>           Buffer;
-
-    public:
-      DataQueue();
-      ~DataQueue();
-
-      void add(RobotData* rd);
-
-      RobotData* findClosestData(number_t timestamp) const;
-
-      RobotData* before(number_t timestamp) const;
-      RobotData* after(number_t timestamp) const;
-
-      const Buffer& buffer() const {return _buffer;}
-
-    protected:
-      Buffer _buffer;
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/data/g2o_types_data_api.h b/g2o/types/data/g2o_types_data_api.h
deleted file mode 100644
index 5493bd1f..00000000
--- a/g2o/types/data/g2o_types_data_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_DATA_API_H
-#define G2O_TYPES_DATA_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_data_EXPORTS
-#define G2O_TYPES_DATA_API __declspec(dllexport)
-#else
-#define G2O_TYPES_DATA_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_DATA_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_DATA_API
-#endif
-
-#endif // G2O_TYPES_DATA_API_H
diff --git a/g2o/types/data/laser_parameters.cpp b/g2o/types/data/laser_parameters.cpp
deleted file mode 100644
index 8b107160..00000000
--- a/g2o/types/data/laser_parameters.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "laser_parameters.h"
-
-namespace g2o {
-
-LaserParameters::LaserParameters(int t, int nbeams, number_t _firstBeamAngle, number_t _angularStep, number_t _maxRange,
-                                 number_t _accuracy, int _remissionMode, number_t _minRange)
-    : laserPose(SE2(0., 0., 0.)),
-      type(t),
-      firstBeamAngle(_firstBeamAngle),
-      fov(_angularStep * nbeams),
-      angularStep(_angularStep),
-      accuracy(_accuracy),
-      remissionMode(_remissionMode),
-      maxRange(_maxRange),
-      minRange(_minRange) {}
-
-LaserParameters::LaserParameters(int nbeams, number_t _firstBeamAngle, number_t _angularStep, number_t _maxRange,
-                                 number_t _minRange)
-    : laserPose(SE2(0., 0., 0.)),
-      type(0),
-      firstBeamAngle(_firstBeamAngle),
-      fov(_angularStep * nbeams),
-      angularStep(_angularStep),
-      accuracy(0.1),
-      remissionMode(0),
-      maxRange(_maxRange),
-      minRange(_minRange) {}
-
-}  // namespace g2o
diff --git a/g2o/types/data/laser_parameters.h b/g2o/types/data/laser_parameters.h
deleted file mode 100644
index 4ef1f924..00000000
--- a/g2o/types/data/laser_parameters.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LASER_PARAMETERS_H
-#define G2O_LASER_PARAMETERS_H
-
-#include "g2o/types/slam2d/se2.h"
-#include "g2o_types_data_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief parameters for a 2D range finder
-   */
-  struct G2O_TYPES_DATA_API LaserParameters
-  {
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    LaserParameters(int type, int beams, number_t firstBeamAngle, number_t angularStep, number_t maxRange, number_t accuracy, int remissionMode, number_t minRange = 0);
-    LaserParameters(int beams, number_t firstBeamAngle, number_t angularStep, number_t maxRange, number_t minRange = 0);
-    SE2 laserPose;
-    int type;
-    number_t firstBeamAngle;
-    number_t fov;
-    number_t angularStep;
-    number_t accuracy;
-    int remissionMode;
-    number_t maxRange;
-    number_t minRange;
-  };
-
-}
-
-#endif
diff --git a/g2o/types/data/raw_laser.cpp b/g2o/types/data/raw_laser.cpp
deleted file mode 100644
index f121a912..00000000
--- a/g2o/types/data/raw_laser.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "raw_laser.h"
-
-#include <iostream>
-
-using namespace std;
-
-namespace g2o {
-
-  RawLaser::RawLaser() :
-    RobotData(),
-    _laserParams(0, 180, -const_pi()/2, const_pi()/180, 50, cst(0.1), 0)
-  {
-  }
-
-  RawLaser::~RawLaser()
-  {
-  }
-
-  bool RawLaser::write(std::ostream& /*os*/) const
-  {
-    // TODO
-    cerr << "RawLaser::write() not implemented yet." << endl;
-    return false;
-  }
-
-  bool RawLaser::read(std::istream& is)
-  {
-    int type;
-    number_t angle, fov, res, maxrange, acc;
-    int remission_mode;
-    is >> type >> angle >> fov >> res >> maxrange >> acc >> remission_mode;
-
-    int beams;
-    is >> beams;
-    _laserParams = LaserParameters(type, beams, angle, res, maxrange, acc, remission_mode);      
-    _ranges.resize(beams);
-    for (int i=0; i<beams; i++)
-      is >> _ranges[i];
-
-    is >> beams;
-    _remissions.resize(beams);
-    for (int i=0; i < beams; i++)
-      is >> _remissions[i];
-
-    // timestamp + host
-    is >> _timestamp;
-    is >> _hostname;
-    is >> _loggerTimestamp;
-    return true;
-  }
-
-  void RawLaser::setRanges(const vector<number_t>& ranges)
-  {
-    _ranges = ranges;
-  }
-
-  void RawLaser::setRemissions(const std::vector<number_t>& remissions)
-  {
-    _remissions = remissions;
-  }
-
-  void RawLaser::setLaserParams(const LaserParameters& laserParams)
-  {
-    _laserParams = laserParams;
-  }
-
-  RawLaser::Point2DVector RawLaser::cartesian() const
-  {
-    Point2DVector points;
-    for (size_t i = 0; i < _ranges.size(); ++i) {
-      const number_t& r = _ranges[i];
-      if (r < _laserParams.maxRange && r > _laserParams.minRange) {
-        number_t alpha = _laserParams.firstBeamAngle + i * _laserParams.angularStep;
-        points.push_back(Vector2(std::cos(alpha) * r, std::sin(alpha) * r));
-      }
-    }
-    return points;
-  }
-
-} // end namespace
diff --git a/g2o/types/data/raw_laser.h b/g2o/types/data/raw_laser.h
deleted file mode 100644
index cfd2078c..00000000
--- a/g2o/types/data/raw_laser.h
+++ /dev/null
@@ -1,82 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_RAW_LASER_H
-#define G2O_RAW_LASER_H
-
-#include "robot_data.h"
-#include "laser_parameters.h"
-#include "g2o_types_data_api.h"
-
-#include <vector>
-
-#include<Eigen/Core>
-
-namespace g2o {
-
-  /**
-   * \brief Raw laser measuerement
-   *
-   * A raw laser measuerement. The read/write function correspond to the format of CARMEN.
-   */
-  class G2O_TYPES_DATA_API RawLaser : public RobotData {
-    public:
-      typedef std::vector<Vector2, Eigen::aligned_allocator<Vector2> >      Point2DVector;
-
-    public:
-      RawLaser();
-      ~RawLaser();
-
-      virtual bool write(std::ostream& os) const;
-      virtual bool read(std::istream& is);
-
-      /**
-       * computes a cartesian view of the beams (x,y).
-       * @return a vector with the points of the scan in cartesian coordinates.
-       */
-      Point2DVector cartesian() const;
-
-      //! the range measurements by the laser
-      const std::vector<number_t>& ranges() const { return _ranges;}
-      void setRanges(const std::vector<number_t>& ranges);
-
-      //! the remission measurements by the laser
-      const std::vector<number_t>& remissions() const { return _remissions;}
-      void setRemissions(const std::vector<number_t>& remissions);
-
-      //! the parameters of the laser
-      const LaserParameters& laserParams() const { return _laserParams;}
-      void setLaserParams(const LaserParameters& laserParams);
-
-    protected:
-      std::vector<number_t> _ranges;
-      std::vector<number_t> _remissions;
-      LaserParameters _laserParams;
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/data/robot_data.cpp b/g2o/types/data/robot_data.cpp
deleted file mode 100644
index 6f588643..00000000
--- a/g2o/types/data/robot_data.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "robot_data.h"
-
-namespace g2o {
-
-  RobotData::RobotData() :
-    HyperGraph::Data(),
-    _timestamp(-1.), _loggerTimestamp(-1.)
-  {
-  }
-
-  RobotData::~RobotData()
-  {
-  }
-
-  void RobotData::setTimestamp(number_t ts)
-  {
-    _timestamp = ts;
-  }
-
-  void RobotData::setLoggerTimestamp(number_t ts)
-  {
-    _loggerTimestamp = ts;
-  }
-
-  void RobotData::setTag(const std::string& tag)
-  {
-    _tag = tag;
-  }
-
-  void RobotData::setHostname(const std::string& hostname)
-  {
-    _hostname = hostname;
-  }
-
-} // end namespace
diff --git a/g2o/types/data/robot_data.h b/g2o/types/data/robot_data.h
deleted file mode 100644
index 2fb00aaa..00000000
--- a/g2o/types/data/robot_data.h
+++ /dev/null
@@ -1,68 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_ROBOT_DATA_H
-#define G2O_ROBOT_DATA_H
-
-#include <iosfwd>
-#include <string>
-
-#include "g2o/core/optimizable_graph.h"
-#include "g2o_types_data_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief data recorded by the robot
-   */
-  class G2O_TYPES_DATA_API RobotData : public HyperGraph::Data
-  {
-    public:
-      RobotData();
-      virtual ~RobotData();
-
-      number_t timestamp() const { return _timestamp;}
-      void setTimestamp(number_t ts);
-
-      number_t loggerTimestamp() const { return _loggerTimestamp;}
-      void setLoggerTimestamp(number_t ts);
-
-      const std::string& tag() const { return _tag;}
-      void setTag(const std::string& tag);
-
-      const std::string& hostname() const { return _hostname;}
-      void setHostname(const std::string& hostname);
-
-    protected:
-      number_t _timestamp; ///< timestamp when the measurement was generated
-      number_t _loggerTimestamp; ///< timestamp when the measurement was recorded
-      std::string _tag; ///< string tag (FLASER, ROBOTLASER, ODOM..) of the line in the log
-      std::string _hostname; ///< name of the computer/robot generating the data
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/data/robot_laser.cpp b/g2o/types/data/robot_laser.cpp
deleted file mode 100644
index 2f80dc68..00000000
--- a/g2o/types/data/robot_laser.cpp
+++ /dev/null
@@ -1,189 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "robot_laser.h"
-
-#include "g2o/stuff/macros.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-#include <iomanip>
-using namespace std;
-
-namespace g2o {
-
-  RobotLaser::RobotLaser() :
-    RawLaser(),
-    _laserTv(0.), _laserRv(0.), _forwardSafetyDist(0.), _sideSaftyDist(0.), _turnAxis(0.)
-  {
-  }
-
-  RobotLaser::~RobotLaser()
-  {
-  }
-
-  bool RobotLaser::read(std::istream& is)
-  {
-    int type;
-    number_t angle, fov, res, maxrange, acc;
-    int remission_mode;
-    is >> type >> angle >> fov >> res >> maxrange >> acc >> remission_mode;
-
-    int beams;
-    is >> beams;
-    _laserParams = LaserParameters(type, beams, angle, res, maxrange, acc, remission_mode);
-    _ranges.resize(beams);
-    for (int i=0; i<beams; i++)
-      is >> _ranges[i];
-
-    is >> beams;
-    _remissions.resize(beams);
-    for (int i = 0; i < beams; i++)
-      is >> _remissions[i];
-
-    // special robot laser stuff
-    number_t x,y,theta;
-    is >> x >> y >> theta;
-    SE2 lp(x,y,theta);
-    //cerr << "x: " << x << " y:" << y << " th:" << theta << " ";
-    is >> x >> y >> theta;
-    //cerr << "x: " << x << " y:" << y << " th:" << theta;
-    _odomPose = SE2(x,y,theta);
-    _laserParams.laserPose = _odomPose.inverse()*lp;
-    is >> _laserTv >>  _laserRv >>  _forwardSafetyDist >> _sideSaftyDist >> _turnAxis;
-
-    // timestamp + host
-    is >> _timestamp;
-    is >> _hostname;
-    is >> _loggerTimestamp;
-    return true;
-  }
-
-  bool RobotLaser::write(std::ostream& os) const
-  {
-    os << _laserParams.type << " " << _laserParams.firstBeamAngle << " " << _laserParams.fov << " "
-      << _laserParams.angularStep << " " << _laserParams.maxRange << " " << _laserParams.accuracy << " "
-      << _laserParams.remissionMode << " ";
-    os << ranges().size();
-    for (size_t i = 0; i < ranges().size(); ++i)
-      os << " " << ranges()[i];
-    os << " " << _remissions.size();
-    for (size_t i = 0; i < _remissions.size(); ++i)
-      os << " " << _remissions[i];
-
-    // odometry pose
-    Vector3 p = (_odomPose * _laserParams.laserPose).toVector();
-    os << " " << p.x() << " " << p.y() << " " << p.z();
-    p = _odomPose.toVector();
-    os << " " << p.x() << " " << p.y() << " " << p.z();
-
-    // crap values
-    os << FIXED(" " <<  _laserTv << " " <<  _laserRv << " " << _forwardSafetyDist << " "
-        << _sideSaftyDist << " " << _turnAxis);
-    os << FIXED(" " << timestamp() << " " << hostname() << " " << loggerTimestamp());
-
-    return os.good();
-  }
-
-  void RobotLaser::setOdomPose(const SE2& odomPose)
-  {
-    _odomPose = odomPose;
-  }
-
-
-
-
-#ifdef G2O_HAVE_OPENGL
-  RobotLaserDrawAction::RobotLaserDrawAction()
-      : DrawAction(typeid(RobotLaser).name()), _beamsDownsampling(nullptr), _pointSize(nullptr), _maxRange(nullptr) {}
-
-  bool RobotLaserDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _beamsDownsampling = _previousParams->makeProperty<IntProperty>(_typeName + "::BEAMS_DOWNSAMPLING", 1);
-      _pointSize = _previousParams->makeProperty<FloatProperty>(_typeName + "::POINT_SIZE", 1.0f);
-      _maxRange = _previousParams->makeProperty<FloatProperty>(_typeName + "::MAX_RANGE", -1.);
-    } else {
-      _beamsDownsampling = 0;
-      _pointSize= 0;
-      _maxRange = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* RobotLaserDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                 HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams){
-      return this;
-    }
-    if (_show && !_show->value())
-      return this;
-    RobotLaser* that = static_cast<RobotLaser*>(element);
-
-    RawLaser::Point2DVector points=that->cartesian();
-    if (_maxRange && _maxRange->value() >=0 ) {
-      // prune the cartesian points;
-      RawLaser::Point2DVector npoints(points.size());
-      int k = 0;
-      auto r2 = std::pow(_maxRange->value(), 2);
-      for (size_t i = 0; i < points.size(); i++) {
-        if (points[i].squaredNorm() < r2) npoints[k++] = points[i];
-      }
-      points = npoints;
-      npoints.resize(k);
-    }
-
-    glPushMatrix();
-    const SE2& laserPose = that->laserParams().laserPose;
-    glTranslatef((float)laserPose.translation().x(), (float)laserPose.translation().y(), 0.f);
-    glRotatef((float)RAD2DEG(laserPose.rotation().angle()),0.f,0.f,1.f);
-    glColor4f(1.f,0.f,0.f,0.5f);
-    int step = 1;
-    if (_beamsDownsampling )
-      step = _beamsDownsampling->value();
-    if (_pointSize) {
-      glPointSize(_pointSize->value());
-    }
-
-    glBegin(GL_POINTS);
-    for (size_t i=0; i<points.size(); i+=step){
-      glVertex3f((float)points[i].x(), (float)points[i].y(), 0.f);
-    }
-    glEnd();
-    glPopMatrix();
-
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/data/robot_laser.h b/g2o/types/data/robot_laser.h
deleted file mode 100644
index 180e786a..00000000
--- a/g2o/types/data/robot_laser.h
+++ /dev/null
@@ -1,78 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_ROBOT_LASER_H
-#define G2O_ROBOT_LASER_H
-
-#include "raw_laser.h"
-#include "g2o_types_data_api.h"
-#include "g2o/core/hyper_graph_action.h"
-
-namespace g2o {
-
-  /**
-   * \brief laser measurement obtained by a robot
-   *
-   * A laser measurement obtained by a robot. The measurement is equipped with a pose of the robot at which
-   * the measurement was taken. The read/write function correspond to the CARMEN logfile format.
-   */
-  class G2O_TYPES_DATA_API RobotLaser : public RawLaser
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      RobotLaser();
-      ~RobotLaser();
-
-      virtual bool write(std::ostream& os) const;
-      virtual bool read(std::istream& is);
-
-      SE2 laserPose() const { return _odomPose * _laserParams.laserPose;} 
-      const SE2& odomPose() const { return _odomPose;}
-      void setOdomPose(const SE2& odomPose);
-
-    protected:
-      SE2 _odomPose;
-      //! velocities and safety distances of the robot.
-      number_t _laserTv, _laserRv, _forwardSafetyDist, _sideSaftyDist, _turnAxis;
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_DATA_API RobotLaserDrawAction: public DrawAction{
-  public:
-    RobotLaserDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_ );
-  protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    IntProperty* _beamsDownsampling;
-    FloatProperty* _pointSize;
-    FloatProperty* _maxRange;
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/data/types_data.cpp b/g2o/types/data/types_data.cpp
deleted file mode 100644
index f19df7ae..00000000
--- a/g2o/types/data/types_data.cpp
+++ /dev/null
@@ -1,52 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "g2o/config.h"
-
-#include "robot_laser.h"
-#include "vertex_tag.h"
-#include "vertex_ellipse.h"
-
-
-#include "g2o/core/factory.h"
-#include "g2o/core/creators.h"
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  G2O_REGISTER_TYPE_GROUP(data);
-
-  G2O_REGISTER_TYPE(VERTEX_TAG, VertexTag);
-  G2O_REGISTER_TYPE(ROBOTLASER1, RobotLaser);
-  G2O_REGISTER_TYPE(VERTEX_ELLIPSE, VertexEllipse);
-
-#ifdef G2O_HAVE_OPENGL 
-  G2O_REGISTER_ACTION(RobotLaserDrawAction);
-  G2O_REGISTER_ACTION(VertexTagDrawAction);
-  G2O_REGISTER_ACTION(VertexEllipseDrawAction);
-#endif
-
-} // end namespace
diff --git a/g2o/types/data/types_data.h b/g2o/types/data/types_data.h
deleted file mode 100644
index 0b28a254..00000000
--- a/g2o/types/data/types_data.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_DATA_H
-#define G2O_TYPES_DATA_H
-
-#include "robot_laser.h"
-#include "vertex_tag.h"
-#include "vertex_ellipse.h"
-
-#endif
diff --git a/g2o/types/data/vertex_ellipse.cpp b/g2o/types/data/vertex_ellipse.cpp
deleted file mode 100644
index 93b97e4f..00000000
--- a/g2o/types/data/vertex_ellipse.cpp
+++ /dev/null
@@ -1,173 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_ellipse.h"
-
-#include "g2o/stuff/macros.h"
-#include "g2o/stuff/misc.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#include "EXTERNAL/freeglut/freeglut_minimal.h"
-#endif
-
-#include <iomanip>
-
-#include <Eigen/Eigenvalues>
-
-using namespace std;
-
-namespace g2o {
-
-VertexEllipse::VertexEllipse()
-    : RobotData(), _covariance(Matrix3F::Zero()), _UMatrix(Matrix2F::Zero()), _singularValues(Vector2F::Zero()) {}
-
-VertexEllipse::~VertexEllipse() {}
-
-void VertexEllipse::_updateSVD() const {
-  Eigen::SelfAdjointEigenSolver<Matrix2F> eigenSolver(_covariance.block<2, 2>(0, 0));
-  _UMatrix = eigenSolver.eigenvectors();
-  _singularValues = eigenSolver.eigenvalues();
-
-  }
-
-  bool VertexEllipse::read(std::istream& is)
-  {
-    float cxx, cxy, cxt, cyy, cyt, ctt;
-    is >> cxx >> cxy >> cxt >> cyy >> cyt >> ctt;
-    _covariance(0,0) = cxx;
-    _covariance(0,1) = cxy;
-    _covariance(0,2) = cxt;
-    _covariance(1,0) = cxy;
-    _covariance(1,1) = cyy;
-    _covariance(1,2) = cyt;
-    _covariance(2,0) = cxt;
-    _covariance(2,1) = cyt;
-    _covariance(2,2) = ctt;
-
-    _updateSVD();
-
-    int size;
-    is >> size;
-    for (int i =0; i<size; i++){
-      float x, y;
-      is >> x >> y;
-      addMatchingVertex(x,y);
-    }
-
-    return true;
-  }
-
-  bool VertexEllipse::write(std::ostream& os) const
-  {
-    os << _covariance(0,0) << " " << _covariance(0,1) << " " << _covariance(0,2) << " "
-       << _covariance(1,1) << " " << _covariance(1,2) << " " << _covariance(2,2) << " ";
-
-    os << _matchingVertices.size() << " " ;
-    for (size_t i=0 ; i< _matchingVertices.size(); i++){
-      os << _matchingVertices[i].x() << " " << _matchingVertices[i].y() << " ";
-    }
-
-    return os.good();
-  }
-
-
-
-#ifdef G2O_HAVE_OPENGL
-  VertexEllipseDrawAction::VertexEllipseDrawAction(): DrawAction(typeid(VertexEllipse).name()){
-    _scaleFactor = 0;
-  }
-
-  bool VertexEllipseDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _scaleFactor = _previousParams->makeProperty<DoubleProperty>(_typeName + "::", 1);
-    } else {
-      _scaleFactor = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexEllipseDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-							       HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams){
-      return this;
-    }
-    if (_show && !_show->value())
-      return this;
-
-    VertexEllipse* that = dynamic_cast<VertexEllipse*>(element);
-
-    glPushMatrix();
-
-    float sigmaTheta = sqrt(that->covariance()(2,2));
-    float x = 0.1f*cosf(sigmaTheta);
-    float y = 0.1f*sinf(sigmaTheta);
-
-    glColor3f(1.f,0.7f,1.f);
-    glBegin(GL_LINE_STRIP);
-    glVertex3f(x,y,0);
-    glVertex3f(0,0,0);
-    glVertex3f(x,-y,0);
-    glEnd();
-
-    glColor3f(0.f,1.f,0.f);
-    for (size_t i=0; i< that->matchingVertices().size(); i++){
-      glBegin(GL_LINES);
-      glVertex3f(0,0,0);
-      glVertex3f(that->matchingVertices()[i].x(),that->matchingVertices()[i].y(),0);
-      glEnd();
-    }
-
-    Matrix2F rot = that->U();
-    float angle = std::atan2(rot(1,0), rot(0,0));
-    glRotatef(angle*180.0/const_pi(), 0., 0., 1.);
-    Vector2F sv = that->singularValues();
-    glScalef(sqrt(sv(0)), sqrt(sv(1)), 1);
-
-    glColor3f(1.f,0.7f,1.f);
-    glBegin(GL_LINE_LOOP);
-    for(int i=0; i<36; i++){
-      float rad = i*const_pi() /18.0;
-      glVertex2f(std::cos(rad),
-		 std::sin(rad));
-    }
-    glEnd();
-
-
-
-    glPopMatrix();
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/data/vertex_ellipse.h b/g2o/types/data/vertex_ellipse.h
deleted file mode 100644
index 5acb26f0..00000000
--- a/g2o/types/data/vertex_ellipse.h
+++ /dev/null
@@ -1,92 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_ELLIPSE_H
-#define G2O_VERTEX_ELLIPSE_H
-
-#include "robot_data.h"
-#include "g2o_types_data_api.h"
-#include "g2o/core/hyper_graph_action.h"
-
-namespace g2o {
-
-  /**
-   * \brief string ellipse to be attached to a vertex
-   */
-  class G2O_TYPES_DATA_API VertexEllipse : public RobotData
-  {
-    public:
-      typedef std::vector<Vector2F, Eigen::aligned_allocator<Vector2F> > myVector2fVector;
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexEllipse();
-      ~VertexEllipse();
-
-      virtual bool write(std::ostream& os) const;
-      virtual bool read(std::istream& is);
-
-      const Matrix3F& covariance() {return _covariance;}
-      void setCovariance( Matrix3F& c) { _covariance = c; _updateSVD();}
-      const Matrix2F& U() {return _UMatrix;}
-      const Vector2F& singularValues() {return _singularValues;}
-
-      const myVector2fVector& matchingVertices() { return _matchingVertices; }
-      void addMatchingVertex(float x, float y) {
-        Vector2F v(x, y);
-        _matchingVertices.push_back(v);
-      }
-
-      void clearMatchingVertices() { _matchingVertices.clear(); }
-
-      const std::vector<int>& matchingVerticesIDs() { return _matchingVerticesIDs; }
-      void addMatchingVertexID(int id) { _matchingVerticesIDs.push_back(id); }
-      void clearMatchingVerticesIDs(){_matchingVerticesIDs.clear();}
-
-  protected:
-      void _updateSVD() const;
-      Matrix3F _covariance;
-      mutable Matrix2F _UMatrix;
-      mutable Vector2F _singularValues;
-      std::vector<int> _matchingVerticesIDs;
-      myVector2fVector _matchingVertices;
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_DATA_API VertexEllipseDrawAction : public DrawAction {
-   public:
-    VertexEllipseDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-                                                HyperGraphElementAction::Parameters* params_);
-
-   protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    DoubleProperty* _scaleFactor;
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/data/vertex_tag.cpp b/g2o/types/data/vertex_tag.cpp
deleted file mode 100644
index b4e97015..00000000
--- a/g2o/types/data/vertex_tag.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_tag.h"
-
-#include "g2o/stuff/macros.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#include "EXTERNAL/freeglut/freeglut_minimal.h"
-#endif
-
-#include <iomanip>
-using namespace std;
-
-namespace g2o {
-
-  VertexTag::VertexTag() : RobotData()
-  {
-  }
-
-  VertexTag::~VertexTag()
-  {
-  }
-
-  bool VertexTag::read(std::istream& is)
-  {
-    is >> _name;
-    is >> _position.x() >> _position.y() >> _position.z();
-    is >> _odom2d.x() >> _odom2d.y() >> _odom2d.z();
-    is >> _timestamp;
-    is >> _hostname;
-    is >> _loggerTimestamp;
-    return true;
-  }
-
-  bool VertexTag::write(std::ostream& os) const
-  {
-    os << _name << " ";
-    os << FIXED(_position.x() << " " << _position.y() << " " << _position.z() << " ");
-    os << FIXED(_odom2d.x() << " " << _odom2d.y() << " " << _odom2d.z() << " ");
-    os << FIXED(" " << timestamp() << " " << hostname() << " " << loggerTimestamp());
-    return os.good();
-  }
-
-
-
-#ifdef G2O_HAVE_OPENGL
-  VertexTagDrawAction::VertexTagDrawAction() : DrawAction(typeid(VertexTag).name()), _textSize(nullptr) {}
-
-  bool VertexTagDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _textSize = _previousParams->makeProperty<DoubleProperty>(_typeName + "::TEXT_SIZE", 1);
-    } else {
-      _textSize = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexTagDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                 HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams){
-      return this;
-    }
-    VertexTag* that = static_cast<VertexTag*>(element);
-
-    glPushMatrix();
-    glColor3f(1.f,0.2f,1.f);
-    glTranslatef(that->position().x(), that->position().y(), that->position().z());
-    float textSize = 1;
-    if (_textSize )
-      textSize = (float)_textSize->value();
-    opengl::drawBox(0.1f*textSize, 0.1f*textSize, 0.1f*textSize);
-    glTranslatef(0.2f*textSize, 0.f, 0.f);
-    glScalef(0.003f*textSize,0.003f*textSize,1.f);
-    freeglut_minimal::glutStrokeString(freeglut_minimal::GLUT_STROKE_ROMAN, that->name().c_str());
-    glPopMatrix();
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/data/vertex_tag.h b/g2o/types/data/vertex_tag.h
deleted file mode 100644
index 5aac49fd..00000000
--- a/g2o/types/data/vertex_tag.h
+++ /dev/null
@@ -1,76 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_TAG_H
-#define G2O_VERTEX_TAG_H
-
-#include "robot_data.h"
-#include "g2o_types_data_api.h"
-#include "g2o/core/hyper_graph_action.h"
-
-namespace g2o {
-
-  /**
-   * \brief string tag to be attached to a vertex
-   *
-   * A laser measurement obtained by a robot. The measurement is equipped with a pose of the robot at which
-   * the measurement was taken. The read/write function correspond to the CARMEN logfile format.
-   */
-  class G2O_TYPES_DATA_API VertexTag : public RobotData
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexTag();
-      ~VertexTag();
-
-      virtual bool write(std::ostream& os) const;
-      virtual bool read(std::istream& is);
-      
-      const std::string name() const { return _name;} 
-      void setName(const std::string& name_) {_name=name_;}
-      const Vector3F& position() const {return _position;}
-      void setPosition( const Vector3F& p) {_position = p;}
-    protected:
-      std::string _name;
-      Vector3F _position;
-      Vector3F _odom2d;
-  };
-
- #ifdef G2O_HAVE_OPENGL 
-  class G2O_TYPES_DATA_API VertexTagDrawAction: public DrawAction{
-  public:
-    VertexTagDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_ );
-  protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    DoubleProperty* _textSize;
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/icp/CMakeLists.txt b/g2o/types/icp/CMakeLists.txt
deleted file mode 100644
index 02c80e82..00000000
--- a/g2o/types/icp/CMakeLists.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-add_library(types_icp ${G2O_LIB_TYPE}
-  types_icp.cpp  types_icp.h
-  g2o_types_icp_api.h
-)
-
-set_target_properties(types_icp PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_icp)
-if (APPLE)
-  set_target_properties(types_icp PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_icp types_sba types_slam3d)
-
-install(TARGETS types_icp
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-  )
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/icp)
diff --git a/g2o/types/icp/g2o_types_icp_api.h b/g2o/types/icp/g2o_types_icp_api.h
deleted file mode 100644
index 524ccffe..00000000
--- a/g2o/types/icp/g2o_types_icp_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_ICP_API_H
-#define G2O_TYPES_ICP_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_icp_EXPORTS
-#define G2O_TYPES_ICP_API __declspec(dllexport)
-#else
-#define G2O_TYPES_ICP_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_ICP_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_ICP_API
-#endif
-
-#endif
diff --git a/g2o/types/icp/types_icp.cpp b/g2o/types/icp/types_icp.cpp
deleted file mode 100644
index ebe34bc0..00000000
--- a/g2o/types/icp/types_icp.cpp
+++ /dev/null
@@ -1,335 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 Kurt Konolige
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_icp.h"
-#include "g2o/core/factory.h"
-#include "g2o/stuff/macros.h"
-
-#include <iostream>
-
-using namespace Eigen;
-
-namespace g2o {
-
-  G2O_REGISTER_TYPE_GROUP(icp);
-  G2O_REGISTER_TYPE(EDGE_V_V_GICP, Edge_V_V_GICP);
-
-  namespace types_icp {
-    int initialized = 0;
-
-    void init()
-    {
-      if (types_icp::initialized)
-        return;
-      //cerr << "Calling " << __FILE__ << " " << __PRETTY_FUNCTION__ << endl;
-
-      Edge_V_V_GICP::dRidx << 0.0,0.0,0.0,
-        0.0,0.0,2.0,
-        0.0,-2.0,0.0;
-      Edge_V_V_GICP::dRidy  << 0.0,0.0,-2.0,
-        0.0,0.0,0.0,
-        2.0,0.0,0.0;
-      Edge_V_V_GICP::dRidz  << 0.0,2.0,0.0,
-        -2.0,0.0,0.0,
-        0.0,0.0,0.0;
-
-      VertexSCam::dRidx << 0.0,0.0,0.0,
-        0.0,0.0,2.0,
-        0.0,-2.0,0.0;
-      VertexSCam::dRidy  << 0.0,0.0,-2.0,
-        0.0,0.0,0.0,
-        2.0,0.0,0.0;
-      VertexSCam::dRidz  << 0.0,2.0,0.0,
-        -2.0,0.0,0.0,
-        0.0,0.0,0.0;
-
-      types_icp::initialized = 1;
-    }
-  }
-
-  using namespace std;
-
-  Matrix3 Edge_V_V_GICP::dRidx; // differential quat matrices
-  Matrix3 Edge_V_V_GICP::dRidy; // differential quat matrices
-  Matrix3 Edge_V_V_GICP::dRidz; // differential quat matrices
-  Matrix3 VertexSCam::dRidx; // differential quat matrices
-  Matrix3 VertexSCam::dRidy; // differential quat matrices
-  Matrix3 VertexSCam::dRidz; // differential quat matrices
-  Matrix3 VertexSCam::Kcam;
-  number_t VertexSCam::baseline;
-
-  // global initialization
-  G2O_ATTRIBUTE_CONSTRUCTOR(init_icp_types)
-  {
-    types_icp::init();
-  }
-
-  // Copy constructor
-  Edge_V_V_GICP::Edge_V_V_GICP(const Edge_V_V_GICP* e)
-    : BaseBinaryEdge<3, EdgeGICP, VertexSE3, VertexSE3>()
-  {
-
-    // Temporary hack - TODO, sort out const-ness properly
-    _vertices[0] = const_cast<HyperGraph::Vertex*> (e->vertex(0));
-    _vertices[1] = const_cast<HyperGraph::Vertex*> (e->vertex(1));
-
-    _measurement.pos0 = e->measurement().pos0;
-    _measurement.pos1 = e->measurement().pos1;
-    _measurement.normal0 = e->measurement().normal0;
-    _measurement.normal1 = e->measurement().normal1;
-    _measurement.R0 = e->measurement().R0;
-    _measurement.R1 = e->measurement().R1;
-
-    pl_pl = e->pl_pl;
-    cov0 = e->cov0;
-    cov1 = e->cov1;
-
-    // TODO the robust kernel is not correctly copied
-    //_robustKernel = e->_robustKernel;
-  }
-
-  //
-  // Rigid 3D constraint between poses, given fixed point offsets
-  //
-
-  // input two matched points between the frames
-  // first point belongs to the first frame, position and normal
-  // second point belongs to the second frame, position and normal
-  //
-  // the measurement variable has type EdgeGICP (see types_icp.h)
-
-  bool Edge_V_V_GICP::read(std::istream& is)
-  {
-    // measured point and normal
-    for (int i=0; i<3; i++)
-      is >> _measurement.pos0[i];
-    for (int i=0; i<3; i++)
-      is >> _measurement.normal0[i];
-
-    // measured point and normal
-    for (int i=0; i<3; i++)
-      is >> _measurement.pos1[i];
-    for (int i=0; i<3; i++)
-      is >> _measurement.normal1[i];
-
-    // don't need this if we don't use it in error calculation (???)
-    //    inverseMeasurement() = -measurement();
-
-    _measurement.makeRot0();  // set up rotation matrices
-
-    // GICP info matrices
-
-    // point-plane only
-    Matrix3 prec;
-    number_t v = cst(.01);
-    prec << v, 0, 0,
-            0, v, 0,
-            0, 0, 1;
-    const Matrix3 &R = measurement().R0; // plane of the point in vp0
-    information() = R.transpose()*prec*R;
-
-    //    information().setIdentity();
-
-    //    setRobustKernel(true);
-    //setHuberWidth(0.01);      // units? m?
-
-    return true;
-  }
-
-
-  // Jacobian
-  // [ -R0'*R1 | R0 * dRdx/ddx * 0p1 ]
-  // [  R0'*R1 | R0 * dR'dx/ddx * 0p1 ]
-
-#ifdef GICP_ANALYTIC_JACOBIANS
-
-  // jacobian defined as:
-  //    f(T0,T1) =  dR0.inv() * T0.inv() * (T1 * dR1 * p1 + dt1) - dt0
-  //    df/dx0 = [-I, d[dR0.inv()]/dq0 * T01 * p1]
-  //    df/dx1 = [R0, T01 * d[dR1]/dq1 * p1]
-  void Edge_V_V_GICP::linearizeOplus()
-  {
-    VertexSE3* vp0 = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3* vp1 = static_cast<VertexSE3*>(_vertices[1]);
-
-    // topLeftCorner<3,3>() is the rotation matrix
-    Matrix3 R0T = vp0->estimate().matrix().topLeftCorner<3,3>().transpose();
-    Vector3 p1 = measurement().pos1;
-
-    // this could be more efficient
-    if (!vp0->fixed())
-      {
-        Isometry3 T01 = vp0->estimate().inverse() *  vp1->estimate();
-        Vector3 p1t = T01 * p1;
-        _jacobianOplusXi.block<3,3>(0,0) = -Matrix3::Identity();
-        _jacobianOplusXi.block<3,1>(0,3) = dRidx*p1t;
-        _jacobianOplusXi.block<3,1>(0,4) = dRidy*p1t;
-        _jacobianOplusXi.block<3,1>(0,5) = dRidz*p1t;
-      }
-
-    if (!vp1->fixed())
-      {
-        Matrix3 R1 = vp1->estimate().matrix().topLeftCorner<3,3>();
-        R0T = R0T*R1;
-        _jacobianOplusXj.block<3,3>(0,0) = R0T;
-        _jacobianOplusXj.block<3,1>(0,3) = R0T*dRidx.transpose()*p1;
-        _jacobianOplusXj.block<3,1>(0,4) = R0T*dRidy.transpose()*p1;
-        _jacobianOplusXj.block<3,1>(0,5) = R0T*dRidz.transpose()*p1;
-      }
-  }
-#endif
-
-
-  bool Edge_V_V_GICP::write(std::ostream& os) const
-  {
-    // first point
-    for (int i=0; i<3; i++)
-      os  << measurement().pos0[i] << " ";
-    for (int i=0; i<3; i++)
-      os  << measurement().normal0[i] << " ";
-
-    // second point
-    for (int i=0; i<3; i++)
-      os  << measurement().pos1[i] << " ";
-    for (int i=0; i<3; i++)
-      os  << measurement().normal1[i] << " ";
-
-
-    return os.good();
-  }
-
-  //
-  // stereo camera functions
-  //
-
-
-
-  VertexSCam::VertexSCam() :
-    VertexSE3()
-  {}
-
-
-  Edge_XYZ_VSC::Edge_XYZ_VSC()
-  {}
-
-#ifdef SCAM_ANALYTIC_JACOBIANS
-/**
- * \brief Jacobian for stereo projection
- */
-  void Edge_XYZ_VSC::linearizeOplus()
-  {
-    VertexSCam *vc = static_cast<VertexSCam *>(_vertices[1]);
-
-    VertexSBAPointXYZ *vp = static_cast<VertexSBAPointXYZ *>(_vertices[0]);
-    Vector4 pt, trans;
-    pt.head<3>() = vp->estimate();
-    pt(3) = 1.0;
-    trans.head<3>() = vc->estimate().translation();
-    trans(3) = 1.0;
-
-    // first get the world point in camera coords
-    Eigen::Matrix<number_t,3,1,Eigen::ColMajor> pc = vc->w2n * pt;
-
-    // Jacobians wrt camera parameters
-    // set d(quat-x) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    number_t px = pc(0);
-    number_t py = pc(1);
-    number_t pz = pc(2);
-    number_t ipz2 = 1.0/(pz*pz);
-    if (isnan(ipz2) )
-      {
-  std::cout << "[SetJac] infinite jac" << std::endl;
-  *(int *)0x0 = 0;
-      }
-
-    number_t ipz2fx = ipz2*vc->Kcam(0,0); // Fx
-    number_t ipz2fy = ipz2*vc->Kcam(1,1); // Fy
-    number_t b      = vc->baseline; // stereo baseline
-
-    Eigen::Matrix<number_t,3,1,Eigen::ColMajor> pwt;
-
-    // check for local vars
-    pwt = (pt-trans).head<3>(); // transform translations, use differential rotation
-
-    // dx
-    Eigen::Matrix<number_t,3,1,Eigen::ColMajor> dp = vc->dRdx * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,3) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,3) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,3) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    // dy
-    dp = vc->dRdy * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,4) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,4) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,4) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    // dz
-    dp = vc->dRdz * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,5) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,5) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,5) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-
-    // set d(t) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    dp = -vc->w2n.col(0);        // dpc / dx
-    _jacobianOplusXj(0,0) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,0) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,0) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = -vc->w2n.col(1);        // dpc / dy
-    _jacobianOplusXj(0,1) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,1) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,1) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = -vc->w2n.col(2);        // dpc / dz
-    _jacobianOplusXj(0,2) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,2) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,2) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-
-    // Jacobians wrt point parameters
-    // set d(t) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    dp = vc->w2n.col(0); // dpc / dx
-    _jacobianOplusXi(0,0) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,0) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXi(2,0) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = vc->w2n.col(1); // dpc / dy
-    _jacobianOplusXi(0,1) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,1) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXi(2,1) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = vc->w2n.col(2); // dpc / dz
-    _jacobianOplusXi(0,2) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,2) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXi(2,2) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-  }
-#endif
-  bool Edge_XYZ_VSC::read(std::istream&)
-  { return false; }
-
-  bool Edge_XYZ_VSC::write(std::ostream&) const
-  { return false; }
-
-  bool VertexSCam::read(std::istream&)
-  { return false; }
-
-  bool VertexSCam::write(std::ostream&) const
-  { return false; }
-
-} // end namespace
diff --git a/g2o/types/icp/types_icp.h b/g2o/types/icp/types_icp.h
deleted file mode 100644
index 5c87acce..00000000
--- a/g2o/types/icp/types_icp.h
+++ /dev/null
@@ -1,413 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 Kurt Konolige
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_ICP
-#define G2O_TYPES_ICP
-
-#define GICP_ANALYTIC_JACOBIANS
-//#define SCAM_ANALYTIC_JACOBIANS
-
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/core/base_multi_edge.h"
-#include "g2o/types/sba/types_sba.h"
-#include "g2o/types/slam3d/types_slam3d.h"
-#include "g2o_types_icp_api.h"
-
-#include <Eigen/Geometry>
-#include <iostream>
-
-namespace g2o {
-
-  namespace types_icp {
-    void init();
-  }
-//
-// GICP-type edges
-// Each measurement is between two rigid points on each 6DOF vertex
-//
-
-  //
-  // class for edges between two points rigidly attached to vertices
-  //
-
-  class G2O_TYPES_ICP_API EdgeGICP
-  {
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-   public:
-    // point positions
-    Vector3 pos0, pos1;
-
-    // unit normals
-    Vector3 normal0, normal1;
-
-    // rotation matrix for normal
-    Matrix3 R0,R1;
-
-    // initialize an object
-    EdgeGICP()
-      {
-        pos0.setZero();
-        pos1.setZero();
-        normal0 << 0, 0, 1;
-        normal1 << 0, 0, 1;
-        //makeRot();
-        R0.setIdentity();
-        R1.setIdentity();
-      }
-
-    // set up rotation matrix for pos0
-    void makeRot0() 
-    {
-      Vector3 y;
-      y << 0, 1, 0;
-      R0.row(2) = normal0;
-      y = y - normal0(1)*normal0;
-      y.normalize();            // need to check if y is close to 0
-      R0.row(1) = y;
-      R0.row(0) = normal0.cross(R0.row(1));
-      //      cout << normal.transpose() << endl;
-      //      cout << R0 << endl << endl;
-      //      cout << R0*R0.transpose() << endl << endl;
-    }
-
-    // set up rotation matrix for pos1
-    void makeRot1()
-    {
-      Vector3 y;
-      y << 0, 1, 0;
-      R1.row(2) = normal1;
-      y = y - normal1(1)*normal1;
-      y.normalize();            // need to check if y is close to 0
-      R1.row(1) = y;
-      R1.row(0) = normal1.cross(R1.row(1));
-    }
-
-    // returns a precision matrix for point-plane
-    Matrix3 prec0(number_t e)
-    {
-      makeRot0();
-      Matrix3 prec;
-      prec << e, 0, 0,
-              0, e, 0,
-              0, 0, 1;
-      return R0.transpose()*prec*R0;
-    }
-    
-    // returns a precision matrix for point-plane
-    Matrix3 prec1(number_t e)
-    {
-      makeRot1();
-      Matrix3 prec;
-      prec << e, 0, 0,
-              0, e, 0,
-              0, 0, 1;
-      return R1.transpose()*prec*R1;
-    }
-    
-    // return a covariance matrix for plane-plane
-    Matrix3 cov0(number_t e)
-    {
-      makeRot0();
-      Matrix3 cov;
-      cov  << 1, 0, 0,
-              0, 1, 0,
-              0, 0, e;
-      return R0.transpose()*cov*R0;
-    }
-    
-    // return a covariance matrix for plane-plane
-    Matrix3 cov1(number_t e)
-    {
-      makeRot1();
-      Matrix3 cov;
-      cov  << 1, 0, 0,
-              0, 1, 0,
-              0, 0, e;
-      return R1.transpose()*cov*R1;
-    }
-
-  };
-
-
-  // 3D rigid constraint
-  //    3 values for position wrt frame
-  //    3 values for normal wrt frame, not used here
-  // first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_ICP_API Edge_V_V_GICP : public  BaseBinaryEdge<3, EdgeGICP, VertexSE3, VertexSE3>
-  {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    Edge_V_V_GICP() : pl_pl(false) {}
-    Edge_V_V_GICP(const Edge_V_V_GICP* e);
-
-    // switch to go between point-plane and plane-plane
-    bool pl_pl;
-    Matrix3 cov0, cov1;
-
-    // I/O functions
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 3-vector
-    void computeError()
-    {
-      // from <ViewPoint> to <Point>
-      const VertexSE3 *vp0 = static_cast<const VertexSE3*>(_vertices[0]);
-      const VertexSE3 *vp1 = static_cast<const VertexSE3*>(_vertices[1]);
-
-      // get vp1 point into vp0 frame
-      // could be more efficient if we computed this transform just once
-      Vector3 p1;
-
-#if 0
-      if (_cnum >= 0 && 0)      // using global cache
-        {
-          if (_tainted[_cnum])  // set up transform
-            {
-              _transforms[_cnum] = vp0->estimate().inverse() * vp1->estimate();
-              _tainted[_cnum] = 0;
-              cout << _transforms[_cnum] << endl;
-            }
-          p1 = _transforms[_cnum].map(measurement().pos1); // do the transform
-        }
-      else
-#endif
-        {
-          p1 = vp1->estimate() * measurement().pos1;
-          p1 = vp0->estimate().inverse() * p1;
-        }
-
-      //      cout << endl << "Error computation; points are: " << endl;
-      //      cout << p0.transpose() << endl;
-      //      cout << p1.transpose() << endl;
-
-      // get their difference
-      // this is simple Euclidean distance, for now
-      _error = p1 - measurement().pos0;
-
-#if 0
-      cout << "vp0" << endl << vp0->estimate() << endl;
-      cout << "vp1" << endl << vp1->estimate() << endl;
-      cout << "e Jac Xj" << endl <<  _jacobianOplusXj << endl << endl;
-      cout << "e Jac Xi" << endl << _jacobianOplusXi << endl << endl;
-#endif
-
-      if (!pl_pl) return;
-
-      // re-define the information matrix
-      // topLeftCorner<3,3>() is the rotation()
-      const Matrix3 transform = ( vp0->estimate().inverse() *  vp1->estimate() ).matrix().topLeftCorner<3,3>();
-      information() = ( cov0 + transform * cov1 * transform.transpose() ).inverse();
-
-    }
-
-    // try analytic jacobians
-#ifdef GICP_ANALYTIC_JACOBIANS
-    virtual void linearizeOplus();
-#endif
-
-    // global derivative matrices
-    static Matrix3 dRidx;
-	static Matrix3 dRidy;
-	static Matrix3 dRidz; // differential quat matrices
-  };
-
-
-/**
- * \brief Stereo camera vertex, derived from SE3 class.
- * Note that we use the actual pose of the vertex as its parameterization, rather
- * than the transform from RW to camera coords.
- * Uses static vars for camera params, so there is a single camera setup.
- */
-  class G2O_TYPES_ICP_API VertexSCam : public VertexSE3
-    {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-        VertexSCam();
-
-      // I/O
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      // capture the update function to reset aux transforms
-      virtual void oplusImpl(const number_t* update)
-      {
-        VertexSE3::oplusImpl(update);
-        setAll();
-      }
-
-      // camera matrix and stereo baseline
-      static Matrix3 Kcam;
-      static number_t baseline;
-
-      // transformations
-      Eigen::Matrix<number_t,3,4,Eigen::ColMajor> w2n; // transform from world to node coordinates
-      Eigen::Matrix<number_t,3,4,Eigen::ColMajor> w2i; // transform from world to image coordinates
-
-      // Derivatives of the rotation matrix transpose wrt quaternion xyz, used for
-      // calculating Jacobian wrt pose of a projection.
-      Matrix3 dRdx, dRdy, dRdz;
-
-      // transforms
-      static void transformW2F(Eigen::Matrix<number_t,3,4,Eigen::ColMajor> &m,
-                               const Vector3 &trans,
-                               const Quaternion &qrot)
-        {
-          m.block<3,3>(0,0) = qrot.toRotationMatrix().transpose();
-          m.col(3).setZero();         // make sure there's no translation
-          Vector4 tt;
-          tt.head(3) = trans;
-          tt[3] = 1.0;
-          m.col(3) = -m*tt;
-        }
-
-      static void transformF2W(Eigen::Matrix<number_t,3,4,Eigen::ColMajor> &m,
-                               const Vector3 &trans,
-                               const Quaternion &qrot)
-        {
-          m.block<3,3>(0,0) = qrot.toRotationMatrix();
-          m.col(3) = trans;
-        }
-
-      // set up camera matrix
-      static void setKcam(number_t fx, number_t fy, number_t cx, number_t cy, number_t tx)
-      {
-        Kcam.setZero();
-        Kcam(0,0) = fx;
-        Kcam(1,1) = fy;
-        Kcam(0,2) = cx;
-        Kcam(1,2) = cy;
-        Kcam(2,2) = 1.0;
-        baseline = tx;
-      }
-
-      // set transform from world to cam coords
-      void setTransform()  {
-        w2n = estimate().inverse().matrix().block<3,4>(0, 0);
-        //transformW2F(w2n,estimate().translation(), estimate().rotation());
-      }
-
-      // Set up world-to-image projection matrix (w2i), assumes camera parameters
-      // are filled.
-      void setProjection() { w2i = Kcam * w2n; }
-
-      // sets angle derivatives
-      void setDr()
-      {
-        // inefficient, just for testing
-        // use simple multiplications and additions for production code in calculating dRdx,y,z
-        // for dS'*R', with dS the incremental change
-        dRdx = dRidx * w2n.block<3,3>(0,0);
-        dRdy = dRidy * w2n.block<3,3>(0,0);
-        dRdz = dRidz * w2n.block<3,3>(0,0);
-      }
-
-      // set all aux transforms
-      void setAll()
-      {
-        setTransform();
-        setProjection();
-        setDr();
-      }
-
-      // calculate stereo projection
-      void mapPoint(Vector3 &res, const Vector3 &pt3)
-      {
-        Vector4 pt;
-        pt.head<3>() = pt3;
-        pt(3) = cst(1.0);
-        Vector3 p1 = w2i * pt;
-        Vector3 p2 = w2n * pt;
-        Vector3 pb(baseline,0,0);
-
-        number_t invp1 = cst(1.0)/p1(2);
-        res.head<2>() = p1.head<2>()*invp1;
-
-        // right camera px
-        p2 = Kcam*(p2-pb);
-        res(2) = p2(0)/p2(2);
-      }
-
-      static Matrix3 dRidx;
-	  static Matrix3 dRidy;
-	  static Matrix3 dRidz;
-    };
-
-
-/**
- * \brief Point vertex, XYZ, is in types_sba
- */
-
-
-// stereo projection
-// first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_ICP_API Edge_XYZ_VSC : public  BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexSCam>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-      Edge_XYZ_VSC();
-
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 2-vector
-    void computeError()
-    {
-      // from <Point> to <Cam>
-      const VertexSBAPointXYZ *point = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-      VertexSCam *cam = static_cast<VertexSCam*>(_vertices[1]);
-      //cam->setAll();
-
-      // calculate the projection
-      Vector3 kp;
-      cam->mapPoint(kp,point->estimate());
-
-      // std::cout << std::endl << "CAM   " << cam->estimate() << std::endl;
-      // std::cout << "POINT " << pt.transpose() << std::endl;
-      // std::cout << "PROJ  " << p1.transpose() << std::endl;
-      // std::cout << "PROJ  " << p2.transpose() << std::endl;
-      // std::cout << "CPROJ " << kp.transpose() << std::endl;
-      // std::cout << "MEAS  " << _measurement.transpose() << std::endl;
-
-      // error, which is backwards from the normal observed - calculated
-      // _measurement is the measured projection
-      _error = kp - _measurement;
-    }
-#ifdef SCAM_ANALYTIC_JACOBIANS
-    // jacobian
-    virtual void linearizeOplus();
-#endif
-};
-
-
-
-} // end namespace
-
-#endif // TYPES_ICP
diff --git a/g2o/types/sba/CMakeLists.txt b/g2o/types/sba/CMakeLists.txt
deleted file mode 100644
index 04d784cb..00000000
--- a/g2o/types/sba/CMakeLists.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-add_library(types_sba ${G2O_LIB_TYPE}
-  types_sba.h     types_six_dof_expmap.h
-  types_sba.cpp   types_six_dof_expmap.cpp
-  g2o_types_sba_api.h
-)
-
-set_target_properties(types_sba PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_sba)
-if (APPLE)
-  set_target_properties(types_sba PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_sba core types_slam3d)
-
-install(TARGETS types_sba
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/sba)
diff --git a/g2o/types/sba/g2o_types_sba_api.h b/g2o/types/sba/g2o_types_sba_api.h
deleted file mode 100644
index 2c1e9808..00000000
--- a/g2o/types/sba/g2o_types_sba_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_SBA_API_H
-#define G2O_TYPES_SBA_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_sba_EXPORTS
-#define G2O_TYPES_SBA_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SBA_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SBA_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SBA_API
-#endif
-
-#endif // G2O_TYPES_SBA_API_H
diff --git a/g2o/types/sba/sbacam.h b/g2o/types/sba/sbacam.h
deleted file mode 100644
index 926e7332..00000000
--- a/g2o/types/sba/sbacam.h
+++ /dev/null
@@ -1,202 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 Kurt Konolige
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-///
-/// Basic types definitions for SBA translation to HChol
-///
-/// Camera nodes use camera pose in real world
-///   v3 position
-///   normalized quaternion rotation
-///
-/// Point nodes:
-///   v3 position
-///
-
-#ifndef G2O_SBACam_
-#define G2O_SBACam_
-
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-#include "g2o/stuff/macros.h"
-#include "g2o/stuff/misc.h"
-#include "g2o/types/slam3d/se3quat.h"
-#include "g2o_types_sba_api.h"
-
-namespace g2o {
-
-class G2O_TYPES_SBA_API SBACam : public SE3Quat {
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
- public:
-  // camera matrix and stereo baseline
-  Matrix3 Kcam;
-  number_t baseline;
-
-  // transformations
-  Eigen::Matrix<number_t, 3, 4> w2n;  // transform from world to node coordinates
-  Eigen::Matrix<number_t, 3, 4> w2i;  // transform from world to image coordinates
-
-  // Derivatives of the rotation matrix transpose wrt quaternion xyz, used for
-  // calculating Jacobian wrt pose of a projection.
-  Matrix3 dRdx, dRdy, dRdz;
-
-  // initialize an object
-  SBACam() {
-    setKcam(1, 1, cst(0.5), cst(0.5), 0);  // unit image projection
-  }
-
-  // set the object pose
-  SBACam(const Quaternion& r_, const Vector3& t_) : SE3Quat(r_, t_) {
-    Kcam.setZero();
-    setTransform();
-    setProjection();
-    setDr();
-  }
-
-  SBACam(const SE3Quat& p) : SE3Quat(p) {
-    Kcam.setZero();
-    setTransform();
-    setProjection();
-    setDr();
-  }
-
-  // update from the linear solution
-  // defined in se3quat
-  void update(const Vector6& update) {
-    // position update
-    _t += update.head(3);
-    // small quaternion update
-    Quaternion qr;
-    qr.vec() = update.segment<3>(3);
-    qr.w() = sqrt(cst(1.0) - qr.vec().squaredNorm());  // should always be positive
-    _r *= qr;                                          // post-multiply
-    _r.normalize();
-    setTransform();
-    setProjection();
-    setDr();
-  }
-
-  // transforms
-  static void transformW2F(Eigen::Matrix<number_t, 3, 4>& m, const Vector3& trans, const Quaternion& qrot) {
-    m.block<3, 3>(0, 0) = qrot.toRotationMatrix().transpose();
-    m.col(3).setZero();  // make sure there's no translation
-    Vector4 tt;
-    tt.head(3) = trans;
-    tt[3] = 1.0;
-    m.col(3) = -m * tt;
-  }
-
-  static void transformF2W(Eigen::Matrix<number_t, 3, 4>& m, const Vector3& trans, const Quaternion& qrot) {
-    m.block<3, 3>(0, 0) = qrot.toRotationMatrix();
-    m.col(3) = trans;
-  }
-
-  // set up camera matrix
-  void setKcam(number_t fx, number_t fy, number_t cx, number_t cy, number_t tx) {
-    Kcam.setZero();
-    Kcam(0, 0) = fx;
-    Kcam(1, 1) = fy;
-    Kcam(0, 2) = cx;
-    Kcam(1, 2) = cy;
-    Kcam(2, 2) = cst(1.0);
-    baseline = tx;
-    setTransform();
-    setProjection();
-    setDr();
-  }
-
-  // set transform from world to cam coords
-  void setTransform() { transformW2F(w2n, _t, _r); }
-
-  // Set up world-to-image projection matrix (w2i), assumes camera parameters
-  // are filled.
-  void setProjection() { w2i = Kcam * w2n; }
-
-  // sets angle derivatives
-  void setDr() {
-    // inefficient, just for testing
-    // use simple multiplications and additions for production code in calculating dRdx,y,z
-    Matrix3 dRidx, dRidy, dRidz;
-    dRidx << cst(0.0), cst(0.0), cst(0.0), cst(0.0), cst(0.0), cst(2.0), cst(0.0), cst(-2.0), cst(0.0);
-    dRidy << cst(0.0), cst(0.0), cst(-2.0), cst(0.0), cst(0.0), cst(0.0), cst(2.0), cst(0.0), cst(0.0);
-    dRidz << cst(0.0), cst(2.0), cst(0.0), cst(-2.0), cst(0.0), cst(0.0), cst(0.0), cst(0.0), cst(0.0);
-
-    // for dS'*R', with dS the incremental change
-    dRdx = dRidx * w2n.block<3, 3>(0, 0);
-    dRdy = dRidy * w2n.block<3, 3>(0, 0);
-    dRdz = dRidz * w2n.block<3, 3>(0, 0);
-  }
-};
-
-// human-readable SBACam object
-inline std::ostream& operator<<(std::ostream& out_str, const SBACam& cam) {
-  out_str << cam.translation().transpose() << std::endl;
-  out_str << cam.rotation().coeffs().transpose() << std::endl << std::endl;
-  out_str << cam.Kcam << std::endl << std::endl;
-  out_str << cam.w2n << std::endl << std::endl;
-  out_str << cam.w2i << std::endl << std::endl;
-  return out_str;
-};
-
-//
-// class for edges from vps to points with normals
-//
-class G2O_TYPES_SBA_API EdgeNormal {
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
- public:
-  // point position
-  Vector3 pos;
-
-  // unit normal
-  Vector3 normal;
-
-  // rotation matrix for normal
-  Matrix3 R;
-
-  // initialize an object
-  EdgeNormal() {
-    pos.setZero();
-    normal << 0, 0, 1;
-    makeRot();
-  }
-
-  // set up rotation matrix
-  void makeRot() {
-    Vector3 y;
-    y << 0, 1, 0;
-    R.row(2) = normal;
-    y = y - normal(1) * normal;
-    y.normalize();  // need to check if y is close to 0
-    R.row(1) = y;
-    R.row(0) = normal.cross(R.row(1));
-  }
-};
-
-}  // namespace g2o
-
-#endif  // SBACam
diff --git a/g2o/types/sba/types_sba.cpp b/g2o/types/sba/types_sba.cpp
deleted file mode 100644
index a0c0d7cc..00000000
--- a/g2o/types/sba/types_sba.cpp
+++ /dev/null
@@ -1,400 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 Kurt Konolige
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_sba.h"
-#include <iostream>
-
-#include "g2o/core/factory.h"
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  using namespace std;
-
-  G2O_REGISTER_TYPE_GROUP(sba);
-
-  G2O_REGISTER_TYPE(VERTEX_CAM, VertexCam);
-  G2O_REGISTER_TYPE(VERTEX_XYZ, VertexSBAPointXYZ);
-  G2O_REGISTER_TYPE(VERTEX_INTRINSICS, VertexIntrinsics);
-
-  G2O_REGISTER_TYPE(EDGE_PROJECT_P2MC, EdgeProjectP2MC);
-  G2O_REGISTER_TYPE(EDGE_PROJECT_P2SC, EdgeProjectP2SC);
-  G2O_REGISTER_TYPE(EDGE_CAM, EdgeSBACam);
-  G2O_REGISTER_TYPE(EDGE_SCALE, EdgeSBAScale);
-
-  // constructor
-  VertexIntrinsics::VertexIntrinsics()
-  {
-    _estimate << cst(1.), cst(1.), cst(.5), cst(.5), cst(.1);
-  }
-
-  bool VertexIntrinsics::read(std::istream& is) { return internal::readVector(is, _estimate); }
-
-  bool VertexIntrinsics::write(std::ostream& os) const { return internal::writeVector(os, estimate()); }
-
-  // constructor
-  VertexCam::VertexCam()
-  {
-  }
-
-  bool VertexCam::read(std::istream& is)
-  {
-    // first the position and orientation (vector3 and quaternion)
-    Vector3 t;
-    internal::readVector(is, t);
-    Quaternion r;
-    internal::readVector(is, r.coeffs());
-    r.normalize(); // recover nummeric precision
-
-    // form the camera object
-    SBACam cam(r,t);
-
-    // now fx, fy, cx, cy, baseline
-    number_t fx, fy, cx, cy, tx;
-
-    // try to read one value
-    is >>  fx;
-    if (is.good()) {
-      is >>  fy >> cx >> cy >> tx;
-      cam.setKcam(fx,fy,cx,cy,tx);
-    } else{
-      is.clear();
-      std::cerr << "cam not defined, using defaults" << std::endl;
-      cam.setKcam(300,300,320,320,cst(0.1));
-    }
-
-    setEstimate(cam);
-    return true;
-  }
-
-  bool VertexCam::write(std::ostream& os) const
-  {
-    const SBACam &cam = estimate();
-
-    // first the position and orientation (vector3 and quaternion)
-    internal::writeVector(os, cam.translation());
-    internal::writeVector(os, cam.rotation().coeffs());
-
-    // now fx, fy, cx, cy, baseline
-    os << cam.Kcam(0,0) << " ";
-    os << cam.Kcam(1,1) << " ";
-    os << cam.Kcam(0,2) << " ";
-    os << cam.Kcam(1,2) << " ";
-    os << cam.baseline << " ";
-    return os.good();
-  }
-
-  EdgeSBACam::EdgeSBACam() :
-    BaseBinaryEdge<6, SE3Quat, VertexCam, VertexCam>()
-  {
-  }
-
-  bool EdgeSBACam::read(std::istream& is)
-  {
-    Vector7 meas;
-    internal::readVector(is, meas);
-    setMeasurement(SE3Quat(meas));
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSBACam::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement().toVector());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSBACam::initialEstimate(const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* /*to_*/)
-  {
-    VertexCam* from = static_cast<VertexCam*>(_vertices[0]);
-    VertexCam* to = static_cast<VertexCam*>(_vertices[1]);
-    if (from_.count(from) > 0)
-      to->setEstimate((SE3Quat) from->estimate() * _measurement);
-    else
-      from->setEstimate((SE3Quat) to->estimate() * _inverseMeasurement);
-  }
-
-
-  VertexSBAPointXYZ::VertexSBAPointXYZ() : BaseVertex<3, Vector3>()
-  {
-  }
-
-  bool VertexSBAPointXYZ::read(std::istream& is)
-  {
-    return internal::readVector(is, _estimate);
-  }
-
-  bool VertexSBAPointXYZ::write(std::ostream& os) const
-  {
-    return internal::writeVector(os, estimate());
-  }
-
-  // point to camera projection, monocular
-  EdgeProjectP2MC::EdgeProjectP2MC() :
-  BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexCam>()
-  {
-    information().setIdentity();
-  }
-
-  bool EdgeProjectP2MC::read(std::istream& is)
-  {
-    // measured keypoint
-    internal::readVector(is, _measurement);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeProjectP2MC::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    writeInformationMatrix(os);
-    return os.good();
-  }
-
-  // point to camera projection, stereo
-  EdgeProjectP2SC::EdgeProjectP2SC() :
-    BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexCam>()
-  {
-  }
-
-  bool EdgeProjectP2SC::read(std::istream& is)
-  {
-    internal::readVector(is, _measurement);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeProjectP2SC::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    writeInformationMatrix(os);
-    return os.good();
-  }
-
-/**
- * \brief Jacobian for stereo projection
- */
-  void EdgeProjectP2SC::linearizeOplus()
-  {
-    VertexCam *vc = static_cast<VertexCam *>(_vertices[1]);
-    const SBACam &cam = vc->estimate();
-
-    VertexSBAPointXYZ *vp = static_cast<VertexSBAPointXYZ *>(_vertices[0]);
-    Vector4 pt, trans;
-    pt.head<3>() = vp->estimate();
-    pt(3) = 1.0;
-    trans.head<3>() = cam.translation();
-    trans(3) = 1.0;
-
-    // first get the world point in camera coords
-    Vector3 pc = cam.w2n * pt;
-
-    // Jacobians wrt camera parameters
-    // set d(quat-x) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    number_t px = pc(0);
-    number_t py = pc(1);
-    number_t pz = pc(2);
-    number_t ipz2 = 1.0/(pz*pz);
-    if (g2o_isnan(ipz2) ) {
-      std::cout << "[SetJac] infinite jac" << std::endl;
-      abort();
-    }
-
-    number_t ipz2fx = ipz2*cam.Kcam(0,0); // Fx
-    number_t ipz2fy = ipz2*cam.Kcam(1,1); // Fy
-    number_t b      = cam.baseline; // stereo baseline
-
-    // check for local vars
-    Vector3 pwt = (pt-trans).head<3>(); // transform translations, use differential rotation
-
-    // dx
-    Vector3 dp = cam.dRdx * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,3) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,3) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,3) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    // dy
-    dp = cam.dRdy * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,4) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,4) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,4) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    // dz
-    dp = cam.dRdz * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,5) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,5) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,5) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-
-    // set d(t) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    dp = -cam.w2n.col(0);        // dpc / dx
-    _jacobianOplusXj(0,0) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,0) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,0) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = -cam.w2n.col(1);        // dpc / dy
-    _jacobianOplusXj(0,1) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,1) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,1) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = -cam.w2n.col(2);        // dpc / dz
-    _jacobianOplusXj(0,2) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,2) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXj(2,2) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-
-    // Jacobians wrt point parameters
-    // set d(t) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    dp = cam.w2n.col(0); // dpc / dx
-    _jacobianOplusXi(0,0) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,0) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXi(2,0) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = cam.w2n.col(1); // dpc / dy
-    _jacobianOplusXi(0,1) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,1) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXi(2,1) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-    dp = cam.w2n.col(2); // dpc / dz
-    _jacobianOplusXi(0,2) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,2) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    _jacobianOplusXi(2,2) = (pz*dp(0) - (px-b)*dp(2))*ipz2fx; // right image px
-  }
-
-
-/**
- * \brief Jacobian for monocular projection
- */
-  void EdgeProjectP2MC::linearizeOplus()
-  {
-    VertexCam *vc = static_cast<VertexCam *>(_vertices[1]);
-    const SBACam &cam = vc->estimate();
-
-    VertexSBAPointXYZ *vp = static_cast<VertexSBAPointXYZ *>(_vertices[0]);
-    Vector4 pt, trans;
-    pt.head<3>() = vp->estimate();
-    pt(3) = 1.0;
-    trans.head<3>() = cam.translation();
-    trans(3) = 1.0;
-
-    // first get the world point in camera coords
-    Vector3 pc = cam.w2n * pt;
-
-    // Jacobians wrt camera parameters
-    // set d(quat-x) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    number_t px = pc(0);
-    number_t py = pc(1);
-    number_t pz = pc(2);
-    number_t ipz2 = 1.0/(pz*pz);
-    if (g2o_isnan(ipz2) ) {
-      std::cout << "[SetJac] infinite jac" << std::endl;
-      abort();
-    }
-
-    number_t ipz2fx = ipz2*cam.Kcam(0,0); // Fx
-    number_t ipz2fy = ipz2*cam.Kcam(1,1); // Fy
-
-    // check for local vars
-    Vector3 pwt = (pt-trans).head<3>(); // transform translations, use differential rotation
-
-    // dx
-    Vector3 dp = cam.dRdx * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,3) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,3) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    // dy
-    dp = cam.dRdy * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,4) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,4) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    // dz
-    dp = cam.dRdz * pwt; // dR'/dq * [pw - t]
-    _jacobianOplusXj(0,5) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,5) = (pz*dp(1) - py*dp(2))*ipz2fy;
-
-    // set d(t) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    dp = -cam.w2n.col(0);        // dpc / dx
-    _jacobianOplusXj(0,0) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,0) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    dp = -cam.w2n.col(1);        // dpc / dy
-    _jacobianOplusXj(0,1) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,1) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    dp = -cam.w2n.col(2);        // dpc / dz
-    _jacobianOplusXj(0,2) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXj(1,2) = (pz*dp(1) - py*dp(2))*ipz2fy;
-
-    // Jacobians wrt point parameters
-    // set d(t) values [ pz*dpx/dx - px*dpz/dx ] / pz^2
-    dp = cam.w2n.col(0); // dpc / dx
-    _jacobianOplusXi(0,0) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,0) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    dp = cam.w2n.col(1); // dpc / dy
-    _jacobianOplusXi(0,1) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,1) = (pz*dp(1) - py*dp(2))*ipz2fy;
-    dp = cam.w2n.col(2); // dpc / dz
-    _jacobianOplusXi(0,2) = (pz*dp(0) - px*dp(2))*ipz2fx;
-    _jacobianOplusXi(1,2) = (pz*dp(1) - py*dp(2))*ipz2fy;
-  }
-
-  // point to camera projection, stereo
-  EdgeSBAScale::EdgeSBAScale() :
-    BaseBinaryEdge<1, number_t, VertexCam, VertexCam>()
-  {
-  }
-
-  bool EdgeSBAScale::read(std::istream& is)
-  {
-    number_t meas;
-    is >> meas;
-    setMeasurement(meas);
-    information().setIdentity();
-    is >> information()(0,0);
-    return true;
-  }
-
-  bool EdgeSBAScale::write(std::ostream& os) const
-  {
-    os  << measurement() << " " << information()(0,0);
-    return os.good();
-  }
-
-  void EdgeSBAScale::initialEstimate(const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* /*to_*/)
-  {
-    VertexCam* v1 = dynamic_cast<VertexCam*>(_vertices[0]);
-    VertexCam* v2 = dynamic_cast<VertexCam*>(_vertices[1]);
-    //compute the translation vector of v1 w.r.t v2
-    if (from_.count(v1) == 1){
-      SE3Quat delta = (v1->estimate().inverse()*v2->estimate());
-      number_t norm =  delta.translation().norm();
-      number_t alpha = _measurement/norm;
-      delta.setTranslation(delta.translation()*alpha);
-      v2->setEstimate(v1->estimate()*delta);
-    } else {
-      SE3Quat delta = (v2->estimate().inverse()*v1->estimate());
-      number_t norm =  delta.translation().norm();
-      number_t alpha = _measurement/norm;
-      delta.setTranslation(delta.translation()*alpha);
-      v1->setEstimate(v2->estimate()*delta);
-    }
-  }
-
-  bool EdgeSBACam::setMeasurementFromState()
-  {
-    const VertexCam* v1 = dynamic_cast<const VertexCam*>(_vertices[0]);
-    const VertexCam* v2 = dynamic_cast<const VertexCam*>(_vertices[1]);
-    _measurement = (v1->estimate().inverse()*v2->estimate());
-    _inverseMeasurement = _measurement.inverse();
-    return true;
-  }
-
-} // end namespace
diff --git a/g2o/types/sba/types_sba.h b/g2o/types/sba/types_sba.h
deleted file mode 100644
index 7fed924b..00000000
--- a/g2o/types/sba/types_sba.h
+++ /dev/null
@@ -1,330 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 Kurt Konolige
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SBA_TYPES
-#define G2O_SBA_TYPES
-
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/core/base_multi_edge.h"
-#include "sbacam.h"
-#include <Eigen/Geometry>
-#include <iostream>
-
-#include "g2o_types_sba_api.h"
-
-namespace g2o {
-
-/**
- * \brief Vertex encoding the intrinsics of the camera fx, fy, cx, xy, baseline;
- */
-class G2O_TYPES_SBA_API VertexIntrinsics : public BaseVertex<4, Eigen::Matrix<number_t, 5, 1, Eigen::ColMajor> >
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    VertexIntrinsics();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    virtual void setToOriginImpl() {
-      _estimate << cst(1.), cst(1.), cst(0.5), cst(0.5), cst(0.1);
-    }
-
-    virtual void oplusImpl(const number_t* update)
-    {
-      _estimate.head<4>() += Vector4(update);
-    }
- };
-
-/**
- * \brief SBACam Vertex, (x,y,z,qw,qx,qy,qz)
- * the parameterization for the increments constructed is a 6d vector
- * (x,y,z,qx,qy,qz) (note that we leave out the w part of the quaternion.
- * qw is assumed to be positive, otherwise there is an ambiguity in qx,qy,qz as a rotation
- */
-  class G2O_TYPES_SBA_API VertexCam : public BaseVertex<6, SBACam>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    VertexCam();
-
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    virtual void setToOriginImpl() {
-      _estimate = SBACam();
-    }
-
-    virtual void setEstimate(const SBACam& cam){
-      BaseVertex<6, SBACam>::setEstimate(cam);
-      _estimate.setTransform();
-      _estimate.setProjection();
-      _estimate.setDr();
-    }
-
-    virtual void oplusImpl(const number_t* update)
-    {
-      Eigen::Map<const Vector6> v(update);
-      _estimate.update(v);
-      _estimate.setTransform();
-      _estimate.setProjection();
-      _estimate.setDr();
-    }
-
-
-    virtual bool setEstimateDataImpl(const number_t* est){
-      Eigen::Map <const Vector7> v(est);
-      _estimate.fromVector(v);
-      return true;
-    }
-
-    virtual bool getEstimateData(number_t* est) const{
-      Eigen::Map <Vector7> v(est);
-      v = estimate().toVector();
-      return true;
-    }
-
-    virtual int estimateDimension() const {
-      return 7;
-    }
-
-    virtual bool setMinimalEstimateDataImpl(const number_t* est){
-      Eigen::Map<const Vector6> v(est);
-      _estimate.fromMinimalVector(v);
-      return true;
-    }
-
-    virtual bool getMinimalEstimateData(number_t* est) const{
-      Eigen::Map<Vector6> v(est);
-      v = _estimate.toMinimalVector();
-      return true;
-    }
-
-    virtual int minimalEstimateDimension() const {
-      return 6;
-    }
- };
-
-/**
- * \brief Point vertex, XYZ
- */
- class G2O_TYPES_SBA_API VertexSBAPointXYZ : public BaseVertex<3, Vector3>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    VertexSBAPointXYZ();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    virtual void setToOriginImpl() {
-      _estimate.fill(0);
-    }
-
-    virtual void oplusImpl(const number_t* update)
-    {
-      Eigen::Map<const Vector3> v(update);
-      _estimate += v;
-    }
-};
-
-
-// monocular projection
-// first two args are the measurement type, second two the connection classes
- class G2O_TYPES_SBA_API EdgeProjectP2MC : public  BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexCam>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeProjectP2MC();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 2-vector
-    void computeError()
-    {
-      // from <Point> to <Cam>
-      const VertexSBAPointXYZ *point = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-      const VertexCam *cam = static_cast<const VertexCam*>(_vertices[1]);
-
-      // calculate the projection
-      const Vector3 &pt = point->estimate();
-      Vector4 ppt(pt(0),pt(1),pt(2),1);
-      Vector3 p = cam->estimate().w2i * ppt;
-      Vector2 perr;
-      perr = p.head<2>()/p(2);
-      //      std::cout << std::endl << "CAM   " << cam->estimate() << std::endl;
-      //      std::cout << "POINT " << pt.transpose() << std::endl;
-      //      std::cout << "PROJ  " << p.transpose() << std::endl;
-      //      std::cout << "CPROJ " << perr.transpose() << std::endl;
-      //      std::cout << "MEAS  " << _measurement.transpose() << std::endl;
-
-      // error, which is backwards from the normal observed - calculated
-      // _measurement is the measured projection
-      _error = perr - _measurement;
-      // std::cerr << _error.x() << " " << _error.y() <<  " " << chi2() << std::endl;
-    }
-
-    // jacobian
-    virtual void linearizeOplus();
-};
-
-// stereo projection
-// first two args are the measurement type, second two the connection classes
- class G2O_TYPES_SBA_API EdgeProjectP2SC : public  BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexCam>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeProjectP2SC();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 2-vector
-    void computeError()
-    {
-      // from <Point> to <Cam>
-      const VertexSBAPointXYZ *point = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-      VertexCam *cam = static_cast<VertexCam*>(_vertices[1]);
-
-      // calculate the projection
-      Vector3 kp;
-      Vector4 pt;
-      pt.head<3>() = point->estimate();
-      pt(3) = 1;
-      const SBACam& nd = cam->estimate();
-      // these should be already ok
-      /* nd.setTransform(); */
-      /* nd.setProjection(); */
-      /* nd.setDr(); */
-
-      Vector3 p1 = nd.w2i * pt;
-      Vector3 p2 = nd.w2n * pt;
-      Vector3 pb(nd.baseline,0,0);
-
-      number_t invp1 = cst(1.0)/p1(2);
-      kp.head<2>() = p1.head<2>()*invp1;
-
-      // right camera px
-      p2 = nd.Kcam*(p2-pb);
-      kp(2) = p2(0)/p2(2);
-
-      // std::cout << std::endl << "CAM   " << cam->estimate() << std::endl;
-      // std::cout << "POINT " << pt.transpose() << std::endl;
-      // std::cout << "PROJ  " << p1.transpose() << std::endl;
-      // std::cout << "PROJ  " << p2.transpose() << std::endl;
-      // std::cout << "CPROJ " << kp.transpose() << std::endl;
-      // std::cout << "MEAS  " << _measurement.transpose() << std::endl;
-
-      // error, which is backwards from the normal observed - calculated
-      // _measurement is the measured projection
-      _error = kp - _measurement;
-    }
-
-    // jacobian
-    virtual void linearizeOplus();
-
-};
-
-/**
- * \brief 3D edge between two SBAcam
- */
- class G2O_TYPES_SBA_API EdgeSBACam : public BaseBinaryEdge<6, SE3Quat, VertexCam, VertexCam>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    EdgeSBACam();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-    void computeError()
-    {
-      const VertexCam* v1 = dynamic_cast<const VertexCam*>(_vertices[0]);
-      const VertexCam* v2 = dynamic_cast<const VertexCam*>(_vertices[1]);
-      SE3Quat delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
-      _error[0]=delta.translation().x();
-      _error[1]=delta.translation().y();
-      _error[2]=delta.translation().z();
-      _error[3]=delta.rotation().x();
-      _error[4]=delta.rotation().y();
-      _error[5]=delta.rotation().z();
-    }
-
-    virtual void setMeasurement(const SE3Quat& meas){
-      _measurement=meas;
-      _inverseMeasurement=meas.inverse();
-    }
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return cst(1.);}
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    virtual bool setMeasurementData(const number_t* d){
-      Eigen::Map<const Vector7> v(d);
-      _measurement.fromVector(v);
-      _inverseMeasurement = _measurement.inverse();
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const{
-      Eigen::Map<Vector7> v(d);
-      v = _measurement.toVector();
-      return true;
-    }
-
-    virtual int measurementDimension() const {return 7;}
-
-    virtual bool setMeasurementFromState();
-
-  protected:
-    SE3Quat _inverseMeasurement;
-};
-
-
-/**
- * \brief edge between two SBAcam that specifies the distance between them
- */
- class G2O_TYPES_SBA_API EdgeSBAScale : public BaseBinaryEdge<1, number_t, VertexCam, VertexCam>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSBAScale();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-    void computeError()
-    {
-      const VertexCam* v1 = dynamic_cast<const VertexCam*>(_vertices[0]);
-      const VertexCam* v2 = dynamic_cast<const VertexCam*>(_vertices[1]);
-      Vector3 dt=v2->estimate().translation()-v1->estimate().translation();
-      _error[0] = _measurement - dt.norm();
-    }
-    virtual void setMeasurement(const number_t& m){
-      _measurement = m;
-    }
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return cst(1.);}
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* to_);
-};
-
-
-
-} // end namespace
-
-#endif // SBA_TYPES
diff --git a/g2o/types/sba/types_six_dof_expmap.cpp b/g2o/types/sba/types_six_dof_expmap.cpp
deleted file mode 100644
index 8f1fbaf7..00000000
--- a/g2o/types/sba/types_six_dof_expmap.cpp
+++ /dev/null
@@ -1,497 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_six_dof_expmap.h"
-
-#include "g2o/core/factory.h"
-#include "g2o/stuff/macros.h"
-
-#include "g2o/types/slam3d/se3_ops.h"
-
-namespace g2o {
-
-using namespace std;
-using namespace Eigen;
-
-G2O_REGISTER_TYPE_GROUP(expmap);
-G2O_REGISTER_TYPE(VERTEX_SE3:EXPMAP, VertexSE3Expmap);
-G2O_REGISTER_TYPE(EDGE_SE3:EXPMAP, EdgeSE3Expmap);
-G2O_REGISTER_TYPE(EDGE_PROJECT_XYZ2UV:EXPMAP, EdgeProjectXYZ2UV);
-G2O_REGISTER_TYPE(EDGE_PROJECT_XYZ2UVU:EXPMAP, EdgeProjectXYZ2UVU);
-G2O_REGISTER_TYPE(EDGE_SE3_PROJECT_XYZ:EXPMAP, EdgeSE3ProjectXYZ);
-G2O_REGISTER_TYPE(EDGE_SE3_PROJECT_XYZONLYPOSE:EXPMAP, EdgeSE3ProjectXYZOnlyPose);
-G2O_REGISTER_TYPE(EDGE_STEREO_SE3_PROJECT_XYZ:EXPMAP, EdgeStereoSE3ProjectXYZ);
-G2O_REGISTER_TYPE(EDGE_STEREO_SE3_PROJECT_XYZONLYPOSE:EXPMAP, EdgeStereoSE3ProjectXYZOnlyPose);
-G2O_REGISTER_TYPE(PARAMS_CAMERAPARAMETERS, CameraParameters);
-
-CameraParameters
-::CameraParameters()
-  : focal_length(1.),
-    principle_point(Vector2(0., 0.)),
-    baseline(0.5)  {
-}
-
-inline Vector3 invert_depth(const Vector3 & x){
-  Vector2 aux = x.head<2>();
-  return unproject(aux)/x[2];
-}
-
-Vector2  CameraParameters::cam_map(const Vector3 & trans_xyz) const {
-  Vector2 proj = project(trans_xyz);
-  Vector2 res;
-  res[0] = proj[0]*focal_length + principle_point[0];
-  res[1] = proj[1]*focal_length + principle_point[1];
-  return res;
-}
-
-Vector3 CameraParameters::stereocam_uvu_map(const Vector3 & trans_xyz) const {
-  Vector2 uv_left = cam_map(trans_xyz);
-  number_t proj_x_right = (trans_xyz[0]-baseline)/trans_xyz[2];
-  number_t u_right = proj_x_right*focal_length + principle_point[0];
-  return Vector3(uv_left[0],uv_left[1],u_right);
-}
-
-
-VertexSE3Expmap::VertexSE3Expmap() : BaseVertex<6, SE3Quat>() {
-}
-
-bool VertexSE3Expmap::read(std::istream& is) {
-  Vector7 est;
-  internal::readVector(is, est);
-  setEstimate(SE3Quat(est).inverse());
-  return true;
-}
-
-bool VertexSE3Expmap::write(std::ostream& os) const {
-  return internal::writeVector(os, estimate().inverse().toVector());
-}
-
-EdgeSE3Expmap::EdgeSE3Expmap() :
-  BaseBinaryEdge<6, SE3Quat, VertexSE3Expmap, VertexSE3Expmap>() {
-}
-
-bool EdgeSE3Expmap::read(std::istream& is)  {
-  Vector7 meas;
-  internal::readVector(is, meas);
-  setMeasurement(SE3Quat(meas).inverse());
-  return readInformationMatrix(is);
-}
-
-bool EdgeSE3Expmap::write(std::ostream& os) const {
-  internal::writeVector(os, measurement().inverse().toVector());
-  return writeInformationMatrix(os);
-}
-
-EdgeProjectXYZ2UV::EdgeProjectXYZ2UV() : BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSE3Expmap>() {
-  _cam = 0;
-  resizeParameters(1);
-  installParameter(_cam, 0);
-}
-
-bool EdgeProjectPSI2UV::write(std::ostream& os) const  {
-  writeParamIds(os);
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-bool EdgeProjectPSI2UV::read(std::istream& is) {
-  readParamIds(is);
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-void EdgeProjectPSI2UV::computeError(){
-  const VertexSBAPointXYZ * psi = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-  const VertexSE3Expmap * T_p_from_world = static_cast<const VertexSE3Expmap*>(_vertices[1]);
-  const VertexSE3Expmap * T_anchor_from_world = static_cast<const VertexSE3Expmap*>(_vertices[2]);
-  const CameraParameters * cam = static_cast<const CameraParameters *>(parameter(0));
-
-  Vector2 obs(_measurement);
-  _error = obs - cam->cam_map(T_p_from_world->estimate()
-        *T_anchor_from_world->estimate().inverse()
-        *invert_depth(psi->estimate()));
-}
-
-inline Matrix<number_t,2,3,Eigen::ColMajor> d_proj_d_y(const number_t & f, const Vector3 & xyz){
-  number_t z_sq = xyz[2]*xyz[2];
-  Matrix<number_t,2,3,Eigen::ColMajor> J;
-  J << f/xyz[2], 0,           -(f*xyz[0])/z_sq,
-      0,           f/xyz[2], -(f*xyz[1])/z_sq;
-  return J;
-}
-
-inline Matrix<number_t,3,6,Eigen::ColMajor> d_expy_d_y(const Vector3 & y){
-  Matrix<number_t,3,6,Eigen::ColMajor> J;
-  J.topLeftCorner<3,3>() = -skew(y);
-  J.bottomRightCorner<3,3>().setIdentity();
-
-  return J;
-}
-
-inline Matrix3 d_Tinvpsi_d_psi(const SE3Quat & T, const Vector3 & psi){
-  Matrix3 R = T.rotation().toRotationMatrix();
-  Vector3 x = invert_depth(psi);
-  Vector3 r1 = R.col(0);
-  Vector3 r2 = R.col(1);
-  Matrix3 J;
-  J.col(0) = r1;
-  J.col(1) = r2;
-  J.col(2) = -R*x;
-  J*=1./psi.z();
-  return J;
-}
-
-void EdgeProjectPSI2UV::linearizeOplus(){
-  VertexSBAPointXYZ* vpoint = static_cast<VertexSBAPointXYZ*>(_vertices[0]);
-  Vector3 psi_a = vpoint->estimate();
-  VertexSE3Expmap * vpose = static_cast<VertexSE3Expmap *>(_vertices[1]);
-  SE3Quat T_cw = vpose->estimate();
-  VertexSE3Expmap * vanchor = static_cast<VertexSE3Expmap *>(_vertices[2]);
-  const CameraParameters * cam
-      = static_cast<const CameraParameters *>(parameter(0));
-
-  SE3Quat A_aw = vanchor->estimate();
-  SE3Quat T_ca = T_cw*A_aw.inverse();
-  Vector3 x_a = invert_depth(psi_a);
-  Vector3 y = T_ca*x_a;
-  Matrix<number_t,2,3,Eigen::ColMajor> Jcam
-      = d_proj_d_y(cam->focal_length, y);
-  _jacobianOplus[0] = -Jcam*d_Tinvpsi_d_psi(T_ca, psi_a);
-  _jacobianOplus[1] = -Jcam*d_expy_d_y(y);
-  _jacobianOplus[2] = Jcam*T_ca.rotation().toRotationMatrix()*d_expy_d_y(x_a);
-}
-
-
-
-EdgeProjectXYZ2UVU::EdgeProjectXYZ2UVU() : BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexSE3Expmap>()
-{
-  _cam = 0;
-  resizeParameters(1);
-  installParameter(_cam, 0);
-}
-
-bool EdgeProjectXYZ2UV::read(std::istream& is){
-  readParamIds(is);
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeProjectXYZ2UV::write(std::ostream& os) const {
-  writeParamIds(os);
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-void EdgeSE3Expmap::linearizeOplus() {
-  VertexSE3Expmap * vi = static_cast<VertexSE3Expmap *>(_vertices[0]);
-  SE3Quat Ti(vi->estimate());
-
-  VertexSE3Expmap * vj = static_cast<VertexSE3Expmap *>(_vertices[1]);
-  SE3Quat Tj(vj->estimate());
-
-  const SE3Quat & Tij = _measurement;
-  SE3Quat invTij = Tij.inverse();
-
-  SE3Quat invTj_Tij = Tj.inverse()*Tij;
-  SE3Quat infTi_invTij = Ti.inverse()*invTij;
-
-  _jacobianOplusXi = invTj_Tij.adj();
-  _jacobianOplusXj = -infTi_invTij.adj();
-}
-
-void EdgeProjectXYZ2UV::linearizeOplus() {
-  VertexSE3Expmap * vj = static_cast<VertexSE3Expmap *>(_vertices[1]);
-  SE3Quat T(vj->estimate());
-  VertexSBAPointXYZ* vi = static_cast<VertexSBAPointXYZ*>(_vertices[0]);
-  Vector3 xyz = vi->estimate();
-  Vector3 xyz_trans = T.map(xyz);
-
-  number_t x = xyz_trans[0];
-  number_t y = xyz_trans[1];
-  number_t z = xyz_trans[2];
-  number_t z_2 = z*z;
-
-  const CameraParameters * cam = static_cast<const CameraParameters *>(parameter(0));
-
-  Matrix<number_t,2,3,Eigen::ColMajor> tmp;
-  tmp(0,0) = cam->focal_length;
-  tmp(0,1) = 0;
-  tmp(0,2) = -x/z*cam->focal_length;
-
-  tmp(1,0) = 0;
-  tmp(1,1) = cam->focal_length;
-  tmp(1,2) = -y/z*cam->focal_length;
-
-  _jacobianOplusXi =  -1./z * tmp * T.rotation().toRotationMatrix();
-
-  _jacobianOplusXj(0,0) =  x*y/z_2 *cam->focal_length;
-  _jacobianOplusXj(0,1) = -(1+(x*x/z_2)) *cam->focal_length;
-  _jacobianOplusXj(0,2) = y/z *cam->focal_length;
-  _jacobianOplusXj(0,3) = -1./z *cam->focal_length;
-  _jacobianOplusXj(0,4) = 0;
-  _jacobianOplusXj(0,5) = x/z_2 *cam->focal_length;
-
-  _jacobianOplusXj(1,0) = (1+y*y/z_2) *cam->focal_length;
-  _jacobianOplusXj(1,1) = -x*y/z_2 *cam->focal_length;
-  _jacobianOplusXj(1,2) = -x/z *cam->focal_length;
-  _jacobianOplusXj(1,3) = 0;
-  _jacobianOplusXj(1,4) = -1./z *cam->focal_length;
-  _jacobianOplusXj(1,5) = y/z_2 *cam->focal_length;
-}
-
-bool EdgeProjectXYZ2UVU::read(std::istream &is) {
-  readParamIds(is);
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeProjectXYZ2UVU::write(std::ostream &os) const {
-  writeParamIds(os);
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-EdgeSE3ProjectXYZ::EdgeSE3ProjectXYZ() : BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSE3Expmap>() {}
-
-bool EdgeSE3ProjectXYZ::read(std::istream &is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeSE3ProjectXYZ::write(std::ostream &os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-void EdgeSE3ProjectXYZ::linearizeOplus() {
-  VertexSE3Expmap *vj = static_cast<VertexSE3Expmap *>(_vertices[1]);
-  SE3Quat T(vj->estimate());
-  VertexSBAPointXYZ *vi = static_cast<VertexSBAPointXYZ *>(_vertices[0]);
-  Vector3 xyz = vi->estimate();
-  Vector3 xyz_trans = T.map(xyz);
-
-  number_t x = xyz_trans[0];
-  number_t y = xyz_trans[1];
-  number_t z = xyz_trans[2];
-  number_t z_2 = z * z;
-
-  Matrix<number_t, 2, 3> tmp;
-  tmp(0, 0) = fx;
-  tmp(0, 1) = 0;
-  tmp(0, 2) = -x / z * fx;
-
-  tmp(1, 0) = 0;
-  tmp(1, 1) = fy;
-  tmp(1, 2) = -y / z * fy;
-
-  _jacobianOplusXi = -1. / z * tmp * T.rotation().toRotationMatrix();
-
-  _jacobianOplusXj(0, 0) = x * y / z_2 * fx;
-  _jacobianOplusXj(0, 1) = -(1 + (x * x / z_2)) * fx;
-  _jacobianOplusXj(0, 2) = y / z * fx;
-  _jacobianOplusXj(0, 3) = -1. / z * fx;
-  _jacobianOplusXj(0, 4) = 0;
-  _jacobianOplusXj(0, 5) = x / z_2 * fx;
-
-  _jacobianOplusXj(1, 0) = (1 + y * y / z_2) * fy;
-  _jacobianOplusXj(1, 1) = -x * y / z_2 * fy;
-  _jacobianOplusXj(1, 2) = -x / z * fy;
-  _jacobianOplusXj(1, 3) = 0;
-  _jacobianOplusXj(1, 4) = -1. / z * fy;
-  _jacobianOplusXj(1, 5) = y / z_2 * fy;
-}
-
-Vector2 EdgeSE3ProjectXYZ::cam_project(const Vector3 &trans_xyz) const {
-  Vector2 proj = project(trans_xyz);
-  Vector2 res;
-  res[0] = proj[0] * fx + cx;
-  res[1] = proj[1] * fy + cy;
-  return res;
-}
-
-Vector3 EdgeStereoSE3ProjectXYZ::cam_project(const Vector3 &trans_xyz, const float &bf) const {
-  const number_t invz = 1.0f / trans_xyz[2];
-  Vector3 res;
-  res[0] = trans_xyz[0] * invz * fx + cx;
-  res[1] = trans_xyz[1] * invz * fy + cy;
-  res[2] = res[0] - bf * invz;
-  return res;
-}
-
-EdgeStereoSE3ProjectXYZ::EdgeStereoSE3ProjectXYZ() : BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexSE3Expmap>() {
-}
-
-bool EdgeStereoSE3ProjectXYZ::read(std::istream &is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeStereoSE3ProjectXYZ::write(std::ostream &os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-void EdgeStereoSE3ProjectXYZ::linearizeOplus() {
-  VertexSE3Expmap *vj = static_cast<VertexSE3Expmap *>(_vertices[1]);
-  SE3Quat T(vj->estimate());
-  VertexSBAPointXYZ *vi = static_cast<VertexSBAPointXYZ *>(_vertices[0]);
-  Vector3 xyz = vi->estimate();
-  Vector3 xyz_trans = T.map(xyz);
-
-  const Matrix3 R = T.rotation().toRotationMatrix();
-
-  number_t x = xyz_trans[0];
-  number_t y = xyz_trans[1];
-  number_t z = xyz_trans[2];
-  number_t z_2 = z * z;
-
-  _jacobianOplusXi(0, 0) = -fx * R(0, 0) / z + fx * x * R(2, 0) / z_2;
-  _jacobianOplusXi(0, 1) = -fx * R(0, 1) / z + fx * x * R(2, 1) / z_2;
-  _jacobianOplusXi(0, 2) = -fx * R(0, 2) / z + fx * x * R(2, 2) / z_2;
-
-  _jacobianOplusXi(1, 0) = -fy * R(1, 0) / z + fy * y * R(2, 0) / z_2;
-  _jacobianOplusXi(1, 1) = -fy * R(1, 1) / z + fy * y * R(2, 1) / z_2;
-  _jacobianOplusXi(1, 2) = -fy * R(1, 2) / z + fy * y * R(2, 2) / z_2;
-
-  _jacobianOplusXi(2, 0) = _jacobianOplusXi(0, 0) - bf * R(2, 0) / z_2;
-  _jacobianOplusXi(2, 1) = _jacobianOplusXi(0, 1) - bf * R(2, 1) / z_2;
-  _jacobianOplusXi(2, 2) = _jacobianOplusXi(0, 2) - bf * R(2, 2) / z_2;
-
-  _jacobianOplusXj(0, 0) = x * y / z_2 * fx;
-  _jacobianOplusXj(0, 1) = -(1 + (x * x / z_2)) * fx;
-  _jacobianOplusXj(0, 2) = y / z * fx;
-  _jacobianOplusXj(0, 3) = -1. / z * fx;
-  _jacobianOplusXj(0, 4) = 0;
-  _jacobianOplusXj(0, 5) = x / z_2 * fx;
-
-  _jacobianOplusXj(1, 0) = (1 + y * y / z_2) * fy;
-  _jacobianOplusXj(1, 1) = -x * y / z_2 * fy;
-  _jacobianOplusXj(1, 2) = -x / z * fy;
-  _jacobianOplusXj(1, 3) = 0;
-  _jacobianOplusXj(1, 4) = -1. / z * fy;
-  _jacobianOplusXj(1, 5) = y / z_2 * fy;
-
-  _jacobianOplusXj(2, 0) = _jacobianOplusXj(0, 0) - bf * y / z_2;
-  _jacobianOplusXj(2, 1) = _jacobianOplusXj(0, 1) + bf * x / z_2;
-  _jacobianOplusXj(2, 2) = _jacobianOplusXj(0, 2);
-  _jacobianOplusXj(2, 3) = _jacobianOplusXj(0, 3);
-  _jacobianOplusXj(2, 4) = 0;
-  _jacobianOplusXj(2, 5) = _jacobianOplusXj(0, 5) - bf / z_2;
-}
-
-bool EdgeSE3ProjectXYZOnlyPose::read(std::istream &is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeSE3ProjectXYZOnlyPose::write(std::ostream &os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-void EdgeSE3ProjectXYZOnlyPose::linearizeOplus() {
-  VertexSE3Expmap *vi = static_cast<VertexSE3Expmap *>(_vertices[0]);
-  Vector3 xyz_trans = vi->estimate().map(Xw);
-
-  number_t x = xyz_trans[0];
-  number_t y = xyz_trans[1];
-  number_t invz = 1.0 / xyz_trans[2];
-  number_t invz_2 = invz * invz;
-
-  _jacobianOplusXi(0, 0) = x * y * invz_2 * fx;
-  _jacobianOplusXi(0, 1) = -(1 + (x * x * invz_2)) * fx;
-  _jacobianOplusXi(0, 2) = y * invz * fx;
-  _jacobianOplusXi(0, 3) = -invz * fx;
-  _jacobianOplusXi(0, 4) = 0;
-  _jacobianOplusXi(0, 5) = x * invz_2 * fx;
-
-  _jacobianOplusXi(1, 0) = (1 + y * y * invz_2) * fy;
-  _jacobianOplusXi(1, 1) = -x * y * invz_2 * fy;
-  _jacobianOplusXi(1, 2) = -x * invz * fy;
-  _jacobianOplusXi(1, 3) = 0;
-  _jacobianOplusXi(1, 4) = -invz * fy;
-  _jacobianOplusXi(1, 5) = y * invz_2 * fy;
-}
-
-Vector2 EdgeSE3ProjectXYZOnlyPose::cam_project(const Vector3 &trans_xyz) const {
-  Vector2 proj = project(trans_xyz);
-  Vector2 res;
-  res[0] = proj[0] * fx + cx;
-  res[1] = proj[1] * fy + cy;
-  return res;
-}
-
-Vector3 EdgeStereoSE3ProjectXYZOnlyPose::cam_project(const Vector3 &trans_xyz) const {
-  const float invz = 1.0f / trans_xyz[2];
-  Vector3 res;
-  res[0] = trans_xyz[0] * invz * fx + cx;
-  res[1] = trans_xyz[1] * invz * fy + cy;
-  res[2] = res[0] - bf * invz;
-  return res;
-}
-
-bool EdgeStereoSE3ProjectXYZOnlyPose::read(std::istream &is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeStereoSE3ProjectXYZOnlyPose::write(std::ostream &os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-void EdgeStereoSE3ProjectXYZOnlyPose::linearizeOplus() {
-  VertexSE3Expmap *vi = static_cast<VertexSE3Expmap *>(_vertices[0]);
-  Vector3 xyz_trans = vi->estimate().map(Xw);
-
-  number_t x = xyz_trans[0];
-  number_t y = xyz_trans[1];
-  number_t invz = 1.0 / xyz_trans[2];
-  number_t invz_2 = invz * invz;
-
-  _jacobianOplusXi(0, 0) = x * y * invz_2 * fx;
-  _jacobianOplusXi(0, 1) = -(1 + (x * x * invz_2)) * fx;
-  _jacobianOplusXi(0, 2) = y * invz * fx;
-  _jacobianOplusXi(0, 3) = -invz * fx;
-  _jacobianOplusXi(0, 4) = 0;
-  _jacobianOplusXi(0, 5) = x * invz_2 * fx;
-
-  _jacobianOplusXi(1, 0) = (1 + y * y * invz_2) * fy;
-  _jacobianOplusXi(1, 1) = -x * y * invz_2 * fy;
-  _jacobianOplusXi(1, 2) = -x * invz * fy;
-  _jacobianOplusXi(1, 3) = 0;
-  _jacobianOplusXi(1, 4) = -invz * fy;
-  _jacobianOplusXi(1, 5) = y * invz_2 * fy;
-
-  _jacobianOplusXi(2, 0) = _jacobianOplusXi(0, 0) - bf * y * invz_2;
-  _jacobianOplusXi(2, 1) = _jacobianOplusXi(0, 1) + bf * x * invz_2;
-  _jacobianOplusXi(2, 2) = _jacobianOplusXi(0, 2);
-  _jacobianOplusXi(2, 3) = _jacobianOplusXi(0, 3);
-  _jacobianOplusXi(2, 4) = 0;
-  _jacobianOplusXi(2, 5) = _jacobianOplusXi(0, 5) - bf * invz_2;
-}
-
-} // end namespace
diff --git a/g2o/types/sba/types_six_dof_expmap.h b/g2o/types/sba/types_six_dof_expmap.h
deleted file mode 100644
index 6135b96f..00000000
--- a/g2o/types/sba/types_six_dof_expmap.h
+++ /dev/null
@@ -1,322 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SIX_DOF_TYPES_EXPMAP
-#define G2O_SIX_DOF_TYPES_EXPMAP
-
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/core/base_unary_edge.h"
-#include "g2o/types/slam3d/se3_ops.h"
-#include "types_sba.h"
-#include <Eigen/Geometry>
-
-namespace g2o {
-namespace types_six_dof_expmap {
-void init();
-}
-
-class G2O_TYPES_SBA_API CameraParameters : public g2o::Parameter
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    CameraParameters();
-
-    CameraParameters(number_t focal_length,
-        const Vector2 & principle_point,
-        number_t baseline)
-      : focal_length(focal_length),
-      principle_point(principle_point),
-      baseline(baseline){}
-
-    Vector2 cam_map (const Vector3 & trans_xyz) const;
-
-    Vector3 stereocam_uvu_map (const Vector3 & trans_xyz) const;
-
-    virtual bool read (std::istream& is){
-      is >> focal_length;
-      is >> principle_point[0];
-      is >> principle_point[1];
-      is >> baseline;
-      return true;
-    }
-
-    virtual bool write (std::ostream& os) const {
-      os << focal_length << " ";
-      os << principle_point.x() << " ";
-      os << principle_point.y() << " ";
-      os << baseline << " ";
-      return true;
-    }
-
-    number_t focal_length;
-    Vector2 principle_point;
-    number_t baseline;
-};
-
-/**
- * \brief SE3 Vertex parameterized internally with a transformation matrix
- and externally with its exponential map
- */
-class G2O_TYPES_SBA_API VertexSE3Expmap : public BaseVertex<6, SE3Quat>{
-public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-  VertexSE3Expmap();
-
-  bool read(std::istream& is);
-
-  bool write(std::ostream& os) const;
-
-  virtual void setToOriginImpl() {
-    _estimate = SE3Quat();
-  }
-
-  virtual void oplusImpl(const number_t* update_)  {
-    Eigen::Map<const Vector6> update(update_);
-    setEstimate(SE3Quat::exp(update)*estimate());
-  }
-};
-
-
-/**
- * \brief 6D edge between two Vertex6
- */
-class G2O_TYPES_SBA_API EdgeSE3Expmap : public BaseBinaryEdge<6, SE3Quat, VertexSE3Expmap, VertexSE3Expmap>{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE3Expmap();
-
-    bool read(std::istream& is);
-
-    bool write(std::ostream& os) const;
-
-    void computeError()  {
-      const VertexSE3Expmap* v1 = static_cast<const VertexSE3Expmap*>(_vertices[0]);
-      const VertexSE3Expmap* v2 = static_cast<const VertexSE3Expmap*>(_vertices[1]);
-
-      SE3Quat C(_measurement);
-      SE3Quat error_= v2->estimate().inverse()*C*v1->estimate();
-      _error = error_.log();
-    }
-
-    virtual void linearizeOplus();
-};
-
-
-class G2O_TYPES_SBA_API EdgeProjectXYZ2UV : public  BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSE3Expmap>{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-    EdgeProjectXYZ2UV();
-
-    bool read(std::istream& is);
-
-    bool write(std::ostream& os) const;
-
-    void computeError()  {
-      const VertexSE3Expmap* v1 = static_cast<const VertexSE3Expmap*>(_vertices[1]);
-      const VertexSBAPointXYZ* v2 = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-      const CameraParameters * cam = static_cast<const CameraParameters *>(parameter(0));
-      _error = measurement() - cam->cam_map(v1->estimate().map(v2->estimate()));
-    }
-
-    virtual void linearizeOplus();
-
-    CameraParameters * _cam;
-};
-
-
-class G2O_TYPES_SBA_API EdgeProjectPSI2UV : public  g2o::BaseMultiEdge<2, Vector2>
-{
-public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-  EdgeProjectPSI2UV()  {
-    resize(3);
-    resizeParameters(1);
-    installParameter(_cam, 0);
-  }
-
-  virtual bool read  (std::istream& is);
-  virtual bool write (std::ostream& os) const;
-  void computeError  ();
-  virtual void linearizeOplus ();
-  CameraParameters * _cam;
-};
-
-
-
-//Stereo Observations
-// U: left u
-// V: left v
-// U: right u
-class G2O_TYPES_SBA_API EdgeProjectXYZ2UVU : public  BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexSE3Expmap>{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-    EdgeProjectXYZ2UVU();
-
-    bool read(std::istream& is);
-
-    bool write(std::ostream& os) const;
-
-    void computeError(){
-      const VertexSE3Expmap* v1 = static_cast<const VertexSE3Expmap*>(_vertices[1]);
-      const VertexSBAPointXYZ* v2 = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-      const CameraParameters* cam = static_cast<const CameraParameters *>(parameter(0));
-      _error = measurement() - cam->stereocam_uvu_map(v1->estimate().map(v2->estimate()));
-    }
-    //  virtual void linearizeOplus();
-    CameraParameters * _cam;
-};
-
-// Projection using focal_length in x and y directions
-class G2O_TYPES_SBA_API EdgeSE3ProjectXYZ : public BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSE3Expmap> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-  EdgeSE3ProjectXYZ();
-
-  bool read(std::istream &is);
-
-  bool write(std::ostream &os) const;
-
-  void computeError() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[1]);
-    const VertexSBAPointXYZ *v2 = static_cast<const VertexSBAPointXYZ *>(_vertices[0]);
-    Vector2 obs(_measurement);
-    _error = obs - cam_project(v1->estimate().map(v2->estimate()));
-  }
-
-  bool isDepthPositive() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[1]);
-    const VertexSBAPointXYZ *v2 = static_cast<const VertexSBAPointXYZ *>(_vertices[0]);
-    return (v1->estimate().map(v2->estimate()))(2) > 0.0;
-  }
-
-  virtual void linearizeOplus();
-
-  Vector2 cam_project(const Vector3 &trans_xyz) const;
-
-  number_t fx, fy, cx, cy;
-};
-
-// Edge to optimize only the camera pose
-class G2O_TYPES_SBA_API EdgeSE3ProjectXYZOnlyPose : public BaseUnaryEdge<2, Vector2, VertexSE3Expmap> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-  EdgeSE3ProjectXYZOnlyPose() {}
-
-  bool read(std::istream &is);
-
-  bool write(std::ostream &os) const;
-
-  void computeError() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[0]);
-    Vector2 obs(_measurement);
-    _error = obs - cam_project(v1->estimate().map(Xw));
-  }
-
-  bool isDepthPositive() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[0]);
-    return (v1->estimate().map(Xw))(2) > 0;
-  }
-
-  virtual void linearizeOplus();
-
-  Vector2 cam_project(const Vector3 &trans_xyz) const;
-
-  Vector3 Xw;
-  number_t fx, fy, cx, cy;
-};
-
-// Projection using focal_length in x and y directions stereo
-class G2O_TYPES_SBA_API EdgeStereoSE3ProjectXYZ : public BaseBinaryEdge<3, Vector3, VertexSBAPointXYZ, VertexSE3Expmap> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-  EdgeStereoSE3ProjectXYZ();
-
-  bool read(std::istream &is);
-
-  bool write(std::ostream &os) const;
-
-  void computeError() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[1]);
-    const VertexSBAPointXYZ *v2 = static_cast<const VertexSBAPointXYZ *>(_vertices[0]);
-    Vector3 obs(_measurement);
-    _error = obs - cam_project(v1->estimate().map(v2->estimate()), bf);
-  }
-
-  bool isDepthPositive() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[1]);
-    const VertexSBAPointXYZ *v2 = static_cast<const VertexSBAPointXYZ *>(_vertices[0]);
-    return (v1->estimate().map(v2->estimate()))(2) > 0;
-  }
-
-  virtual void linearizeOplus();
-
-  Vector3 cam_project(const Vector3 &trans_xyz, const float &bf) const;
-
-  number_t fx, fy, cx, cy, bf;
-};
-
-// Edge to optimize only the camera pose stereo
-class G2O_TYPES_SBA_API EdgeStereoSE3ProjectXYZOnlyPose : public BaseUnaryEdge<3, Vector3, VertexSE3Expmap> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-  EdgeStereoSE3ProjectXYZOnlyPose() {}
-
-  bool read(std::istream &is);
-
-  bool write(std::ostream &os) const;
-
-  void computeError() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[0]);
-    Vector3 obs(_measurement);
-    _error = obs - cam_project(v1->estimate().map(Xw));
-  }
-
-  bool isDepthPositive() {
-    const VertexSE3Expmap *v1 = static_cast<const VertexSE3Expmap *>(_vertices[0]);
-    return (v1->estimate().map(Xw))(2) > 0;
-  }
-
-  virtual void linearizeOplus();
-
-  Vector3 cam_project(const Vector3 &trans_xyz) const;
-
-  Vector3 Xw;
-  number_t fx, fy, cx, cy, bf;
-};
-
-} // end namespace
-
-#endif
-
diff --git a/g2o/types/sclam2d/CMakeLists.txt b/g2o/types/sclam2d/CMakeLists.txt
deleted file mode 100644
index bb934536..00000000
--- a/g2o/types/sclam2d/CMakeLists.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-add_library(types_sclam2d ${G2O_LIB_TYPE}
-  edge_se2_sensor_calib.cpp edge_se2_sensor_calib.h
-  vertex_odom_differential_params.cpp vertex_odom_differential_params.h
-  edge_se2_odom_differential_calib.cpp edge_se2_odom_differential_calib.h
-  odometry_measurement.cpp odometry_measurement.h
-  types_sclam2d.cpp types_sclam2d.h
-  g2o_types_sclam2d_api.h
-)
-
-set_target_properties(types_sclam2d PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_sclam2d)
-if (APPLE)
-  set_target_properties(types_sclam2d PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_sclam2d types_slam2d core)
-if(G2O_HAVE_OPENGL)
-  target_link_libraries(types_sclam2d ${OPENGL_gl_LIBRARY})
-endif()
-
-install(TARGETS types_sclam2d
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/sclam2d)
diff --git a/g2o/types/sclam2d/edge_se2_odom_differential_calib.cpp b/g2o/types/sclam2d/edge_se2_odom_differential_calib.cpp
deleted file mode 100644
index b9f0bd0d..00000000
--- a/g2o/types/sclam2d/edge_se2_odom_differential_calib.cpp
+++ /dev/null
@@ -1,81 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_odom_differential_calib.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-namespace g2o {
-
-  EdgeSE2OdomDifferentialCalib::EdgeSE2OdomDifferentialCalib() :
-    BaseMultiEdge<3, VelocityMeasurement>()
-  {
-    resize(3);
-  }
-
-  bool EdgeSE2OdomDifferentialCalib::read(std::istream& is)
-  {
-    number_t vl, vr, dt;
-    is >> vl >> vr >> dt;
-    VelocityMeasurement vm(vl, vr, dt);
-    setMeasurement(vm);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSE2OdomDifferentialCalib::write(std::ostream& os) const
-  {
-    os << measurement().vl() << " " << measurement().vr() << " " << measurement().dt() << " ";
-    return writeInformationMatrix(os);
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE2OdomDifferentialCalibDrawAction::EdgeSE2OdomDifferentialCalibDrawAction() :
-    DrawAction(typeid(EdgeSE2OdomDifferentialCalib).name())
-  {
-  }
-
-  HyperGraphElementAction* EdgeSE2OdomDifferentialCalibDrawAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* )
-  {
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    EdgeSE2OdomDifferentialCalib* e = static_cast<EdgeSE2OdomDifferentialCalib*>(element);
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
-    glColor3f(0.5f,0.5f,0.5f);
-    glPushAttrib(GL_ENABLE_BIT);
-    glDisable(GL_LIGHTING);
-    glBegin(GL_LINES);
-    glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),0.f);
-    glVertex3f((float)toEdge->estimate().translation().x(),(float)toEdge->estimate().translation().y(),0.f);
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/sclam2d/edge_se2_odom_differential_calib.h b/g2o/types/sclam2d/edge_se2_odom_differential_calib.h
deleted file mode 100644
index 95c6881c..00000000
--- a/g2o/types/sclam2d/edge_se2_odom_differential_calib.h
+++ /dev/null
@@ -1,79 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_ODOM_CALIB_DIFFERENTIAL_H
-#define G2O_EDGE_SE2_ODOM_CALIB_DIFFERENTIAL_H
-
-#include "g2o_types_sclam2d_api.h"
-#include "odometry_measurement.h"
-#include "vertex_odom_differential_params.h"
-
-#include "g2o/types/slam2d/vertex_se2.h"
-#include "g2o/core/base_multi_edge.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SCLAM2D_API EdgeSE2OdomDifferentialCalib : public BaseMultiEdge<3, VelocityMeasurement>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE2OdomDifferentialCalib();
-
-      void computeError()
-      {
-        const VertexSE2* v1                        = dynamic_cast<const VertexSE2*>(_vertices[0]);
-        const VertexSE2* v2                        = dynamic_cast<const VertexSE2*>(_vertices[1]);
-        const VertexOdomDifferentialParams* params = dynamic_cast<const VertexOdomDifferentialParams*>(_vertices[2]);
-        const SE2& x1                              = v1->estimate();
-        const SE2& x2                              = v2->estimate();
-
-        // get the calibrated motion given by the odometry
-        VelocityMeasurement calibratedVelocityMeasurment(measurement().vl() * params->estimate()(0),
-            measurement().vr() * params->estimate()(1),
-            measurement().dt());
-        MotionMeasurement mm = OdomConvert::convertToMotion(calibratedVelocityMeasurment, params->estimate()(2));
-        SE2 Ku_ij;
-        Ku_ij.fromVector(mm.measurement());
-
-        SE2 delta = Ku_ij.inverse() * x1.inverse() * x2 ;
-        _error = delta.toVector();
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SCLAM2D_API EdgeSE2OdomDifferentialCalibDrawAction: public DrawAction {
-    public:
-      EdgeSE2OdomDifferentialCalibDrawAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/sclam2d/edge_se2_sensor_calib.cpp b/g2o/types/sclam2d/edge_se2_sensor_calib.cpp
deleted file mode 100644
index 83a2d4b4..00000000
--- a/g2o/types/sclam2d/edge_se2_sensor_calib.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_sensor_calib.h"
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-namespace g2o {
-
-  EdgeSE2SensorCalib::EdgeSE2SensorCalib() :
-    BaseMultiEdge<3, SE2>()
-  {
-    resize(3);
-  }
-
-  void EdgeSE2SensorCalib::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-  {
-    (void) to;
-    VertexSE2* vi = static_cast<VertexSE2*>(_vertices[0]);
-    VertexSE2* vj = static_cast<VertexSE2*>(_vertices[1]);
-    VertexSE2* l  = static_cast<VertexSE2*>(_vertices[2]);
-    if (from.count(l) == 0)
-      return;
-    if (from.count(vi) == 1) {
-      vj->setEstimate(vi->estimate() * l->estimate() * measurement() * l->estimate().inverse());
-    } else {
-      vi->setEstimate(vj->estimate() * l->estimate() * _inverseMeasurement * l->estimate().inverse());
-    }
-  }
-
-  bool EdgeSE2SensorCalib::read(std::istream& is)
-  {
-    Vector3 p;
-    internal::readVector(is, p);
-    _measurement.fromVector(p);
-    _inverseMeasurement=measurement().inverse();
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSE2SensorCalib::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement().toVector());
-    return writeInformationMatrix(os);
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE2SensorCalibDrawAction::EdgeSE2SensorCalibDrawAction() :
-    DrawAction(typeid(EdgeSE2SensorCalib).name())
-  {
-  }
-
-  HyperGraphElementAction* EdgeSE2SensorCalibDrawAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* )
-  {
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    EdgeSE2SensorCalib* e = static_cast<EdgeSE2SensorCalib*>(element);
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
-    glColor3f(0.5,0.5,1.0);
-    glPushAttrib(GL_ENABLE_BIT);
-    glDisable(GL_LIGHTING);
-    glBegin(GL_LINES);
-    glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),0.f);
-    glVertex3f((float)toEdge->estimate().translation().x(),(float)toEdge->estimate().translation().y(),0.f);
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/sclam2d/edge_se2_sensor_calib.h b/g2o/types/sclam2d/edge_se2_sensor_calib.h
deleted file mode 100644
index 1301d22a..00000000
--- a/g2o/types/sclam2d/edge_se2_sensor_calib.h
+++ /dev/null
@@ -1,88 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_SENSOR_CALIB_H
-#define G2O_EDGE_SE2_SENSOR_CALIB_H
-
-#include "g2o_types_sclam2d_api.h"
-#include "g2o/core/base_multi_edge.h"
-#include "g2o/types/slam2d/vertex_se2.h"
-
-namespace g2o {
-
-  /**
-   * \brief scanmatch measurement that also calibrates an offset for the laser
-   */
-  class G2O_TYPES_SCLAM2D_API EdgeSE2SensorCalib : public BaseMultiEdge<3, SE2>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE2SensorCalib();
-
-      void computeError()
-      {
-        const VertexSE2* v1          = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexSE2* v2          = static_cast<const VertexSE2*>(_vertices[1]);
-        const VertexSE2* laserOffset = static_cast<const VertexSE2*>(_vertices[2]);
-        const SE2& x1 = v1->estimate();
-        const SE2& x2 = v2->estimate();
-        SE2 delta = _inverseMeasurement * ((x1 * laserOffset->estimate()).inverse() * x2 * laserOffset->estimate());
-        _error = delta.toVector();
-      }
-
-      void setMeasurement(const SE2& m){
-        _measurement = m;
-        _inverseMeasurement = m.inverse();
-      }
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-      {
-        if (   from.count(_vertices[2]) == 1 // need the laser offset
-            && ((from.count(_vertices[0]) == 1 && to == _vertices[1]) || ((from.count(_vertices[1]) == 1 && to == _vertices[0])))) {
-          return 1.0;
-        }
-        return -1.0;
-      }
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-    protected:
-      SE2 _inverseMeasurement;
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class EdgeSE2SensorCalibDrawAction: public DrawAction {
-  public:
-    EdgeSE2SensorCalibDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/sclam2d/g2o_types_sclam2d_api.h b/g2o/types/sclam2d/g2o_types_sclam2d_api.h
deleted file mode 100644
index 2c4c62b0..00000000
--- a/g2o/types/sclam2d/g2o_types_sclam2d_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_SCLAM2D_API_H
-#define G2O_TYPES_SCLAM2D_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_sclam2d_EXPORTS
-#define G2O_TYPES_SCLAM2D_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SCLAM2D_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SCLAM2D_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SCLAM2D_API
-#endif
-
-#endif // G2O_TYPES_SCLAM2D_API_H
diff --git a/g2o/types/sclam2d/odometry_measurement.cpp b/g2o/types/sclam2d/odometry_measurement.cpp
deleted file mode 100644
index 2c0e89a4..00000000
--- a/g2o/types/sclam2d/odometry_measurement.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "odometry_measurement.h"
-
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-namespace g2o {
-
-  VelocityMeasurement::VelocityMeasurement() :
-    _measurement(0., 0.), _dt(0.)
-  {
-  }
-
-  VelocityMeasurement::VelocityMeasurement(number_t vl, number_t vr, number_t dt) :
-    _measurement(vl, vr), _dt(dt)
-  {
-  }
-
-  MotionMeasurement::MotionMeasurement() :
-    _measurement(0., 0., 0.), _dt(0.)
-  {
-  }
-
-  MotionMeasurement::MotionMeasurement(number_t x, number_t y, number_t theta, number_t dt) :
-    _measurement(x, y, theta), _dt(dt)
-  {
-  }
-
-  MotionMeasurement::MotionMeasurement(const Vector3& m, number_t dt) :
-    _measurement(m), _dt(dt)
-  {
-  }
-
-  VelocityMeasurement OdomConvert::convertToVelocity(const MotionMeasurement& m)
-  {
-    if (fabs(m.theta()) > 1e-7) {
-      const number_t translation = std::hypot(m.x(), m.y());
-      const number_t R = translation / (2 * sin(m.theta() / 2));
-      number_t w = 0.;
-      if (fabs(m.dt()) > 1e-7) w = m.theta() / m.dt();
-
-      const number_t vl = (2.*R*w - w) / 2.;
-      const number_t vr = w + vl;
-
-      return VelocityMeasurement(vl, vr, m.dt());
-    } else {
-      number_t vl, vr;
-      if (fabs(m.dt()) > 1e-7)
-        vl = vr = std::hypot(m.x(), m.y()) / m.dt();
-      else
-        vl = vr = 0.;
-      return VelocityMeasurement(vl, vr, m.dt());
-    }
-  }
-
-  MotionMeasurement OdomConvert::convertToMotion(const VelocityMeasurement& v, number_t l)
-  {
-    number_t x, y, theta;
-    if (fabs(v.vr() - v.vl()) > 1e-7) {
-      number_t R = l * 0.5 * ((v.vl() + v.vr())  / (v.vr() - v.vl()));
-      number_t w = (v.vr() - v.vl()) / l;
-
-      theta = w * v.dt();
-      Rotation2D rot(theta);
-      Vector2 icc(0, R);
-      Vector2 motion = (rot * (Vector2(-1.*icc))) + icc;
-      x = motion.x();
-      y = motion.y();
-    } else {
-      number_t tv = 0.5 * (v.vr() + v.vl());
-      theta = 0.;
-      x = tv * v.dt();
-      y = 0.;
-    }
-
-    return MotionMeasurement(x, y, theta, v.dt());
-  }
-
-} // end namespace
diff --git a/g2o/types/sclam2d/odometry_measurement.h b/g2o/types/sclam2d/odometry_measurement.h
deleted file mode 100644
index cd040599..00000000
--- a/g2o/types/sclam2d/odometry_measurement.h
+++ /dev/null
@@ -1,103 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_ODOMETRY_MEASUREMENT_H
-#define G2O_ODOMETRY_MEASUREMENT_H
-
-#include "g2o_types_sclam2d_api.h"
-#include <Eigen/Core>
-
-namespace g2o {
-
-  /**
-   * \brief velocity measurement of a differential robot
-   */
-  class G2O_TYPES_SCLAM2D_API VelocityMeasurement
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VelocityMeasurement();
-      VelocityMeasurement(number_t vl, number_t vr, number_t dt);
-
-      number_t vl() const { return _measurement(0);}
-      void setVl(number_t v) { _measurement(0) = v;}
-
-      number_t vr() const { return _measurement(1);}
-      void setVr(number_t v) { _measurement(1) = v;}
-
-      number_t dt() const { return _dt;}
-      void setDt(number_t t) { _dt = t;}
-      
-      const Vector2& measurement() const { return _measurement;}
-
-    protected:
-      Vector2 _measurement;
-      number_t _dt;
-  };
-
-  /**
-   * \brief A 2D odometry measurement expressed as a transformation
-   */
-  class G2O_TYPES_SCLAM2D_API MotionMeasurement
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      MotionMeasurement();
-      MotionMeasurement(number_t x, number_t y, number_t theta, number_t dt);
-      MotionMeasurement(const Vector3& m, number_t dt);
-
-      number_t x() const { return _measurement(0);}
-      void setX(number_t v) { _measurement(0) = v;}
-
-      number_t y() const { return _measurement(1);}
-      void setY(number_t v) { _measurement(1) = v;}
-
-      number_t theta() const { return _measurement(2);}
-      void setTheta(number_t v) { _measurement(2) = v;}
-
-      number_t dt() const { return _dt;}
-      void setDt(number_t t) { _dt = t;}
-
-      const Vector3& measurement() const { return _measurement;}
-
-    protected:
-      Vector3 _measurement;
-      number_t _dt;
-  };
-
-  /**
-   * \brief convert between the different types of odometry measurements
-   */
-  class G2O_TYPES_SCLAM2D_API OdomConvert
-  {
-    public:
-      static VelocityMeasurement convertToVelocity(const MotionMeasurement& m);
-      static MotionMeasurement convertToMotion(const VelocityMeasurement& vi, number_t l = 1.0);
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/sclam2d/types_sclam2d.cpp b/g2o/types/sclam2d/types_sclam2d.cpp
deleted file mode 100644
index 49b2a5e8..00000000
--- a/g2o/types/sclam2d/types_sclam2d.cpp
+++ /dev/null
@@ -1,52 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "g2o/config.h"
-
-#include "vertex_odom_differential_params.h"
-
-#include "edge_se2_sensor_calib.h"
-#include "edge_se2_odom_differential_calib.h"
-
-#include "g2o/core/factory.h"
-
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  G2O_USE_TYPE_GROUP(slam2d);
-  
-  G2O_REGISTER_TYPE_GROUP(sclam);
-  G2O_REGISTER_TYPE(VERTEX_ODOM_DIFFERENTIAL, VertexOdomDifferentialParams);
-  G2O_REGISTER_TYPE(EDGE_SE2_CALIB, EdgeSE2SensorCalib);
-  G2O_REGISTER_TYPE(EDGE_SE2_ODOM_DIFFERENTIAL_CALIB, EdgeSE2OdomDifferentialCalib);
-
-#ifdef G2O_HAVE_OPENGL
-  G2O_REGISTER_ACTION(EdgeSE2SensorCalibDrawAction);
-  G2O_REGISTER_ACTION(EdgeSE2OdomDifferentialCalibDrawAction);
-#endif
-
-} // end namespace
diff --git a/g2o/types/sclam2d/types_sclam2d.h b/g2o/types/sclam2d/types_sclam2d.h
deleted file mode 100644
index 9552d25d..00000000
--- a/g2o/types/sclam2d/types_sclam2d.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_SCLAM_H
-#define G2O_TYPES_SCLAM_H
-
-#include "edge_se2_sensor_calib.h"
-#include "edge_se2_odom_differential_calib.h"
-
-#endif
diff --git a/g2o/types/sclam2d/vertex_odom_differential_params.cpp b/g2o/types/sclam2d/vertex_odom_differential_params.cpp
deleted file mode 100644
index d9c5e462..00000000
--- a/g2o/types/sclam2d/vertex_odom_differential_params.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_odom_differential_params.h"
-
-namespace g2o {
-
-  VertexOdomDifferentialParams::VertexOdomDifferentialParams() :
-    BaseVertex <3, Vector3>()
-  {
-  }
-
-  bool VertexOdomDifferentialParams::read(std::istream& is)
-  {
-    return internal::readVector(is, _estimate);
-  }
-
-  bool VertexOdomDifferentialParams::write(std::ostream& os) const
-  {
-    return internal::writeVector(os, estimate());
-  }
-
-}
diff --git a/g2o/types/sclam2d/vertex_odom_differential_params.h b/g2o/types/sclam2d/vertex_odom_differential_params.h
deleted file mode 100644
index bec6fe39..00000000
--- a/g2o/types/sclam2d/vertex_odom_differential_params.h
+++ /dev/null
@@ -1,54 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_ODOM_DIFFERENTIAL_PARAMS_H
-#define G2O_VERTEX_ODOM_DIFFERENTIAL_PARAMS_H
-
-#include "g2o_types_sclam2d_api.h"
-#include "g2o/core/base_vertex.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SCLAM2D_API VertexOdomDifferentialParams: public BaseVertex <3, Vector3> {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexOdomDifferentialParams();
-      virtual void setToOriginImpl() {
-        _estimate << 1. , 1., 1.;
-      }
-
-      virtual void oplusImpl(const number_t* v) {
-        for (int i=0; i<3; i++)
-          _estimate(i) += v[i];
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-  };
-
-}
-
-#endif
diff --git a/g2o/types/sim3/CMakeLists.txt b/g2o/types/sim3/CMakeLists.txt
deleted file mode 100644
index f4abbb51..00000000
--- a/g2o/types/sim3/CMakeLists.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-add_library(types_sim3 ${G2O_LIB_TYPE}
-  types_seven_dof_expmap.cpp
-  types_seven_dof_expmap.h
-)
-
-set_target_properties(types_sim3 PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_sim3)
-if (APPLE)
-  set_target_properties(types_sim3 PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_sim3 PUBLIC types_sba)
-
-install(TARGETS types_sim3
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/sim3)
-
diff --git a/g2o/types/sim3/sim3.h b/g2o/types/sim3/sim3.h
deleted file mode 100644
index 6dec96a4..00000000
--- a/g2o/types/sim3/sim3.h
+++ /dev/null
@@ -1,301 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SIM_3
-#define G2O_SIM_3
-
-#include "g2o/types/slam3d/se3_ops.h"
-#include "g2o/stuff/misc.h"
-#include <Eigen/Geometry>
-
-namespace g2o
-{
-  struct Sim3
-  {
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-    protected:
-      Quaternion r;
-      Vector3 t;
-      number_t s;
-
-    public:
-      Sim3()
-      {
-        r.setIdentity();
-        t.fill(0.);
-        s=1.;
-      }
-
-      Sim3(const Quaternion & r, const Vector3 & t, number_t s)
-        : r(r),t(t),s(s)
-      {
-			normalizeRotation();
-      }
-
-      Sim3(const Matrix3 & R, const Vector3 & t, number_t s)
-        : r(Quaternion(R)),t(t),s(s)
-      {
-			normalizeRotation();
-      }
-
-
-      Sim3(const Vector7 & update)
-      {
-
-        Vector3 omega;
-        for (int i=0; i<3; i++)
-          omega[i]=update[i];
-
-        Vector3 upsilon;
-        for (int i=0; i<3; i++)
-          upsilon[i]=update[i+3];
-
-        number_t sigma = update[6];
-        number_t theta = omega.norm();
-        Matrix3 Omega = skew(omega);
-        s = std::exp(sigma);
-        Matrix3 Omega2 = Omega*Omega;
-        Matrix3 I;
-        I.setIdentity();
-        Matrix3 R;
-
-        number_t eps = cst(0.00001);
-        number_t A,B,C;
-        if (fabs(sigma)<eps)
-        {
-          C = 1;
-          if (theta<eps)
-          {
-            A = cst(1./2.);
-            B = cst(1./6.);
-            R = (I + Omega + Omega*Omega/2);//R=I+(1-cos(theta))*a^a^+sin(theta)*a^~=(omit O(theta^3))=I+theta^2/2*a^a^+theta*a^
-          }
-          else
-          {
-            number_t theta2= theta*theta;
-            A = (1-std::cos(theta))/(theta2);
-            B = (theta-std::sin(theta))/(theta2*theta);
-            R = I + std::sin(theta)/theta *Omega + (1-std::cos(theta))/(theta*theta)*Omega2;
-          }
-        }
-        else
-        {
-          C=(s-1)/sigma;
-          if (theta<eps)
-          {
-            number_t sigma2= sigma*sigma;
-            A = ((sigma-1)*s+1)/sigma2;
-            B= ((cst(0.5)*sigma2-sigma+1)*s-1)/(sigma2*sigma);//B=[C-((s*cos(theta)-1)*sigma+s*sin(theta)*theta)/(sigma^2+theta^2)]/theta^2~=(omit O(theta^2))=
-	    //(1/2*s*sigma-s)/(sigma^2)+[C-(s-1)*sigma/(sigma^2+theta^2)]/theta^2~=(0.5*sigma^2*s-s*sigma)/sigma^3+[s-1]/sigma^3=[s*(0.5*sigma^2-sigma+1)-1]/sigma^3  
-            R = (I + Omega + Omega2/2);//R=I+(1-cos(theta))*a^a^+sin(theta)*a^~=I+theta^2/2*a^a^+theta*a^
-          }
-          else
-          {
-            R = I + std::sin(theta)/theta *Omega + (1-std::cos(theta))/(theta*theta)*Omega2;
-            number_t a=s*std::sin(theta);
-            number_t b=s*std::cos(theta);
-            number_t theta2= theta*theta;
-            number_t sigma2= sigma*sigma;
-            number_t c=theta2+sigma2;
-            A = (a*sigma+ (1-b)*theta)/(theta*c);
-            B = (C-((b-1)*sigma+a*theta)/(c))*1/(theta2);
-
-          }
-        }
-        r = Quaternion(R);
-
-
-
-        Matrix3 W = A*Omega + B*Omega2 + C*I;
-        t = W*upsilon;
-      }
-
-      Vector3 map (const Vector3& xyz) const {
-        return s*(r*xyz) + t;
-      }
-
-      Vector7 log() const
-      {
-        Vector7 res;
-        number_t sigma = std::log(s);
-
-        Vector3 omega;
-        Vector3 upsilon;
-
-        Matrix3 R = r.toRotationMatrix();
-        number_t d =  cst(0.5)*(R(0,0)+R(1,1)+R(2,2)-1);
-
-        Matrix3 Omega;
-
-        number_t eps = cst(0.00001);
-        Matrix3 I = Matrix3::Identity();
-
-        number_t A,B,C;
-        if (fabs(sigma)<eps)
-        {
-          C = 1;
-          if (d>1-eps)
-          {
-            omega=0.5*deltaR(R);
-            Omega = skew(omega);
-            A = cst(1./2.);
-            B = cst(1./6.);
-          }
-          else
-          {
-            number_t theta = std::acos(d);
-            number_t theta2 = theta*theta;
-            omega = theta/(2*std::sqrt(1-d*d))*deltaR(R);
-            Omega = skew(omega);
-            A = (1-std::cos(theta))/(theta2);
-            B = (theta-std::sin(theta))/(theta2*theta);
-          }
-        }
-        else
-        {
-          C=(s-1)/sigma;
-          if (d>1-eps)
-          {
-            number_t sigma2 = sigma*sigma;
-            omega=cst(0.5)*deltaR(R);
-            Omega = skew(omega);
-            A = ((sigma-1)*s+1)/(sigma2);
-            B = ((cst(0.5)*sigma2-sigma+1)*s-1)/(sigma2*sigma);//B=[C-((s*cos(theta)-1)*sigma+s*sin(theta)*theta)/(sigma^2+theta^2)]/theta^2
-	    //use limit(theta->0)(B)=limit(theta->0){[(sigma2+theta2)*(s*sigma*sin(theta)-s*sin(theta)-s*theta*cos(theta))+(s*cos(theta)*sigma-sigma+s*sin(theta)*theta)*2*theta]/(2*theta)}=
-	    //=limit(theta->0)(s*sigma-s)*sin(theta)/(2*(sigma2+theta2)*theta)+limit(theta->0)[-s*cos(theta)/(2*(sigma2+theta2))+(s*cos(theta)*sigma-sigma+s*sin(theta)*theta)/(sigma2+theta2)^2]=
-	    //=limit(theta->0)(s*sigma-s)*cos(theta)/(2*(sigma2+3*theta2))+-s/(2*sigma2)+(s-1)/sigma^3=
-	    //=(s*sigma-s)/2/sigma2-s/2/sigma2+(s-1)/sigma^3=[(0.5*sigma2-sigma+1)*s-1]/sigma^3
-          }
-          else
-          {
-            number_t theta = std::acos(d);
-            omega = theta/(2*std::sqrt(1-d*d))*deltaR(R);
-            Omega = skew(omega);
-            number_t theta2 = theta*theta;
-            number_t a=s*std::sin(theta);
-            number_t b=s*std::cos(theta);
-            number_t c=theta2 + sigma*sigma;
-            A = (a*sigma+ (1-b)*theta)/(theta*c);
-            B = (C-((b-1)*sigma+a*theta)/(c))*1/(theta2);
-          }
-        }
-
-        Matrix3 W = A*Omega + B*Omega*Omega + C*I;
-
-        upsilon = W.lu().solve(t);
-
-        for (int i=0; i<3; i++)
-          res[i] = omega[i];
-
-        for (int i=0; i<3; i++)
-          res[i+3] = upsilon[i];
-
-        res[6] = sigma;
-
-        return res;
-      }
-
-
-      Sim3 inverse() const
-      {
-        return Sim3(r.conjugate(), r.conjugate()*((-1/s)*t), 1/s);
-      }
-
-      number_t operator[](int i) const
-      {
-        assert(i<8);
-        if (i<4){
-
-          return r.coeffs()[i];
-        }
-        if (i<7){
-          return t[i-4];
-        }
-        return s;
-      }
-
-      number_t& operator[](int i)
-      {
-        assert(i<8);
-        if (i<4){
-
-          return r.coeffs()[i];
-        }
-        if (i<7)
-        {
-          return t[i-4];
-        }
-        return s;
-      }
-
-      Sim3 operator *(const Sim3& other) const {
-        Sim3 ret;
-        ret.r = r*other.r;
-        ret.t=s*(r*other.t)+t;
-        ret.s=s*other.s;
-        return ret;
-      }
-
-      Sim3& operator *=(const Sim3& other){
-        Sim3 ret=(*this)*other;
-        *this=ret;
-        return *this;
-      }
-    void normalizeRotation(){
-        if (r.w()<0){
-          r.coeffs() *= -1;
-        }
-        r.normalize();
-    }
-      inline const Vector3& translation() const {return t;}
-
-      inline Vector3& translation() {return t;}
-
-      inline const Quaternion& rotation() const {return r;}
-
-      inline Quaternion& rotation() {return r;}
-
-      inline const number_t& scale() const {return s;}
-
-      inline number_t& scale() {return s;}
-
-  };
-
-  inline std::ostream& operator <<(std::ostream& out_str,
-                                   const Sim3& sim3)
-  {
-    out_str << sim3.rotation().coeffs() << std::endl;
-    out_str << sim3.translation() << std::endl;
-    out_str << sim3.scale() << std::endl;
-
-    return out_str;
-  }
-
-} // end namespace
-
-
-#endif
diff --git a/g2o/types/sim3/types_seven_dof_expmap.cpp b/g2o/types/sim3/types_seven_dof_expmap.cpp
deleted file mode 100644
index 81958341..00000000
--- a/g2o/types/sim3/types_seven_dof_expmap.cpp
+++ /dev/null
@@ -1,211 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_seven_dof_expmap.h"
-
-#include "g2o/core/factory.h"
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-G2O_USE_TYPE_GROUP(sba);
-G2O_REGISTER_TYPE_GROUP(sim3);
-
-G2O_REGISTER_TYPE(VERTEX_SIM3:EXPMAP, VertexSim3Expmap);
-G2O_REGISTER_TYPE(EDGE_SIM3:EXPMAP, EdgeSim3);
-G2O_REGISTER_TYPE(EDGE_PROJECT_SIM3_XYZ:EXPMAP, EdgeSim3ProjectXYZ);
-G2O_REGISTER_TYPE(EDGE_PROJECT_INVERSE_SIM3_XYZ:EXPMAP, EdgeInverseSim3ProjectXYZ);
-
-VertexSim3Expmap::VertexSim3Expmap() : BaseVertex<7, Sim3>() {
-  _marginalized = false;
-  _fix_scale = false;
-
-  _principle_point1[0] = 0;
-  _principle_point1[1] = 0;
-  _focal_length1[0] = 1;
-  _focal_length1[1] = 1;
-
-  _principle_point2[0] = 0;
-  _principle_point2[1] = 0;
-  _focal_length2[0] = 1;
-  _focal_length2[1] = 1;
-}
-
-EdgeSim3::EdgeSim3() : BaseBinaryEdge<7, Sim3, VertexSim3Expmap, VertexSim3Expmap>() {}
-
-bool VertexSim3Expmap::read(std::istream &is) {
-  Vector7 cam2world;
-  bool state = true;
-  state &= internal::readVector(is, cam2world);
-  state &= internal::readVector(is, _focal_length1);
-  state &= internal::readVector(is, _principle_point1);
-  setEstimate(Sim3(cam2world).inverse());
-  return state;
-}
-
-bool VertexSim3Expmap::write(std::ostream &os) const {
-  Sim3 cam2world(estimate().inverse());
-  Vector7 lv = cam2world.log();
-  internal::writeVector(os, lv);
-  internal::writeVector(os, _focal_length1);
-  internal::writeVector(os, _principle_point1);
-  return os.good();
-}
-
-bool EdgeSim3::read(std::istream &is) {
-  Vector7 v7;
-  internal::readVector(is, v7);
-  Sim3 cam2world(v7);
-  setMeasurement(cam2world.inverse());
-  return readInformationMatrix(is);
-}
-
-bool EdgeSim3::write(std::ostream &os) const {
-  Sim3 cam2world(measurement().inverse());
-  internal::writeVector(os, cam2world.log());
-  return writeInformationMatrix(os);
-}
-
-#if G2O_SIM3_JACOBIAN
-void EdgeSim3::linearizeOplus() {
-    VertexSim3Expmap *v1 = static_cast<VertexSim3Expmap *>(_vertices[0]);
-    VertexSim3Expmap *v2 = static_cast<VertexSim3Expmap *>(_vertices[1]);
-    const Sim3 Si(v1->estimate());//Siw
-    const Sim3 Sj(v2->estimate());
-
-    const Sim3& Sji = _measurement;
-
-    // error in Lie Algebra
-    const Eigen::Matrix<double, 7, 1> error = (Sji * Si * Sj.inverse()).log();
-    const Eigen::Vector3d phi = error.block<3, 1>(0, 0); // rotation
-    const Eigen::Vector3d tau = error.block<3, 1>(3, 0); // translation
-    const double s = error(6);                           // scale
-
-    const Eigen::Matrix<double, 7, 7> I7 = Eigen::Matrix<double, 7, 7>::Identity();
-    const Eigen::Matrix<double, 3, 3> I3 = Eigen::Matrix<double, 3, 3>::Identity();
-
-    // Jacobi Matrix of Si
-    // note: because the order of rotation and translation is different,
-    //       so it is slightly different from the formula.
-    Eigen::Matrix<double, 7, 7> jacobi_i = Eigen::Matrix<double, 7, 7>::Zero();
-    jacobi_i.block<3, 3>(0, 0) = -skew(phi);
-    jacobi_i.block<3, 3>(3, 3) = -(skew(phi) + s * I3);
-    jacobi_i.block<3, 3>(3, 0) = -skew(tau);
-    jacobi_i.block<3, 1>(3, 6) = tau;
-
-    // Adjoint matrix of Sji
-    Eigen::Matrix<double, 7, 7> adj_Sji = I7;
-    adj_Sji.block<3, 3>(0, 0) = Sji.rotation().toRotationMatrix();
-    adj_Sji.block<3, 3>(3, 3) = Sji.scale() * Sji.rotation().toRotationMatrix();
-    adj_Sji.block<3, 3>(3, 0) =
-        skew(Sji.translation()) * Sji.rotation().toRotationMatrix();
-    adj_Sji.block<3, 1>(3, 6) = -Sji.translation();
-
-    _jacobianOplusXi = (I7 + 0.5 * jacobi_i) * adj_Sji;
-
-    // Jacobi Matrix of Sj
-    Eigen::Matrix<double, 7, 7> jacobi_j = Eigen::Matrix<double, 7, 7>::Zero();
-    jacobi_j.block<3, 3>(0, 0) = skew(phi);
-    jacobi_j.block<3, 3>(3, 3) = skew(phi) + s * I3;
-    jacobi_j.block<3, 3>(3, 0) = skew(tau);
-    jacobi_j.block<3, 1>(3, 6) = -tau;
-
-    _jacobianOplusXj = -(I7 + 0.5 * jacobi_j);
-}
-#endif
-
-  /**Sim3ProjectXYZ*/
-
-EdgeSim3ProjectXYZ::EdgeSim3ProjectXYZ() : BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSim3Expmap>() {}
-
-bool EdgeSim3ProjectXYZ::read(std::istream &is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeSim3ProjectXYZ::write(std::ostream &os) const {
-  internal::writeVector(os, _measurement);
-  return writeInformationMatrix(os);
-}
-
-EdgeInverseSim3ProjectXYZ::EdgeInverseSim3ProjectXYZ() :
-    BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSim3Expmap>() {
-}
-
-bool EdgeInverseSim3ProjectXYZ::read(std::istream &is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeInverseSim3ProjectXYZ::write(std::ostream &os) const {
-  internal::writeVector(os, _measurement);
-  return writeInformationMatrix(os);
-}
-
-//  void EdgeSim3ProjectXYZ::linearizeOplus()
-//  {
-//    VertexSim3Expmap * vj = static_cast<VertexSim3Expmap *>(_vertices[1]);
-//    Sim3 T = vj->estimate();
-
-//    VertexPointXYZ* vi = static_cast<VertexPointXYZ*>(_vertices[0]);
-//    Vector3 xyz = vi->estimate();
-//    Vector3 xyz_trans = T.map(xyz);
-
-//    number_t x = xyz_trans[0];
-//    number_t y = xyz_trans[1];
-//    number_t z = xyz_trans[2];
-//    number_t z_2 = z*z;
-
-//    Matrix<number_t,2,3,Eigen::ColMajor> tmp;
-//    tmp(0,0) = _focal_length(0);
-//    tmp(0,1) = 0;
-//    tmp(0,2) = -x/z*_focal_length(0);
-
-//    tmp(1,0) = 0;
-//    tmp(1,1) = _focal_length(1);
-//    tmp(1,2) = -y/z*_focal_length(1);
-
-//    _jacobianOplusXi =  -1./z * tmp * T.rotation().toRotationMatrix();
-
-//    _jacobianOplusXj(0,0) =  x*y/z_2 * _focal_length(0);
-//    _jacobianOplusXj(0,1) = -(1+(x*x/z_2)) *_focal_length(0);
-//    _jacobianOplusXj(0,2) = y/z *_focal_length(0);
-//    _jacobianOplusXj(0,3) = -1./z *_focal_length(0);
-//    _jacobianOplusXj(0,4) = 0;
-//    _jacobianOplusXj(0,5) = x/z_2 *_focal_length(0);
-//    _jacobianOplusXj(0,6) = 0; // scale is ignored
-
-
-//    _jacobianOplusXj(1,0) = (1+y*y/z_2) *_focal_length(1);
-//    _jacobianOplusXj(1,1) = -x*y/z_2 *_focal_length(1);
-//    _jacobianOplusXj(1,2) = -x/z *_focal_length(1);
-//    _jacobianOplusXj(1,3) = 0;
-//    _jacobianOplusXj(1,4) = -1./z *_focal_length(1);
-//    _jacobianOplusXj(1,5) = y/z_2 *_focal_length(1);
-//    _jacobianOplusXj(1,6) = 0; // scale is ignored
-//  }
-
-} // end namespace
diff --git a/g2o/types/sim3/types_seven_dof_expmap.h b/g2o/types/sim3/types_seven_dof_expmap.h
deleted file mode 100644
index 5750bacc..00000000
--- a/g2o/types/sim3/types_seven_dof_expmap.h
+++ /dev/null
@@ -1,192 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SEVEN_DOF_EXPMAP_TYPES
-#define G2O_SEVEN_DOF_EXPMAP_TYPES
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/types/sba/types_six_dof_expmap.h"
-#include "sim3.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_sim3_EXPORTS
-#define G2O_TYPES_SIM3_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SIM3_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SIM3_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SIM3_API
-#endif
-namespace g2o {
-
-// explicit instantiation of BaseVertex, if not instantiated causes already defined error in some cases (msvc debug only)
-// see links below
-// https://stackoverflow.com/questions/44960760/msvc-dll-exporting-class-that-inherits-from-template-cause-lnk2005-already-defin
-// https://developercommunity.visualstudio.com/content/problem/224597/linker-failing-because-of-multiple-definitions-of.html
-template class BaseVertex<7, Sim3>;
-
-/**
- * \brief Sim3 Vertex, (x,y,z,qw,qx,qy,qz)
- * the parameterization for the increments constructed is a 7d vector
- * (x,y,z,qx,qy,qz) (note that we leave out the w part of the quaternion.
- *
- * Will represent relative transformation between two cameras
-*/
-class G2O_TYPES_SIM3_API VertexSim3Expmap : public BaseVertex<7, Sim3>
-{
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-  VertexSim3Expmap();
-  virtual bool read(std::istream& is);
-  virtual bool write(std::ostream& os) const;
-
-  virtual void setToOriginImpl() {
-    _estimate = Sim3();
-  }
-
-  virtual void oplusImpl(const number_t* update_)
-  {
-    Eigen::Map<Vector7> update(const_cast<number_t*>(update_));
-
-    if (_fix_scale)
-      update[6] = 0;
-
-    Sim3 s(update);
-    setEstimate(s*estimate());
-  }
-
-  Vector2 _principle_point1, _principle_point2;
-  Vector2 _focal_length1, _focal_length2;
-
-  Vector2 cam_map1(const Vector2 &v) const {
-    Vector2 res;
-    res[0] = v[0] * _focal_length1[0] + _principle_point1[0];
-    res[1] = v[1] * _focal_length1[1] + _principle_point1[1];
-    return res;
-  }
-
-  Vector2 cam_map2(const Vector2 &v) const {
-    Vector2 res;
-    res[0] = v[0] * _focal_length2[0] + _principle_point2[0];
-    res[1] = v[1] * _focal_length2[1] + _principle_point2[1];
-    return res;
-  }
-
-  bool _fix_scale;
-
-
- protected:
-};
-
-  /**
- * \brief 7D edge between two Vertex7
- */
-  class G2O_TYPES_SIM3_API EdgeSim3 : public BaseBinaryEdge<7, Sim3, VertexSim3Expmap, VertexSim3Expmap>
-  {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSim3();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-    void computeError()
-    {
-      const VertexSim3Expmap* v1 = static_cast<const VertexSim3Expmap*>(_vertices[0]);
-      const VertexSim3Expmap* v2 = static_cast<const VertexSim3Expmap*>(_vertices[1]);
-
-      Sim3 C(_measurement);
-      Sim3 error_=C*v1->estimate()*v2->estimate().inverse();
-      _error = error_.log();
-    }
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to*/)
-    {
-      VertexSim3Expmap* v1 = static_cast<VertexSim3Expmap*>(_vertices[0]);
-      VertexSim3Expmap* v2 = static_cast<VertexSim3Expmap*>(_vertices[1]);
-      if (from.count(v1) > 0)
-        v2->setEstimate(measurement()*v1->estimate());
-      else
-        v1->setEstimate(measurement().inverse()*v2->estimate());
-    }
-    #if G2O_SIM3_JACOBIAN
-    virtual void linearizeOplus();
-    #endif
-  };
-
-
-/**/
-class G2O_TYPES_SIM3_API EdgeSim3ProjectXYZ : public  BaseBinaryEdge<2, Vector2,  VertexSBAPointXYZ, VertexSim3Expmap>
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSim3ProjectXYZ();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    void computeError()
-    {
-      const VertexSim3Expmap* v1 = static_cast<const VertexSim3Expmap*>(_vertices[1]);
-      const VertexSBAPointXYZ* v2 = static_cast<const VertexSBAPointXYZ*>(_vertices[0]);
-
-      Vector2 obs(_measurement);
-      _error = obs-v1->cam_map1(project(v1->estimate().map(v2->estimate())));
-    }
-
-   // virtual void linearizeOplus();
-
-};
-
-/**/
-class G2O_TYPES_SIM3_API EdgeInverseSim3ProjectXYZ : public BaseBinaryEdge<2, Vector2, VertexSBAPointXYZ, VertexSim3Expmap> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  EdgeInverseSim3ProjectXYZ();
-  virtual bool read(std::istream &is);
-  virtual bool write(std::ostream &os) const;
-
-  void computeError() {
-    const VertexSim3Expmap *v1 = static_cast<const VertexSim3Expmap *>(_vertices[1]);
-    const VertexSBAPointXYZ *v2 = static_cast<const VertexSBAPointXYZ *>(_vertices[0]);
-
-    Vector2 obs(_measurement);
-    _error = obs - v1->cam_map2(project(v1->estimate().inverse().map(v2->estimate())));
-  }
-
-  // virtual void linearizeOplus();
-
-};
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/CMakeLists.txt b/g2o/types/slam2d/CMakeLists.txt
deleted file mode 100644
index 1a951e27..00000000
--- a/g2o/types/slam2d/CMakeLists.txt
+++ /dev/null
@@ -1,38 +0,0 @@
-add_library(types_slam2d ${G2O_LIB_TYPE}
-  se2.h
-  edge_se2_pointxy_bearing.h  edge_se2_prior.h
-  edge_se2.cpp                  edge_se2_pointxy_calib.cpp  types_slam2d.cpp
-  edge_se2.h                    edge_se2_pointxy_calib.h    vertex_point_xy.cpp
-  edge_se2_pointxy.cpp        vertex_point_xy.h
-  edge_se2_pointxy.h          vertex_se2.cpp
-  edge_se2_pointxy_bearing.cpp  edge_se2_prior.cpp          vertex_se2.h
-  parameter_se2_offset.cpp     parameter_se2_offset.h
-  edge_se2_offset.cpp          edge_se2_offset.h
-  edge_se2_pointxy_offset.cpp  edge_se2_pointxy_offset.h
-  edge_se2_xyprior.cpp edge_se2_xyprior.h
-  edge_pointxy.cpp             edge_pointxy.h
-  edge_se2_twopointsxy.cpp	edge_se2_twopointsxy.h
-  edge_se2_lotsofxy.cpp		edge_se2_lotsofxy.h
-  edge_xy_prior.cpp		edge_xy_prior.h
-  g2o_types_slam2d_api.h
-)
-
-set_target_properties(types_slam2d PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_slam2d)
-if (APPLE)
-  set_target_properties(types_slam2d PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_slam2d core)
-if(G2O_HAVE_OPENGL)
-  target_link_libraries(types_slam2d opengl_helper ${OPENGL_gl_LIBRARY} )
-endif()
-
-install(TARGETS types_slam2d
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/slam2d)
diff --git a/g2o/types/slam2d/edge_pointxy.cpp b/g2o/types/slam2d/edge_pointxy.cpp
deleted file mode 100644
index f0bf5994..00000000
--- a/g2o/types/slam2d/edge_pointxy.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_pointxy.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  EdgePointXY::EdgePointXY() :
-    BaseBinaryEdge<2, Vector2, VertexPointXY, VertexPointXY>()
-  {
-    _information.setIdentity();
-    _error.setZero();
-  }
-
-  bool EdgePointXY::read(std::istream& is)
-  {
-    Vector2 p;
-    internal::readVector(is, p);
-    setMeasurement(p);
-    readInformationMatrix(is);
-    return true;
-  }
-
-  bool EdgePointXY::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-  void EdgePointXY::linearizeOplus()
-  {
-    _jacobianOplusXi=-Matrix2::Identity();
-    _jacobianOplusXj= Matrix2::Identity();
-  }
-#endif
-
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_pointxy.h b/g2o/types/slam2d/edge_pointxy.h
deleted file mode 100644
index 8fed9f4b..00000000
--- a/g2o/types/slam2d/edge_pointxy.h
+++ /dev/null
@@ -1,86 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_POINTXY_H
-#define G2O_EDGE_POINTXY_H
-
-#include "vertex_point_xy.h"
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_API EdgePointXY : public BaseBinaryEdge<2, Vector2, VertexPointXY, VertexPointXY>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgePointXY();
-
-      void computeError()
-      {
-        const VertexPointXY* v1 = static_cast<const VertexPointXY*>(_vertices[0]);
-        const VertexPointXY* v2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        _error = (v2->estimate()-v1->estimate())-_measurement;
-      }
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void setMeasurement(const Vector2& m){
-        _measurement = m;
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        _measurement=Vector2(d[0], d[1]);
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-        Eigen::Map<Vector2> m(d);
-        m = _measurement;
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 2;}
-
-      virtual bool setMeasurementFromState() {
-        const VertexPointXY* v1 = static_cast<const VertexPointXY*>(_vertices[0]);
-        const VertexPointXY* v2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        _measurement = v2->estimate()-v1->estimate();
-        return true;
-      }
-
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 0;}
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-      virtual void linearizeOplus();
-#endif
-  };
-
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/edge_se2.cpp b/g2o/types/slam2d/edge_se2.cpp
deleted file mode 100644
index 4f392cad..00000000
--- a/g2o/types/slam2d/edge_se2.cpp
+++ /dev/null
@@ -1,191 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  EdgeSE2::EdgeSE2() :
-    BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>()
-  {
-  }
-
-  bool EdgeSE2::read(std::istream& is)
-  {
-    Vector3 p;
-    internal::readVector(is, p);
-    setMeasurement(SE2(p));
-    _inverseMeasurement = measurement().inverse();
-    readInformationMatrix(is);
-    return is.good() || is.eof();
-  }
-
-  bool EdgeSE2::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement().toVector());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /* to */)
-  {
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(_vertices[0]);
-    VertexSE2* toEdge   = static_cast<VertexSE2*>(_vertices[1]);
-    if (from.count(fromEdge) > 0)
-      toEdge->setEstimate(fromEdge->estimate() * _measurement);
-    else
-      fromEdge->setEstimate(toEdge->estimate() * _inverseMeasurement);
-  }
-
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-  void EdgeSE2::linearizeOplus()
-  {
-    const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
-    const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
-    number_t thetai = vi->estimate().rotation().angle();
-
-    Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
-    number_t si=std::sin(thetai), ci=std::cos(thetai);
-
-    _jacobianOplusXi <<
-        -ci, -si, -si*dt.x()+ci*dt.y(),
-         si, -ci, -ci*dt.x()-si*dt.y(),
-         0,  0,   -1;
-
-    _jacobianOplusXj <<
-         ci, si, 0,
-        -si, ci, 0,
-         0,  0,  1;
-
-    const SE2& rmean = _inverseMeasurement;
-    Matrix3 z;
-    z.block<2, 2>(0, 0) = rmean.rotation().toRotationMatrix();
-    z.col(2) << cst(0.), cst(0.), cst(1.);
-    z.row(2).head<2>() << cst(0.), cst(0.);
-    _jacobianOplusXi = z * _jacobianOplusXi;
-    _jacobianOplusXj = z * _jacobianOplusXj;
-  }
-#endif
-
-  EdgeSE2WriteGnuplotAction::EdgeSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSE2).name()){}
-
-  HyperGraphElementAction* EdgeSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    EdgeSE2* e =  static_cast<EdgeSE2*>(element);
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
-    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
-      << " " << fromEdge->estimate().rotation().angle() << std::endl;
-    *(params->os) << toEdge->estimate().translation().x() << " " << toEdge->estimate().translation().y()
-      << " " << toEdge->estimate().rotation().angle() << std::endl;
-    *(params->os) << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE2DrawAction::EdgeSE2DrawAction()
-      : DrawAction(typeid(EdgeSE2).name()), _triangleX(nullptr), _triangleY(nullptr) {}
-
-  bool EdgeSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_X", .2f);
-      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_Y", .05f);
-    } else {
-      _triangleX = 0;
-      _triangleY = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* EdgeSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
-               HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    EdgeSE2* e =  static_cast<EdgeSE2*>(element);
-    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
-    VertexSE2* to   = static_cast<VertexSE2*>(e->vertex(1));
-    if (! from && ! to)
-      return this;
-    SE2 fromTransform;
-    SE2 toTransform;
-    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
-    glDisable(GL_LIGHTING);
-    if (! from) {
-      glColor3f(POSE_EDGE_GHOST_COLOR);
-      toTransform = to->estimate();
-      fromTransform = to->estimate()*e->measurement().inverse();
-      // DRAW THE FROM EDGE AS AN ARROW
-      glPushMatrix();
-      glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(),0.f);
-      glRotatef((float)RAD2DEG(fromTransform.rotation().angle()),0.f,0.f,1.f);
-      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
-      glPopMatrix();
-    } else if (! to){
-      glColor3f(POSE_EDGE_GHOST_COLOR);
-      fromTransform = from->estimate();
-      toTransform = from->estimate()*e->measurement();
-      // DRAW THE TO EDGE AS AN ARROW
-      glPushMatrix();
-      glTranslatef(toTransform.translation().x(),toTransform.translation().y(),0.f);
-      glRotatef((float)RAD2DEG(toTransform.rotation().angle()),0.f,0.f,1.f);
-      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
-      glPopMatrix();
-    } else {
-      glColor3f(POSE_EDGE_COLOR);
-      fromTransform = from->estimate();
-      toTransform = to->estimate();
-    }
-    glBegin(GL_LINES);
-    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),0.f);
-    glVertex3f((float)toTransform.translation().x(),(float)toTransform.translation().y(),0.f);
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_se2.h b/g2o/types/slam2d/edge_se2.h
deleted file mode 100644
index b3aa12e2..00000000
--- a/g2o/types/slam2d/edge_se2.h
+++ /dev/null
@@ -1,116 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_H
-#define G2O_EDGE_SE2_H
-
-#include "vertex_se2.h"
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief 2D edge between two Vertex2
-   */
-  class G2O_TYPES_SLAM2D_API EdgeSE2 : public BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-        EdgeSE2();
-
-      void computeError()
-      {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
-        SE2 delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
-        _error = delta.toVector();
-      }
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void setMeasurement(const SE2& m){
-        _measurement = m;
-        _inverseMeasurement = m.inverse();
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        _measurement=SE2(d[0], d[1], d[2]);
-        _inverseMeasurement = _measurement.inverse();
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-        Vector3 v=_measurement.toVector();
-        d[0] = v[0];
-        d[1] = v[1];
-        d[2] = v[2];
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 3;}
-
-      virtual bool setMeasurementFromState() {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
-        _measurement = v1->estimate().inverse()*v2->estimate();
-        _inverseMeasurement = _measurement.inverse();
-        return true;
-      }
-
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-      virtual void linearizeOplus();
-#endif
-    protected:
-      SE2 _inverseMeasurement;
-  };
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2WriteGnuplotAction: public WriteGnuplotAction {
-  public:
-    EdgeSE2WriteGnuplotAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_);
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM2D_API EdgeSE2DrawAction: public DrawAction{
-  public:
-    EdgeSE2DrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_);
-  protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    FloatProperty *_triangleX, *_triangleY;
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/edge_se2_lotsofxy.cpp b/g2o/types/slam2d/edge_se2_lotsofxy.cpp
deleted file mode 100644
index 69e31f54..00000000
--- a/g2o/types/slam2d/edge_se2_lotsofxy.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_lotsofxy.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_primitives.h"
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-namespace g2o {
-
-EdgeSE2LotsOfXY::EdgeSE2LotsOfXY() : BaseMultiEdge<-1, VectorX>(), _observedPoints(0) { resize(0); }
-
-void EdgeSE2LotsOfXY::computeError() {
-  VertexSE2* pose = static_cast<VertexSE2*>(_vertices[0]);
-
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    VertexPointXY* xy = static_cast<VertexPointXY*>(_vertices[1 + i]);
-    Vector2 m = pose->estimate().inverse() * xy->estimate();
-
-    unsigned int index = 2 * i;
-    _error[index] = m[0] - _measurement[index];
-    _error[index + 1] = m[1] - _measurement[index + 1];
-  }
-}
-
-bool EdgeSE2LotsOfXY::read(std::istream& is) {
-  is >> _observedPoints;
-  setSize(_observedPoints + 1);
-
-  // read the measurements
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    unsigned int index = 2 * i;
-    is >> _measurement[index] >> _measurement[index + 1];
-  }
-
-  // read the information matrix
-  for (unsigned int i = 0; i < _observedPoints * 2; i++) {
-    // fill the "upper triangle" part of the matrix
-    for (unsigned int j = i; j < _observedPoints * 2; j++) {
-      is >> information()(i, j);
-    }
-
-    // fill the lower triangle part
-    for (unsigned int j = 0; j < i; j++) {
-      information()(i, j) = information()(j, i);
-    }
-  }
-
-  return true;
-}
-
-bool EdgeSE2LotsOfXY::write(std::ostream& os) const {
-  // write number of observed points
-  os << "|| " << _observedPoints;
-
-  // write measurements
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    unsigned int index = 2 * i;
-    os << " " << _measurement[index] << " " << _measurement[index + 1];
-  }
-
-  // write information matrix
-  for (unsigned int i = 0; i < _observedPoints * 2; i++) {
-    for (unsigned int j = i; j < _observedPoints * 2; j++) {
-      os << " " << information()(i, j);
-    }
-  }
-
-  return os.good();
-}
-
-void EdgeSE2LotsOfXY::linearizeOplus() {
-  const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
-  const number_t& x1 = vi->estimate().translation()[0];
-  const number_t& y1 = vi->estimate().translation()[1];
-  const number_t& th1 = vi->estimate().rotation().angle();
-
-  number_t ct = std::cos(th1);
-  number_t st = std::sin(th1);
-
-  MatrixX Ji;
-  unsigned int rows = 2 * (_vertices.size() - 1);
-  Ji.resize(rows, 3);
-  Ji.fill(0);
-
-  Matrix2 poseRot;  // inverse of the rotation matrix associated to the pose
-  poseRot << ct, st, -st, ct;
-
-  Matrix2 minusPoseRot = -poseRot;
-
-  for (unsigned int i = 1; i < _vertices.size(); i++) {
-    g2o::VertexPointXY* point = (g2o::VertexPointXY*)(_vertices[i]);
-
-    const number_t& x2 = point->estimate()[0];
-    const number_t& y2 = point->estimate()[1];
-
-    unsigned int index = 2 * (i - 1);
-
-    Ji.block<2, 2>(index, 0) = minusPoseRot;
-
-    Ji(index, 2) = ct * (y2 - y1) + st * (x1 - x2);
-    Ji(index + 1, 2) = st * (y1 - y2) + ct * (x1 - x2);
-
-    MatrixX Jj;
-    Jj.resize(rows, 2);
-    Jj.fill(0);
-    Jj.block<2, 2>(index, 0) = poseRot;
-
-    _jacobianOplus[i] = Jj;
-  }
-  _jacobianOplus[0] = Ji;
-}
-
-void EdgeSE2LotsOfXY::initialEstimate(const OptimizableGraph::VertexSet& fixed, OptimizableGraph::Vertex* toEstimate) {
-  (void)toEstimate;
-
-  assert(initialEstimatePossible(fixed, toEstimate) && "Bad vertices specified");
-
-  VertexSE2* pose = static_cast<VertexSE2*>(_vertices[0]);
-
-#ifdef _MSC_VER
-  std::vector<bool> estimate_this(_observedPoints, true);
-#else
-  bool estimate_this[_observedPoints];
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    estimate_this[i] = true;
-  }
-#endif
-
-  for (std::set<HyperGraph::Vertex*>::iterator it = fixed.begin(); it != fixed.end(); ++it) {
-    for (unsigned int i = 1; i < _vertices.size(); i++) {
-      VertexPointXY* vert = static_cast<VertexPointXY*>(_vertices[i]);
-      if (vert->id() == (*it)->id()) estimate_this[i - 1] = false;
-    }
-  }
-
-  for (unsigned int i = 1; i < _vertices.size(); i++) {
-    if (estimate_this[i - 1]) {
-      unsigned int index = 2 * (i - 1);
-      Vector2 submeas(_measurement[index], _measurement[index + 1]);
-      VertexPointXY* vert = static_cast<VertexPointXY*>(_vertices[i]);
-      vert->setEstimate(pose->estimate() * submeas);
-    }
-  }
-}
-
-number_t EdgeSE2LotsOfXY::initialEstimatePossible(const OptimizableGraph::VertexSet& fixed,
-                                                  OptimizableGraph::Vertex* toEstimate) {
-  (void)toEstimate;
-
-  for (std::set<HyperGraph::Vertex*>::iterator it = fixed.begin(); it != fixed.end(); ++it) {
-    if (_vertices[0]->id() == (*it)->id()) {
-      return 1.0;
-    }
-  }
-
-  return -1.0;
-}
-
-bool EdgeSE2LotsOfXY::setMeasurementFromState() {
-  VertexSE2* pose = static_cast<VertexSE2*>(_vertices[0]);
-
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    VertexPointXY* xy = static_cast<VertexPointXY*>(_vertices[1 + i]);
-    Vector2 m = pose->estimate().inverse() * xy->estimate();
-
-    unsigned int index = 2 * i;
-    _measurement[index] = m[0];
-    _measurement[index + 1] = m[1];
-  }
-
-  return true;
-}
-
-}  // end namespace g2o
diff --git a/g2o/types/slam2d/edge_se2_lotsofxy.h b/g2o/types/slam2d/edge_se2_lotsofxy.h
deleted file mode 100644
index 23156426..00000000
--- a/g2o/types/slam2d/edge_se2_lotsofxy.h
+++ /dev/null
@@ -1,70 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_LOTSOF_XY
-#define G2O_EDGE_SE2_LOTSOF_XY
-
-#include "g2o/config.h"
-#include "g2o_types_slam2d_api.h"
-#include "g2o/core/base_multi_edge.h"
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2LotsOfXY : public BaseMultiEdge<-1,VectorX>
-  {
-    protected:
-      unsigned int _observedPoints;
-
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE2LotsOfXY();
-
-      void setSize(int vertices)
-      {
-        resize(vertices);
-        _observedPoints = vertices-1;
-        _measurement.resize(_observedPoints*2, 1);
-        setDimension(_observedPoints*2);
-      }
-
-      virtual void computeError();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual bool setMeasurementFromState();
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*);
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*);
-
-      virtual void linearizeOplus();
-  };
-
-} // end namespace g2o
-
-#endif	// G2O_EDGE_SE2_LOTSOF_XY
diff --git a/g2o/types/slam2d/edge_se2_offset.cpp b/g2o/types/slam2d/edge_se2_offset.cpp
deleted file mode 100644
index 25c855c5..00000000
--- a/g2o/types/slam2d/edge_se2_offset.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_offset.h"
-
-#include "parameter_se2_offset.h"
-
-#include <iostream>
-
-namespace g2o {
-  using namespace std;
-
-  EdgeSE2Offset::EdgeSE2Offset() : BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>() {
-    information().setIdentity();
-    _offsetFrom = 0;
-    _offsetTo = 0;
-    _cacheFrom = 0;
-    _cacheTo = 0;
-    resizeParameters(2);
-    installParameter(_offsetFrom, 0);
-    installParameter(_offsetTo, 1);
-  }
-
-  bool EdgeSE2Offset::resolveCaches(){
-    assert(_offsetFrom && _offsetTo);
-
-    ParameterVector pv(1);
-    pv[0]=_offsetFrom;
-    resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],"CACHE_SE2_OFFSET",pv);
-    pv[0]=_offsetTo;
-    resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],"CACHE_SE2_OFFSET",pv);
-    return (_cacheFrom && _cacheTo);
-  }
-
-  bool EdgeSE2Offset::read(std::istream& is) {
-    int pidFrom, pidTo;
-    is >> pidFrom >> pidTo;
-    if (! setParameterId(0,pidFrom))
-      return false;
-    if (! setParameterId(1,pidTo))
-      return false;
-
-    Vector3 meas;
-    internal::readVector(is, meas);
-    setMeasurement(SE2(meas));
-    if (is.bad()) return false;
-    readInformationMatrix(is);
-    if (is.bad()) {
-      //  we overwrite the information matrix with the Identity
-      information().setIdentity();
-    }
-    return true;
-  }
-
-  bool EdgeSE2Offset::write(std::ostream& os) const {
-    os << _offsetFrom->id() << " " << _offsetTo->id() << " ";
-    internal::writeVector(os, measurement().toVector());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2Offset::computeError() {
-    SE2 delta=_inverseMeasurement * _cacheFrom->w2n() * _cacheTo->n2w();
-    _error.head<2>() = delta.translation();
-    _error(2)=delta.rotation().angle();
-  }
-
-  bool EdgeSE2Offset::setMeasurementFromState(){
-    SE2 delta = _cacheFrom->w2n() * _cacheTo->n2w();
-    setMeasurement(delta);
-    return true;
-  }
-
-  void EdgeSE2Offset::initialEstimate(const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* /*to_*/) {
-    VertexSE2 *from = static_cast<VertexSE2*>(_vertices[0]);
-    VertexSE2 *to   = static_cast<VertexSE2*>(_vertices[1]);
-
-    SE2 virtualMeasurement = _cacheFrom->offsetParam()->offset() * measurement() * _cacheTo->offsetParam()->offset().inverse();
-
-    if (from_.count(from) > 0)
-      to->setEstimate(from->estimate() * virtualMeasurement);
-    else
-      from->setEstimate(to->estimate() * virtualMeasurement.inverse());
-  }
-
-}
diff --git a/g2o/types/slam2d/edge_se2_offset.h b/g2o/types/slam2d/edge_se2_offset.h
deleted file mode 100644
index bb1bcd2e..00000000
--- a/g2o/types/slam2d/edge_se2_offset.h
+++ /dev/null
@@ -1,93 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_OFFSET_H_
-#define G2O_EDGE_SE2_OFFSET_H_
-
-#include "g2o/core/base_binary_edge.h"
-
-#include "vertex_se2.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  class ParameterSE2Offset;
-  class CacheSE2Offset;
-
-  /**
-   * \brief Offset edge
-   */
-  // first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_SLAM2D_API EdgeSE2Offset : public BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2> {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE2Offset();
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      void computeError();
-
-      // jacobian
-      //virtual void linearizeOplus();
-
-      virtual void setMeasurement(const SE2& m){
-        _measurement = m;
-        _inverseMeasurement = m.inverse();
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        Eigen::Map<const Vector3> v(d);
-        _measurement.fromVector(v);
-        _inverseMeasurement = _measurement.inverse();
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const{
-        Eigen::Map<Vector3> v(d);
-        v = _measurement.toVector();
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 3;}
-
-      virtual bool setMeasurementFromState() ;
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& /*from*/,
-                                               OptimizableGraph::Vertex* /*to*/) {
-        return 1.;
-      }
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    protected:
-      SE2 _inverseMeasurement;
-      virtual bool resolveCaches();
-      ParameterSE2Offset *_offsetFrom, *_offsetTo;
-      CacheSE2Offset  *_cacheFrom, *_cacheTo;
-  };
-
-} // end namespace
-#endif
diff --git a/g2o/types/slam2d/edge_se2_pointxy.cpp b/g2o/types/slam2d/edge_se2_pointxy.cpp
deleted file mode 100644
index 6c3308d7..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_pointxy.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  EdgeSE2PointXY::EdgeSE2PointXY() :
-    BaseBinaryEdge<2, Vector2, VertexSE2, VertexPointXY>()
-  {
-  }
-
-  bool EdgeSE2PointXY::read(std::istream& is)
-  {
-    internal::readVector(is, _measurement);
-    readInformationMatrix(is);
-    return true;
-  }
-
-  bool EdgeSE2PointXY::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2PointXY::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-  {
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexSE2 position by VertexPointXY");
-
-    VertexSE2* vi     = static_cast<VertexSE2*>(_vertices[0]);
-    VertexPointXY* vj = static_cast<VertexPointXY*>(_vertices[1]);
-    if (from.count(vi) > 0 && to == vj) {
-      vj->setEstimate(vi->estimate() * _measurement);
-    }
-  }
-
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-  void EdgeSE2PointXY::linearizeOplus()
-  {
-    const VertexSE2* vi     = static_cast<const VertexSE2*>(_vertices[0]);
-    const VertexPointXY* vj = static_cast<const VertexPointXY*>(_vertices[1]);
-    const number_t& x1        = vi->estimate().translation()[0];
-    const number_t& y1        = vi->estimate().translation()[1];
-    const number_t& th1       = vi->estimate().rotation().angle();
-    const number_t& x2        = vj->estimate()[0];
-    const number_t& y2        = vj->estimate()[1];
-
-    number_t aux_1 = std::cos(th1) ;
-    number_t aux_2 = -aux_1 ;
-    number_t aux_3 = std::sin(th1) ;
-
-    _jacobianOplusXi( 0 , 0 ) = aux_2 ;
-    _jacobianOplusXi( 0 , 1 ) = -aux_3 ;
-    _jacobianOplusXi( 0 , 2 ) = aux_1*y2-aux_1*y1-aux_3*x2+aux_3*x1 ;
-    _jacobianOplusXi( 1 , 0 ) = aux_3 ;
-    _jacobianOplusXi( 1 , 1 ) = aux_2 ;
-    _jacobianOplusXi( 1 , 2 ) = -aux_3*y2+aux_3*y1-aux_1*x2+aux_1*x1 ;
-
-    _jacobianOplusXj( 0 , 0 ) = aux_1 ;
-    _jacobianOplusXj( 0 , 1 ) = aux_3 ;
-    _jacobianOplusXj( 1 , 0 ) = -aux_3 ;
-    _jacobianOplusXj( 1 , 1 ) = aux_1 ;
-  }
-#endif
-
-  EdgeSE2PointXYWriteGnuplotAction::EdgeSE2PointXYWriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSE2PointXY).name()){}
-
-  HyperGraphElementAction* EdgeSE2PointXYWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    EdgeSE2PointXY* e =  static_cast<EdgeSE2PointXY*>(element);
-    if (e->numUndefinedVertices())
-      return this;
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-    VertexPointXY* toEdge   = static_cast<VertexPointXY*>(e->vertex(1));
-    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
-      << " " << fromEdge->estimate().rotation().angle() << std::endl;
-    *(params->os) << toEdge->estimate().x() << " " << toEdge->estimate().y() << std::endl;
-    *(params->os) << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE2PointXYDrawAction::EdgeSE2PointXYDrawAction(): DrawAction(typeid(EdgeSE2PointXY).name()){}
-
-  HyperGraphElementAction* EdgeSE2PointXYDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                HyperGraphElementAction::Parameters*  params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-
-    EdgeSE2PointXY* e =  static_cast<EdgeSE2PointXY*>(element);
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-    VertexPointXY* toEdge   = static_cast<VertexPointXY*>(e->vertex(1));
-    if (! fromEdge)
-      return this;
-    Vector2 p=e->measurement();
-    glPushAttrib(GL_ENABLE_BIT|GL_LIGHTING|GL_COLOR);
-    glDisable(GL_LIGHTING);
-    if (!toEdge){
-      p=fromEdge->estimate()*p;
-      glColor3f(LANDMARK_EDGE_GHOST_COLOR);
-      glPushAttrib(GL_POINT_SIZE);
-      glPointSize(3);
-      glBegin(GL_POINTS);
-      glVertex3f((float)p.x(),(float)p.y(),0.f);
-      glEnd();
-      glPopAttrib();
-    } else {
-      p=toEdge->estimate();
-      glColor3f(LANDMARK_EDGE_COLOR);
-    }
-    glBegin(GL_LINES);
-    glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),0.f);
-    glVertex3f((float)p.x(),(float)p.y(),0.f);
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_se2_pointxy.h b/g2o/types/slam2d/edge_se2_pointxy.h
deleted file mode 100644
index dfed0e82..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_POINT_XY_H
-#define G2O_EDGE_SE2_POINT_XY_H
-
-#include "g2o/config.h"
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXY : public BaseBinaryEdge<2, Vector2, VertexSE2, VertexPointXY>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      EdgeSE2PointXY();
-
-      void computeError()
-      {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexPointXY* l2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        _error = (v1->estimate().inverse() * l2->estimate()) - _measurement;
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        _measurement[0]=d[0];
-        _measurement[1]=d[1];
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const{
-        d[0] = _measurement[0];
-        d[1] = _measurement[1];
-        return true;
-      }
-      
-      virtual int measurementDimension() const {return 2;}
-
-      virtual bool setMeasurementFromState(){
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexPointXY* l2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        _measurement = v1->estimate().inverse() * l2->estimate();
-        return true;
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) { (void) to; return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);}
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-      virtual void linearizeOplus();
-#endif
-  };
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYWriteGnuplotAction: public WriteGnuplotAction {
-  public:
-    EdgeSE2PointXYWriteGnuplotAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYDrawAction: public DrawAction{
-  public:
-    EdgeSE2PointXYDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/edge_se2_pointxy_bearing.cpp b/g2o/types/slam2d/edge_se2_pointxy_bearing.cpp
deleted file mode 100644
index d2a9d89f..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy_bearing.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_pointxy_bearing.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  EdgeSE2PointXYBearing::EdgeSE2PointXYBearing()
-  {
-  }
-
-
-  void EdgeSE2PointXYBearing::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to*/)
-  {
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexSE2 position by VertexPointXY");
-
-    if (from.count(_vertices[0]) != 1)
-      return;
-    number_t r=2.;
-    const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-    VertexPointXY* l2 = static_cast<VertexPointXY*>(_vertices[1]);
-    SE2 t=v1->estimate();
-    t.setRotation(t.rotation()*Rotation2D(_measurement));
-    Vector2 vr(r, 0.);
-    l2->setEstimate(t*vr);
-  }
-
-  bool EdgeSE2PointXYBearing::read(std::istream& is)
-  {
-    is >> _measurement >> information()(0,0);
-    return true;
-  }
-
-  bool EdgeSE2PointXYBearing::write(std::ostream& os) const
-  {
-    os << measurement() << " " << information()(0,0);
-    return os.good();
-  }
-
-
-  EdgeSE2PointXYBearingWriteGnuplotAction::EdgeSE2PointXYBearingWriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSE2PointXYBearing).name()){}
-
-  HyperGraphElementAction* EdgeSE2PointXYBearingWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element,
-                         HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    EdgeSE2PointXYBearing* e =  static_cast<EdgeSE2PointXYBearing*>(element);
-    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-    VertexPointXY* toEdge   = static_cast<VertexPointXY*>(e->vertex(1));
-    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
-      << " " << fromEdge->estimate().rotation().angle() << std::endl;
-    *(params->os) << toEdge->estimate().x() << " " << toEdge->estimate().y() << std::endl;
-    *(params->os) << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE2PointXYBearingDrawAction::EdgeSE2PointXYBearingDrawAction(): DrawAction(typeid(EdgeSE2PointXYBearing).name()){}
-
-  HyperGraphElementAction* EdgeSE2PointXYBearingDrawAction::operator()(HyperGraph::HyperGraphElement* element,  HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-    
-    if (_show && !_show->value())
-      return this;
-
-    EdgeSE2PointXYBearing* e =  static_cast<EdgeSE2PointXYBearing*>(element);
-    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
-    VertexPointXY* to   = static_cast<VertexPointXY*>(e->vertex(1));
-    if (! from)
-      return this;
-    number_t guessRange=5;
-    number_t theta = e->measurement();
-    Vector2 p(std::cos(theta)*guessRange, std::sin(theta)*guessRange);
-    glPushAttrib(GL_ENABLE_BIT|GL_LIGHTING|GL_COLOR);
-    glDisable(GL_LIGHTING);
-    if (!to){
-      p=from->estimate()*p;
-      glColor3f(LANDMARK_EDGE_GHOST_COLOR);
-      glPushAttrib(GL_POINT_SIZE);
-      glPointSize(3);
-      glBegin(GL_POINTS);
-      glVertex3f((float)p.x(),(float)p.y(),0.f);
-      glEnd();
-      glPopAttrib();
-    } else {
-      p=to->estimate();
-      glColor3f(LANDMARK_EDGE_COLOR);
-    }
-    glBegin(GL_LINES);
-    glVertex3f((float)from->estimate().translation().x(),(float)from->estimate().translation().y(),0.f);
-    glVertex3f((float)p.x(),(float)p.y(),0.f);
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_se2_pointxy_bearing.h b/g2o/types/slam2d/edge_se2_pointxy_bearing.h
deleted file mode 100644
index 224fbdae..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy_bearing.h
+++ /dev/null
@@ -1,98 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_POINT_XY_BEARING_H
-#define G2O_EDGE_SE2_POINT_XY_BEARING_H
-
-#include "g2o/config.h"
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYBearing: public BaseBinaryEdge<1, number_t, VertexSE2, VertexPointXY>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      EdgeSE2PointXYBearing();
-      void computeError()
-      {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexPointXY* l2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        Vector2 delta = (v1->estimate().inverse() * l2->estimate());
-        number_t angle = std::atan2(delta[1], delta[0]);
-        _error[0] = normalize_theta(_measurement - angle );
-      }
-
-
-      virtual bool setMeasurementData(const number_t* d) {
-        _measurement=d[0];
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-        d[0] = _measurement;
-        return true;
-      }
-
-      int measurementDimension() const {return 1;}
-
-      virtual bool setMeasurementFromState(){
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexPointXY* l2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        Vector2 delta = (v1->estimate().inverse() * l2->estimate());
-        _measurement = std::atan2(delta[1], delta[0]);
-        return true;
-      }
-      
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex*) { return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);}
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-  };
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYBearingWriteGnuplotAction: public WriteGnuplotAction {
-  public:
-    EdgeSE2PointXYBearingWriteGnuplotAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYBearingDrawAction: public DrawAction{
-  public:
-    EdgeSE2PointXYBearingDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/slam2d/edge_se2_pointxy_calib.cpp b/g2o/types/slam2d/edge_se2_pointxy_calib.cpp
deleted file mode 100644
index 667b3cb8..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy_calib.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_pointxy_calib.h"
-
-namespace g2o {
-
-  EdgeSE2PointXYCalib::EdgeSE2PointXYCalib() :
-    BaseMultiEdge<2, Vector2>()
-  {
-    resize(3);
-  }
-
-  void EdgeSE2PointXYCalib::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to*/)
-  {
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexSE2 position by VertexPointXY");
-
-    if (from.count(_vertices[0]) != 1)
-      return;
-    VertexSE2* vi     = static_cast<VertexSE2*>(_vertices[0]);
-    VertexPointXY* vj = static_cast<VertexPointXY*>(_vertices[1]);
-    vj->setEstimate(vi->estimate() * _measurement);
-  }
-
-  bool EdgeSE2PointXYCalib::read(std::istream& is)
-  {
-    internal::readVector(is, _measurement);
-    readInformationMatrix(is);
-    return true;
-  }
-
-  bool EdgeSE2PointXYCalib::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_se2_pointxy_calib.h b/g2o/types/slam2d/edge_se2_pointxy_calib.h
deleted file mode 100644
index 36cf9221..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy_calib.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_XY_CALIB_H
-#define G2O_EDGE_SE2_XY_CALIB_H
-
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-#include "g2o/core/base_multi_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief Landmark measurement that also calibrates an offset for the landmark measurement
-   */
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYCalib : public BaseMultiEdge<2, Vector2>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      EdgeSE2PointXYCalib();
-
-      void computeError()
-      {
-        const VertexSE2* v1     = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexPointXY* l2 = static_cast<const VertexPointXY*>(_vertices[1]);
-        const VertexSE2* calib  = static_cast<const VertexSE2*>(_vertices[2]);
-        _error = ((v1->estimate() * calib->estimate()).inverse() * l2->estimate()) - _measurement;
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) { (void) to; return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);}
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-  };
-
-}
-
-#endif
diff --git a/g2o/types/slam2d/edge_se2_pointxy_offset.cpp b/g2o/types/slam2d/edge_se2_pointxy_offset.cpp
deleted file mode 100644
index b1ac9af6..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy_offset.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "parameter_se2_offset.h"
-#include "edge_se2_pointxy_offset.h"
-#include <iostream>
-
-namespace g2o {
-  using namespace std;
-
-
-  // point to camera projection, monocular
-  EdgeSE2PointXYOffset::EdgeSE2PointXYOffset() : BaseBinaryEdge<2, Vector2, VertexSE2, VertexPointXY>() {
-    information().setIdentity();
-    cache = 0;
-    offsetParam = 0;
-    resizeParameters(1);
-    installParameter(offsetParam, 0);
-  }
-
-  bool EdgeSE2PointXYOffset::resolveCaches(){
-    ParameterVector pv(1);
-    pv[0]=offsetParam;
-    resolveCache(cache, (OptimizableGraph::Vertex*)_vertices[0],"CACHE_SE2_OFFSET",pv);
-    return cache != 0;
-  }
-
-
-  bool EdgeSE2PointXYOffset::read(std::istream& is) {
-    int pId;
-    is >> pId;
-    setParameterId(0, pId);
-    // measured keypoint
-    internal::readVector(is, _measurement);
-    if (is.bad()) return false;
-    readInformationMatrix(is);
-    //  we overwrite the information matrix in case of read errors
-    if (is.bad()) information().setIdentity();
-    return true;
-  }
-
-  bool EdgeSE2PointXYOffset::write(std::ostream& os) const {
-    os << offsetParam->id() << " ";
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2PointXYOffset::computeError() {
-    // from cam to point (track)
-    // VertexSE2 *rob = static_cast<VertexSE2*>(_vertices[0]);
-    VertexPointXY *point = static_cast<VertexPointXY*>(_vertices[1]);
-
-    Vector2 perr = cache->w2lMatrix() * point->estimate();
-
-    // error, which is backwards from the normal observed - calculated
-    // _measurement is the measured projection
-    _error = perr - _measurement;
-  }
-
-  void EdgeSE2PointXYOffset::linearizeOplus() {
-    VertexSE2 *rob = static_cast<VertexSE2*>(_vertices[0]);
-    VertexPointXY *point = static_cast<VertexPointXY*>(_vertices[1]);
-    _jacobianOplusXi.block<2,2>(0,0) = - cache->RpInverseRInverseMatrix();
-    _jacobianOplusXi.block<2,1>(0,2) = cache->RpInverseRInversePrimeMatrix()*(point->estimate()-rob->estimate().translation());
-    _jacobianOplusXj = cache->RpInverseRInverseMatrix();
-  }
-
-
-  bool EdgeSE2PointXYOffset::setMeasurementFromState(){
-    VertexPointXY *point = static_cast<VertexPointXY*>(_vertices[1]);
-
-    _measurement = cache->w2lMatrix() * point->estimate();
-    return true;
-  }
-
-
-  void EdgeSE2PointXYOffset::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
-  {
-    (void) from;
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexDepthCam position by VertexTrackXY");
-
-    VertexSE2 *cam = dynamic_cast<VertexSE2*>(_vertices[0]);
-    VertexPointXY *point = dynamic_cast<VertexPointXY*>(_vertices[1]);
-    // SE2OffsetCache* vcache = (SE2OffsetCache* ) cam->getCache(_cacheIds[0]);
-    // if (! vcache){
-    //   cerr << "fatal error in retrieving cache" << endl;
-    // }
-    // SE2OffsetParameters* params=vcache->params;
-    Vector2 p=_measurement;
-    point->setEstimate(cam->estimate() * (offsetParam->offsetMatrix() * p));
-  }
-
-}
diff --git a/g2o/types/slam2d/edge_se2_pointxy_offset.h b/g2o/types/slam2d/edge_se2_pointxy_offset.h
deleted file mode 100644
index 3e57c862..00000000
--- a/g2o/types/slam2d/edge_se2_pointxy_offset.h
+++ /dev/null
@@ -1,89 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_POINT_XY_OFFSET_H_
-#define G2O_EDGE_SE2_POINT_XY_OFFSET_H_
-
-#include "g2o/core/base_binary_edge.h"
-
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-
-  /*! \class EdgeSE2PointXYOffset
-   * \brief g2o edge from a track to a point node
-   */
-  // first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_SLAM2D_API EdgeSE2PointXYOffset : public BaseBinaryEdge<2, Vector2, VertexSE2, VertexPointXY> {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSE2PointXYOffset();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    void computeError();
-    virtual void linearizeOplus();
-
-
-    virtual void setMeasurement(const Vector2& m){
-      _measurement = m;
-    }
-
-    virtual bool setMeasurementData(const number_t* d){
-      Eigen::Map<const Vector2> v(d);
-      _measurement = v;
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const{
-      Eigen::Map<Vector2> v(d);
-      v=_measurement;
-      return true;
-    }
-
-    virtual int measurementDimension() const {return 3;}
-
-    virtual bool setMeasurementFromState() ;
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
-      (void)to;
-      return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
-    }
-
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-  private:
-    ParameterSE2Offset* offsetParam;
-    CacheSE2Offset* cache;
-    virtual bool resolveCaches();
-
-  };
-
-}
-#endif
diff --git a/g2o/types/slam2d/edge_se2_prior.cpp b/g2o/types/slam2d/edge_se2_prior.cpp
deleted file mode 100644
index f1161d7d..00000000
--- a/g2o/types/slam2d/edge_se2_prior.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_prior.h"
-
-namespace g2o {
-
-  EdgeSE2Prior::EdgeSE2Prior() : BaseUnaryEdge<3, SE2, VertexSE2>()
-  {
-  }
-
-  void EdgeSE2Prior::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-  {
-    assert(from.size() == 0); (void) from; (void) to;
-    VertexSE2* v1 = static_cast<VertexSE2*>(_vertices[0]);
-    v1->setEstimate(_measurement);
-  }
-
-  bool EdgeSE2Prior::read(std::istream& is)
-  {
-    Vector3 p;
-    internal::readVector(is, p);
-    setMeasurement(p);
-    _inverseMeasurement= _measurement.inverse();
-    readInformationMatrix(is);
-    return true;
-  }
-
-  bool EdgeSE2Prior::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement().toVector());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2Prior::setMeasurement(const SE2& m)
-  {
-    _measurement = m;
-    _inverseMeasurement = m.inverse();
-  }
-
-  bool EdgeSE2Prior::setMeasurementData(const number_t* d) {
-    _measurement=SE2(d[0], d[1], d[2]);
-    _inverseMeasurement = _measurement.inverse();
-    return true;
-  }
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_se2_prior.h b/g2o/types/slam2d/edge_se2_prior.h
deleted file mode 100644
index 3c5f19b6..00000000
--- a/g2o/types/slam2d/edge_se2_prior.h
+++ /dev/null
@@ -1,81 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_PRIOR_H
-#define G2O_EDGE_SE2_PRIOR_H
-
-#include "vertex_se2.h"
-#include "g2o/core/base_unary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief Prior for a two D pose
-   */
-  class G2O_TYPES_SLAM2D_API EdgeSE2Prior : public BaseUnaryEdge<3, SE2, VertexSE2>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE2Prior();
-
-      void computeError()
-      {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        SE2 delta = _inverseMeasurement * v1->estimate();
-        _error = delta.toVector();
-      }
-
-      virtual void linearizeOplus() {
-        _jacobianOplusXi.setZero();
-        _jacobianOplusXi.block<2,2>(0,0)=_inverseMeasurement.rotation().toRotationMatrix();
-        _jacobianOplusXi(2,2)=1.;
-      }
-
-      virtual void setMeasurement(const SE2& m);
-      virtual bool setMeasurementData(const number_t* d);
-
-      virtual bool getMeasurementData(number_t* d) const {
-        Eigen::Map<Vector3> v(d);
-        v = _measurement.toVector();
-        return true;
-      }
-
-      int measurementDimension() const {return 3;}
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    protected:
-      SE2 _inverseMeasurement;
-  };
-
-}
-
-#endif
diff --git a/g2o/types/slam2d/edge_se2_twopointsxy.cpp b/g2o/types/slam2d/edge_se2_twopointsxy.cpp
deleted file mode 100644
index 7517895d..00000000
--- a/g2o/types/slam2d/edge_se2_twopointsxy.cpp
+++ /dev/null
@@ -1,136 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_twopointsxy.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-
-namespace g2o{
-
-  EdgeSE2TwoPointsXY::EdgeSE2TwoPointsXY() : BaseMultiEdge<4,Vector4>(){
-    resize(3);
-  }
-
-  void EdgeSE2TwoPointsXY::computeError(){
-    VertexSE2 * pose = static_cast<VertexSE2 *> (_vertices[0]);
-    VertexPointXY * xy1 = static_cast<VertexPointXY *> (_vertices[1]);
-    VertexPointXY * xy2 = static_cast<VertexPointXY *> (_vertices[2]);
-
-
-    Vector2 m1 = pose->estimate().inverse() * xy1->estimate();
-    Vector2 m2 = pose->estimate().inverse() * xy2->estimate();
-
-    _error[0] = m1[0] - _measurement[0];
-    _error[1] = m1[1] - _measurement[1];
-    _error[2] = m2[0] - _measurement[2];
-    _error[3] = m2[1] - _measurement[3];
-  }
-
-  bool EdgeSE2TwoPointsXY::read(std::istream& is){
-    is >> _measurement[0] >> _measurement[1] >> _measurement[2] >> _measurement[3];
-    is >> information()(0,0) >> information()(0,1) >> information()(0,2) >> information()(0,3) >> information()(1,1) >> information()(1,2) >> information()(1,3) >> information()(2,2) >> information()(2,3) >> information()(3,3);
-    information()(1,0) = information()(0,1);
-    information()(2,0) = information()(0,2);
-    information()(2,1) = information()(1,2);
-    information()(3,0) = information()(0,3);
-    information()(3,1) = information()(1,3);
-    information()(3,2) = information()(2,3);
-    return true;
-  }
-
-  bool EdgeSE2TwoPointsXY::write(std::ostream& os) const{
-    os << measurement()[0] << " " << measurement()[1] << " " << measurement()[2] << " "  << measurement()[3] << " ";
-    os << information()(0,0) << " " << information()(0,1) << " " << information()(0,2) << " " << information()(0,3) << " " << information()(1,1) << " " << information()(1,2) << " " << information()(1,3) << " " << information()(2,2) << " " << information()(2,3) << " " << information()(3,3);
-    return os.good();
-  }
-
-
-  void EdgeSE2TwoPointsXY::initialEstimate(const OptimizableGraph::VertexSet& fixed, OptimizableGraph::Vertex* toEstimate){
-    (void) toEstimate;
-
-    assert(initialEstimatePossible(fixed, toEstimate) && "Bad vertices specified");
-
-    VertexSE2 * pose = static_cast<VertexSE2 *>(_vertices[0]);
-    VertexPointXY * v1 = static_cast<VertexPointXY *>(_vertices[1]);
-    VertexPointXY * v2 = static_cast<VertexPointXY *>(_vertices[2]);
-
-    bool estimatev1 = true;
-    bool estimatev2 = true;
-
-    for(std::set<HyperGraph::Vertex*>::iterator it=fixed.begin(); it!=fixed.end(); ++it){
-      if(v1->id() == (*it)->id()){
-        estimatev1 = false;
-      }
-      else if(v2->id() == (*it)->id()){
-        estimatev2 = false;
-      }
-    }
-
-    if(estimatev1){
-      Vector2 submeas(_measurement[0], _measurement[1]);
-      v1->setEstimate(pose->estimate() * submeas);
-    }
-
-    if(estimatev2){
-      Vector2 submeas(_measurement[2], _measurement[3]);
-      v2->setEstimate(pose->estimate() * submeas);
-    }
-  }
-
-
-  number_t EdgeSE2TwoPointsXY::initialEstimatePossible(const OptimizableGraph::VertexSet& fixed, OptimizableGraph::Vertex* toEstimate){
-    (void) toEstimate;
-
-    for(std::set<HyperGraph::Vertex *>::iterator it=fixed.begin(); it!=fixed.end(); ++it){
-      if(_vertices[0]->id() == (*it)->id()){
-        return 1.0;
-      }
-    }
-    return -1.0;
-  }
-
-
-  bool EdgeSE2TwoPointsXY::setMeasurementFromState(){
-    VertexSE2 * pose = static_cast<VertexSE2 *> (_vertices[0]);
-    VertexPointXY * xy1 = static_cast<VertexPointXY *> (_vertices[1]);
-    VertexPointXY * xy2 = static_cast<VertexPointXY *> (_vertices[2]);
-
-
-    Vector2 m1 = pose->estimate().inverse() * xy1->estimate();
-    Vector2 m2 = pose->estimate().inverse() * xy2->estimate();
-
-    _measurement[0] = m1[0];
-    _measurement[1] = m1[1];
-    _measurement[2] = m2[0];
-    _measurement[3] = m2[1];
-    return true;
-  }
-
-} // end namespace g2o
diff --git a/g2o/types/slam2d/edge_se2_twopointsxy.h b/g2o/types/slam2d/edge_se2_twopointsxy.h
deleted file mode 100644
index 32a93a07..00000000
--- a/g2o/types/slam2d/edge_se2_twopointsxy.h
+++ /dev/null
@@ -1,55 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_TWOPOINTS_XY_H
-#define G2O_EDGE_SE2_TWOPOINTS_XY_H
-
-#include "g2o/config.h"
-#include "g2o_types_slam2d_api.h"
-#include "g2o/core/base_multi_edge.h"
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-
-namespace g2o{
-
-  class G2O_TYPES_SLAM2D_API EdgeSE2TwoPointsXY : public BaseMultiEdge<4, Vector4>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE2TwoPointsXY();
-
-      virtual void computeError();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual bool setMeasurementFromState();
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*);
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*);
-  };
-}
-#endif	// G2O_EDGE_SE2_TWOPOINTS_XY_H
diff --git a/g2o/types/slam2d/edge_se2_xyprior.cpp b/g2o/types/slam2d/edge_se2_xyprior.cpp
deleted file mode 100644
index 2227d1f0..00000000
--- a/g2o/types/slam2d/edge_se2_xyprior.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_xyprior.h"
-
-namespace g2o {
-
-  EdgeSE2XYPrior::EdgeSE2XYPrior() : BaseUnaryEdge< 2, Vector2, g2o::VertexSE2 >()
-  {
-
-  }
-
-  bool EdgeSE2XYPrior::read(std::istream& is)
-  {
-    internal::readVector(is, _measurement);
-    readInformationMatrix(is);
-    return true;
-  }
-
-  bool EdgeSE2XYPrior::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2XYPrior::linearizeOplus()
-  {
-    _jacobianOplusXi << 1,0,0, 0,1,0;
-  }
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_se2_xyprior.h b/g2o/types/slam2d/edge_se2_xyprior.h
deleted file mode 100644
index 145545d4..00000000
--- a/g2o/types/slam2d/edge_se2_xyprior.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_PRIOR_XY_H
-#define G2O_EDGE_SE2_PRIOR_XY_H
-
-#include "vertex_se2.h"
-#include "g2o/core/base_unary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief Prior for a two D pose with constraints only in xy direction (like gps)
-   */
-  class G2O_TYPES_SLAM2D_API EdgeSE2XYPrior : public BaseUnaryEdge<2, Vector2, VertexSE2>
-  {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    EdgeSE2XYPrior();
-
-    virtual bool setMeasurementData(const number_t* d)
-    {
-      _measurement[0]=d[0];
-      _measurement[1]=d[1];
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const
-    {
-      d[0] = _measurement[0];
-      d[1] = _measurement[1];
-      return true;
-    }
-
-    virtual int measurementDimension() const {return 2;}
-
-    virtual void linearizeOplus();
-
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-      
-    virtual void computeError()
-    {
-      const VertexSE2* v = static_cast<const VertexSE2*>(_vertices[0]);
-      _error = v->estimate().translation() - _measurement;
-    }
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/edge_xy_prior.cpp b/g2o/types/slam2d/edge_xy_prior.cpp
deleted file mode 100644
index e2d93ef2..00000000
--- a/g2o/types/slam2d/edge_xy_prior.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_xy_prior.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  EdgeXYPrior::EdgeXYPrior() :
-    BaseUnaryEdge<2, Vector2, VertexPointXY>()
-  {
-    _information.setIdentity();
-    _error.setZero();
-  }
-
-  bool EdgeXYPrior::read(std::istream& is)
-  {
-    internal::readVector(is, _measurement);
-    readInformationMatrix(is);
-    return true;
-  }
-
-  bool EdgeXYPrior::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-  void EdgeXYPrior::linearizeOplus()
-  {
-    _jacobianOplusXi=Matrix2::Identity();
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d/edge_xy_prior.h b/g2o/types/slam2d/edge_xy_prior.h
deleted file mode 100644
index 54799970..00000000
--- a/g2o/types/slam2d/edge_xy_prior.h
+++ /dev/null
@@ -1,84 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_XY_PRIOR_H
-#define G2O_EDGE_XY_PRIOR_H
-
-#include "vertex_point_xy.h"
-#include "g2o/config.h"
-#include "g2o/core/base_unary_edge.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_API EdgeXYPrior : public BaseUnaryEdge<2, Vector2, VertexPointXY>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-        EdgeXYPrior();
-
-      void computeError()
-      {
-        const VertexPointXY* v = static_cast<const VertexPointXY*>(_vertices[0]);
-        _error = v->estimate()-_measurement;
-      }
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void setMeasurement(const Vector2& m){
-        _measurement = m;
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        _measurement=Vector2(d[0], d[1]);
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-        Eigen::Map<Vector2> m(d);
-        m=_measurement;
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 2;}
-
-      virtual bool setMeasurementFromState() {
-        const VertexPointXY* v = static_cast<const VertexPointXY*>(_vertices[0]);
-        _measurement = v->estimate();
-        return true;
-      }
-
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 0.;}
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-      virtual void linearizeOplus();
-#endif
-  };
-
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/g2o_types_slam2d_api.h b/g2o/types/slam2d/g2o_types_slam2d_api.h
deleted file mode 100644
index e07b93af..00000000
--- a/g2o/types/slam2d/g2o_types_slam2d_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_SLAM2D_API_H
-#define G2O_TYPES_SLAM2D_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_slam2d_EXPORTS
-#define G2O_TYPES_SLAM2D_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SLAM2D_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SLAM2D_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SLAM2D_API
-#endif
-
-#endif // G2O_TYPES_SLAM2D_API_H
diff --git a/g2o/types/slam2d/parameter_se2_offset.cpp b/g2o/types/slam2d/parameter_se2_offset.cpp
deleted file mode 100644
index db8a4d18..00000000
--- a/g2o/types/slam2d/parameter_se2_offset.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "parameter_se2_offset.h"
-
-#include "g2o/core/io_helper.h"
-#include "vertex_se2.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-namespace g2o {
-
-ParameterSE2Offset::ParameterSE2Offset() { setOffset(); }
-
-void ParameterSE2Offset::setOffset(const SE2& offset_) {
-  _offset = offset_;
-  _offsetMatrix = _offset.rotation().toRotationMatrix();
-  _offsetMatrix.translation() = _offset.translation();
-  _inverseOffsetMatrix = _offsetMatrix.inverse();
-}
-
-bool ParameterSE2Offset::read(std::istream& is) {
-  Vector3 off;
-  bool state = g2o::internal::readVector(is, off);
-  setOffset(SE2(off));
-  return state;
-}
-
-bool ParameterSE2Offset::write(std::ostream& os) const { return internal::writeVector(os, offset().toVector()); }
-
-CacheSE2Offset::CacheSE2Offset() : Cache(), _offsetParam(0) {}
-
-bool CacheSE2Offset::resolveDependancies() {
-  _offsetParam = dynamic_cast<ParameterSE2Offset*>(_parameters[0]);
-  return _offsetParam != 0;
-}
-
-void CacheSE2Offset::updateImpl() {
-  const VertexSE2* v = static_cast<const VertexSE2*>(vertex());
-  _se2_n2w = v->estimate() * _offsetParam->offset();
-
-  _n2w = _se2_n2w.rotation().toRotationMatrix();
-  _n2w.translation() = _se2_n2w.translation();
-
-  _se2_w2n = _se2_n2w.inverse();
-  _w2n = _se2_w2n.rotation().toRotationMatrix();
-  _w2n.translation() = _se2_w2n.translation();
-
-  SE2 w2l = v->estimate().inverse();
-  _w2l = w2l.rotation().toRotationMatrix();
-  _w2l.translation() = w2l.translation();
-
-  number_t alpha = v->estimate().rotation().angle();
-  number_t c = std::cos(alpha), s = std::sin(alpha);
-  Matrix2 RInversePrime;
-  RInversePrime << -s, c, -c, -s;
-  _RpInverse_RInversePrime = _offsetParam->offset().rotation().toRotationMatrix().transpose() * RInversePrime;
-  _RpInverse_RInverse = w2l.rotation();
-}
-
-void CacheSE2Offset::setOffsetParam(ParameterSE2Offset* offsetParam) { _offsetParam = offsetParam; }
-
-}  // namespace g2o
diff --git a/g2o/types/slam2d/parameter_se2_offset.h b/g2o/types/slam2d/parameter_se2_offset.h
deleted file mode 100644
index c6cdc9bd..00000000
--- a/g2o/types/slam2d/parameter_se2_offset.h
+++ /dev/null
@@ -1,112 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_SE2_OFFSET_PARAMETERS_H_
-#define G2O_VERTEX_SE2_OFFSET_PARAMETERS_H_
-
-
-#include "se2.h"
-#include "g2o_types_slam2d_api.h"
-#include "g2o/core/cache.h"
-
-
-namespace g2o {
-
-  class VertexSE2;
-
-  /**
-   * \brief offset for an SE2
-   */
-  class G2O_TYPES_SLAM2D_API ParameterSE2Offset: public Parameter
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      ParameterSE2Offset();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      /**
-       * update the offset to a new value.
-       * re-calculates the different representations, e.g., the rotation matrix
-       */
-      void setOffset(const SE2& offset_ = SE2());
-
-      const SE2& offset() const { return _offset;}
-
-      //! rotation of the offset as 2x2 rotation matrix
-      const Isometry2& offsetMatrix() const { return _offsetMatrix;}
-
-      //! rotation of the inverse offset as 2x2 rotation matrix
-      const Isometry2& inverseOffsetMatrix() const { return _inverseOffsetMatrix;}
-
-    protected:
-      SE2 _offset;
-      Isometry2 _offsetMatrix;
-      Isometry2 _inverseOffsetMatrix;
-  };
-
-  /**
-   * \brief caching the offset related to a vertex
-   */
-  class G2O_TYPES_SLAM2D_API CacheSE2Offset: public Cache {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      CacheSE2Offset();
-      virtual void updateImpl();
-
-      const ParameterSE2Offset* offsetParam() const { return _offsetParam;}
-      void setOffsetParam(ParameterSE2Offset* offsetParam);
-
-      const SE2& w2n() const {return _se2_w2n;}
-      const SE2& n2w() const {return _se2_n2w;}
-
-      const Isometry2& w2nMatrix() const { return _w2n;}
-      const Isometry2& n2wMatrix() const { return _n2w;}
-      const Isometry2& w2lMatrix() const { return _w2l;}
-
-      const Matrix2 RpInverseRInverseMatrix() const { return _RpInverse_RInverse; }
-      const Matrix2 RpInverseRInversePrimeMatrix() const { return _RpInverse_RInversePrime; }
-
-    protected:
-      ParameterSE2Offset* _offsetParam; ///< the parameter connected to the cache
-      SE2 _se2_w2n;
-      SE2 _se2_n2w;
-
-      Isometry2 _w2n; ///< world to sensor transform
-      Isometry2 _w2l; ///< world to local
-      Isometry2 _n2w; ///< sensor to world
-      Matrix2 _RpInverse_RInverse;
-      Matrix2 _RpInverse_RInversePrime;
-      
-    protected:
-      virtual bool resolveDependancies();
-      
-  };
-
-}
-
-#endif
diff --git a/g2o/types/slam2d/se2.h b/g2o/types/slam2d/se2.h
deleted file mode 100644
index 3277c030..00000000
--- a/g2o/types/slam2d/se2.h
+++ /dev/null
@@ -1,126 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SE2_H_
-#define G2O_SE2_H_
-
-#include "g2o/stuff/misc.h"
-#include "g2o_types_slam2d_api.h"
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-namespace g2o {
-
-  /**
-   * \brief represent SE2
-   */
-  class G2O_TYPES_SLAM2D_API SE2 {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      SE2():_R(0),_t(0,0){}
-
-      SE2(const Isometry2& iso): _R(0), _t(iso.translation()){
-        _R.fromRotationMatrix(iso.linear());
-      }
-
-      SE2(const Vector3& v):_R(v[2]),_t(v[0],v[1]){}
-
-      SE2(number_t x, number_t y, number_t theta):_R(theta),_t(x,y){}
-
-      //! translational component
-      inline const Vector2& translation() const {return _t;}
-      void setTranslation(const Vector2& t_) {_t=t_;}
-
-      //! rotational component
-      inline const Rotation2D& rotation() const {return _R;}
-      void setRotation(const Rotation2D& R_) {_R=R_;}
-
-      //! concatenate two SE2 elements (motion composition)
-      inline SE2 operator * (const SE2& tr2) const{
-        SE2 result(*this);
-        result *= tr2;
-        return result;
-      }
-
-      //! motion composition operator
-      inline SE2& operator *= (const SE2& tr2){
-        _t+=_R*tr2._t;
-        _R.angle()+=tr2._R.angle();
-        _R.angle()=normalize_theta(_R.angle());
-        return *this;
-      }
-
-      //! project a 2D vector
-      inline Vector2 operator * (const Vector2& v) const {
-        return _t+_R*v;
-      }
-
-      //! invert :-)
-      inline SE2 inverse() const{
-        SE2 ret;
-        ret._R=_R.inverse();
-        ret._R.angle()=normalize_theta(ret._R.angle());
-#ifdef _MSC_VER
-        ret._t=ret._R*(Vector2(_t*-1.));
-#else
-        ret._t=ret._R*(_t*-1.);
-#endif
-        return ret;
-      }
-
-      inline number_t operator [](int i) const {
-        assert (i>=0 && i<3);
-        if (i<2)
-          return _t(i);
-        return _R.angle();
-      }
-
-
-      //! assign from a 3D vector (x, y, theta)
-      inline void fromVector (const Vector3& v){
-        *this=SE2(v[0], v[1], v[2]);
-      }
-
-      //! convert to a 3D vector (x, y, theta)
-      inline Vector3 toVector() const {
-        return Vector3(_t.x(), _t.y(), _R.angle());
-      }
-
-      inline Isometry2 toIsometry() const {
-        Isometry2 iso = Isometry2::Identity();
-        iso.linear() = _R.toRotationMatrix();
-        iso.translation() = _t;
-        return iso;
-      }
-
-    protected:
-      Rotation2D _R;
-      Vector2 _t;
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d/types_slam2d.cpp b/g2o/types/slam2d/types_slam2d.cpp
deleted file mode 100644
index ada15c67..00000000
--- a/g2o/types/slam2d/types_slam2d.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_slam2d.h"
-
-#include "g2o/core/factory.h"
-
-#include "g2o/stuff/macros.h"
-
-#include <iostream>
-
-namespace g2o {
-
-  G2O_REGISTER_TYPE_GROUP(slam2d);
-
-  G2O_REGISTER_TYPE(VERTEX_SE2, VertexSE2);
-  G2O_REGISTER_TYPE(VERTEX_XY, VertexPointXY);
-  G2O_REGISTER_TYPE(PARAMS_SE2OFFSET, ParameterSE2Offset);
-  G2O_REGISTER_TYPE(CACHE_SE2_OFFSET, CacheSE2Offset);
-  G2O_REGISTER_TYPE(EDGE_PRIOR_SE2, EdgeSE2Prior);
-  G2O_REGISTER_TYPE(EDGE_PRIOR_SE2_XY, EdgeSE2XYPrior);
-  G2O_REGISTER_TYPE(EDGE_SE2, EdgeSE2);
-  G2O_REGISTER_TYPE(EDGE_SE2_XY, EdgeSE2PointXY);
-  G2O_REGISTER_TYPE(EDGE_BEARING_SE2_XY, EdgeSE2PointXYBearing);
-  G2O_REGISTER_TYPE(EDGE_SE2_XY_CALIB, EdgeSE2PointXYCalib);
-  G2O_REGISTER_TYPE(EDGE_SE2_OFFSET, EdgeSE2Offset);
-  G2O_REGISTER_TYPE(EDGE_SE2_POINTXY_OFFSET, EdgeSE2PointXYOffset);
-  G2O_REGISTER_TYPE(EDGE_POINTXY, EdgePointXY);
-  G2O_REGISTER_TYPE(EDGE_SE2_TWOPOINTSXY, EdgeSE2TwoPointsXY);
-  G2O_REGISTER_TYPE(EDGE_SE2_LOTSOFXY, EdgeSE2LotsOfXY);
-  G2O_REGISTER_TYPE(EDGE_PRIOR_XY, EdgeXYPrior);
-
- 
-  G2O_REGISTER_ACTION(VertexSE2WriteGnuplotAction);
-  G2O_REGISTER_ACTION(VertexPointXYWriteGnuplotAction);
-  G2O_REGISTER_ACTION(EdgeSE2WriteGnuplotAction);
-  G2O_REGISTER_ACTION(EdgeSE2PointXYWriteGnuplotAction);
-  G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
-
-
-#ifdef G2O_HAVE_OPENGL
-  G2O_REGISTER_ACTION(VertexSE2DrawAction);
-  G2O_REGISTER_ACTION(VertexPointXYDrawAction);
-  G2O_REGISTER_ACTION(EdgeSE2DrawAction);
-  G2O_REGISTER_ACTION(EdgeSE2PointXYDrawAction);
-  G2O_REGISTER_ACTION(EdgeSE2PointXYBearingDrawAction);
-
-#endif
-} // end namespace
diff --git a/g2o/types/slam2d/types_slam2d.h b/g2o/types/slam2d/types_slam2d.h
deleted file mode 100644
index 1c0534a7..00000000
--- a/g2o/types/slam2d/types_slam2d.h
+++ /dev/null
@@ -1,47 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_SLAM2D_
-#define G2O_TYPES_SLAM2D_
-
-#include "g2o/config.h"
-#include "vertex_se2.h"
-#include "vertex_point_xy.h"
-#include "parameter_se2_offset.h"
-#include "edge_se2_prior.h"
-#include "edge_se2_xyprior.h"
-#include "edge_se2.h"
-#include "edge_se2_pointxy.h"
-#include "edge_se2_pointxy_bearing.h"
-#include "edge_se2_pointxy_calib.h"
-#include "edge_se2_offset.h"
-#include "edge_se2_pointxy_offset.h"
-#include "edge_pointxy.h"
-#include "edge_se2_twopointsxy.h"
-#include "edge_se2_lotsofxy.h"
-#include "edge_xy_prior.h"
-
-#endif
diff --git a/g2o/types/slam2d/vertex_point_xy.cpp b/g2o/types/slam2d/vertex_point_xy.cpp
deleted file mode 100644
index 34dd6c3a..00000000
--- a/g2o/types/slam2d/vertex_point_xy.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_point_xy.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-#include <typeinfo>
-
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  VertexPointXY::VertexPointXY() :
-    BaseVertex<2, Vector2>()
-  {
-    _estimate.setZero();
-  }
-
-  bool VertexPointXY::read(std::istream& is)
-  {
-    return internal::readVector(is, _estimate);
-  }
-
-  bool VertexPointXY::write(std::ostream& os) const
-  {
-    return internal::writeVector(os, estimate());
-  }
-
-  VertexPointXYWriteGnuplotAction::VertexPointXYWriteGnuplotAction(): WriteGnuplotAction(typeid(VertexPointXY).name()){}
-
-  HyperGraphElementAction* VertexPointXYWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    VertexPointXY* v =  static_cast<VertexPointXY*>(element);
-    *(params->os) << v->estimate().x() << " " << v->estimate().y() << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  VertexPointXYDrawAction::VertexPointXYDrawAction() : DrawAction(typeid(VertexPointXY).name()), _pointSize(nullptr) {}
-
-  bool VertexPointXYDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (! DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _pointSize = _previousParams->makeProperty<FloatProperty>(_typeName + "::POINT_SIZE", 1.);
-    } else {
-      _pointSize = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexPointXYDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                                                               HyperGraphElementAction::Parameters* params) {
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    initializeDrawActionsCache();
-    refreshPropertyPtrs(params);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-    VertexPointXY* that = static_cast<VertexPointXY*>(element);
-
-    glPushMatrix();
-    glPushAttrib(GL_ENABLE_BIT | GL_POINT_BIT);
-    glDisable(GL_LIGHTING);
-    glColor3f(LANDMARK_VERTEX_COLOR);
-    float ps = _pointSize ? _pointSize->value() :  1.0f;
-    glTranslatef((float)that->estimate()(0),(float)that->estimate()(1),0.0f);
-    opengl::drawPoint(ps);
-    glPopAttrib();
-    drawCache(that->cacheContainer(), params);
-    drawUserData(that->userData(), params);
-    glPopMatrix();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d/vertex_point_xy.h b/g2o/types/slam2d/vertex_point_xy.h
deleted file mode 100644
index e25f3c30..00000000
--- a/g2o/types/slam2d/vertex_point_xy.h
+++ /dev/null
@@ -1,109 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_POINT_XY_H
-#define G2O_VERTEX_POINT_XY_H
-
-#include "g2o_types_slam2d_api.h"
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-
-#include <Eigen/Core>
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_API VertexPointXY : public BaseVertex<2, Vector2>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexPointXY();
-
-      virtual void setToOriginImpl() {
-        _estimate.setZero();
-      }
-
-      virtual bool setEstimateDataImpl(const number_t* est){
-        _estimate[0] = est[0];
-        _estimate[1] = est[1];
-        return true;
-      }
-
-      virtual bool getEstimateData(number_t* est) const{
-        est[0] = _estimate[0];
-        est[1] = _estimate[1];
-        return true;
-      }
-
-      virtual int estimateDimension() const { 
-        return 2;
-      }
-
-      virtual bool setMinimalEstimateDataImpl(const number_t* est){
-        return setEstimateData(est);
-      }
-
-      virtual bool getMinimalEstimateData(number_t* est) const{
-        return getEstimateData(est);
-      }
-
-      virtual int minimalEstimateDimension() const { 
-        return 2;
-      }
-
-      virtual void oplusImpl(const number_t* update)
-      {
-        _estimate[0] += update[0];
-        _estimate[1] += update[1];
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-  };
-
-  class G2O_TYPES_SLAM2D_API VertexPointXYWriteGnuplotAction: public WriteGnuplotAction {
-  public:
-    VertexPointXYWriteGnuplotAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM2D_API VertexPointXYDrawAction: public DrawAction{
-  public:
-    VertexPointXYDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  protected:
-    FloatProperty *_pointSize;
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/slam2d/vertex_se2.cpp b/g2o/types/slam2d/vertex_se2.cpp
deleted file mode 100644
index c1ed2c30..00000000
--- a/g2o/types/slam2d/vertex_se2.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_se2.h"
-#include <typeinfo>
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  VertexSE2::VertexSE2() :
-    BaseVertex<3, SE2>()
-  {
-  }
-
-  bool VertexSE2::read(std::istream& is)
-  {
-    Vector3 p;
-    bool state = internal::readVector(is, p);
-    setEstimate(p);
-    return state;
-  }
-
-  bool VertexSE2::write(std::ostream& os) const
-  {
-    return internal::writeVector(os, estimate().toVector());
-  }
-
-  VertexSE2WriteGnuplotAction::VertexSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(VertexSE2).name()){}
-
-  HyperGraphElementAction* VertexSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params || !params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid output stream specified" << std::endl;
-      return nullptr;
-    }
-
-    VertexSE2* v =  static_cast<VertexSE2*>(element);
-    *(params->os) << v->estimate().translation().x() << " " << v->estimate().translation().y()
-      << " " << v->estimate().rotation().angle() << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  VertexSE2DrawAction::VertexSE2DrawAction()
-      : DrawAction(typeid(VertexSE2).name()), _drawActions(nullptr), _triangleX(nullptr), _triangleY(nullptr) {}
-
-  bool VertexSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::TRIANGLE_X", .2f);
-      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::TRIANGLE_Y", .05f);
-    } else {
-      _triangleX = 0;
-      _triangleY = 0;
-    }
-    return true;
-  }
-
-
-  HyperGraphElementAction* VertexSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                 HyperGraphElementAction::Parameters* params_){
-   if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    initializeDrawActionsCache();
-    refreshPropertyPtrs(params_);
-
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    VertexSE2* that = static_cast<VertexSE2*>(element);
-
-    glColor3f(POSE_VERTEX_COLOR);
-    glPushMatrix();
-    glTranslatef((float)that->estimate().translation().x(),(float)that->estimate().translation().y(),0.f);
-    glRotatef((float)RAD2DEG(that->estimate().rotation().angle()),0.f,0.f,1.f);
-    opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
-    drawCache(that->cacheContainer(), params_);
-    drawUserData(that->userData(), params_);
-    glPopMatrix();
-    return this;
-  }
-#endif
-
-
-} // end namespace
diff --git a/g2o/types/slam2d/vertex_se2.h b/g2o/types/slam2d/vertex_se2.h
deleted file mode 100644
index 07cb7164..00000000
--- a/g2o/types/slam2d/vertex_se2.h
+++ /dev/null
@@ -1,111 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_SE2_H
-#define G2O_VERTEX_SE2_H
-
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "se2.h"
-#include "g2o_types_slam2d_api.h"
-
-namespace g2o {
-
-  /**
-   * \brief 2D pose Vertex, (x,y,theta)
-   */
-  class G2O_TYPES_SLAM2D_API VertexSE2 : public BaseVertex<3, SE2>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      VertexSE2();
-
-      virtual void setToOriginImpl() {
-        _estimate = SE2();
-      }
-
-      virtual void oplusImpl(const number_t* update)
-      {
-        Vector2 t=_estimate.translation();
-        t+=Eigen::Map<const Vector2>(update);
-        number_t angle=normalize_theta(_estimate.rotation().angle() + update[2]);
-        _estimate.setTranslation(t);
-        _estimate.setRotation(Rotation2D(angle));
-      }
-
-      virtual bool setEstimateDataImpl(const number_t* est){
-        _estimate=SE2(est[0], est[1], est[2]);
-        return true;
-      }
-
-      virtual bool getEstimateData(number_t* est) const {
-        Eigen::Map<Vector3> v(est);
-        v = _estimate.toVector();
-        return true;
-      }
-      
-      virtual int estimateDimension() const { return 3; }
-
-      virtual bool setMinimalEstimateDataImpl(const number_t* est){
-        return setEstimateData(est);
-      }
-
-      virtual bool getMinimalEstimateData(number_t* est) const {
-        return getEstimateData(est);
-      }
-      
-      virtual int minimalEstimateDimension() const { return 3; }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-  };
-
-  class G2O_TYPES_SLAM2D_API VertexSE2WriteGnuplotAction: public WriteGnuplotAction {
-  public:
-    VertexSE2WriteGnuplotAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_ );
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM2D_API VertexSE2DrawAction: public DrawAction{
-  public:
-    VertexSE2DrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_ );
-  protected:
-    HyperGraphElementAction* _drawActions;
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    FloatProperty* _triangleX, *_triangleY;
-
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d_addons/CMakeLists.txt b/g2o/types/slam2d_addons/CMakeLists.txt
deleted file mode 100644
index 7018ab6a..00000000
--- a/g2o/types/slam2d_addons/CMakeLists.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-add_library(types_slam2d_addons ${G2O_LIB_TYPE}
-  line_2d.h
-  types_slam2d_addons.cpp types_slam2d_addons.h
-  vertex_segment2d.cpp         vertex_segment2d.h
-  edge_se2_segment2d.cpp       edge_se2_segment2d.h
-  edge_se2_segment2d_line.cpp       edge_se2_segment2d_line.h
-  edge_se2_segment2d_pointLine.cpp       edge_se2_segment2d_pointLine.h
-  vertex_line2d.cpp            vertex_line2d.h
-  edge_se2_line2d.cpp          edge_se2_line2d.h
-  edge_line2d_pointxy.cpp          edge_line2d_pointxy.h
-  edge_line2d.cpp          edge_line2d.h
-  g2o_types_slam2d_addons_api.h
-)
-
-set_target_properties(types_slam2d_addons PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_slam2d_addons)
-if (APPLE)
-  set_target_properties(types_slam2d_addons PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_slam2d_addons types_slam2d core)
-if(G2O_HAVE_OPENGL)
-  target_link_libraries(types_slam2d_addons ${OPENGL_gl_LIBRARY})
-endif()
-
-install(TARGETS types_slam2d_addons
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/slam2d_addons)
diff --git a/g2o/types/slam2d_addons/edge_line2d.cpp b/g2o/types/slam2d_addons/edge_line2d.cpp
deleted file mode 100644
index 8461c18b..00000000
--- a/g2o/types/slam2d_addons/edge_line2d.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_line2d.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_primitives.h"
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-using namespace g2o;
-using namespace Eigen;
-
-EdgeLine2D::EdgeLine2D() : BaseBinaryEdge<2, Line2D, VertexLine2D, VertexLine2D>() {
-  _information.setIdentity();
-  _error.setZero();
-}
-
-bool EdgeLine2D::read(std::istream& is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeLine2D::write(std::ostream& os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-void EdgeLine2D::linearizeOplus() {
-  _jacobianOplusXi = -Matrix2::Identity();
-  _jacobianOplusXj = Matrix2::Identity();
-}
-#endif
diff --git a/g2o/types/slam2d_addons/edge_line2d.h b/g2o/types/slam2d_addons/edge_line2d.h
deleted file mode 100644
index 00c73cf6..00000000
--- a/g2o/types/slam2d_addons/edge_line2d.h
+++ /dev/null
@@ -1,82 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_LINE2D_H
-#define G2O_EDGE_LINE2D_H
-
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "types_slam2d_addons.h"
-#include "vertex_line2d.h"
-
-namespace g2o {
-
-class G2O_TYPES_SLAM2D_ADDONS_API EdgeLine2D : public BaseBinaryEdge<2, Line2D, VertexLine2D, VertexLine2D> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  EdgeLine2D();
-
-  void computeError() {
-    const VertexLine2D* v1 = static_cast<const VertexLine2D*>(_vertices[0]);
-    const VertexLine2D* v2 = static_cast<const VertexLine2D*>(_vertices[1]);
-    _error = (v2->estimate() - v1->estimate()) - _measurement;
-  }
-  virtual bool read(std::istream& is);
-  virtual bool write(std::ostream& os) const;
-
-  virtual void setMeasurement(const Line2D& m) { _measurement = m; }
-
-  virtual void setMeasurement(const Vector2& m) { _measurement = m; }
-
-  virtual bool setMeasurementData(const number_t* d) {
-    Eigen::Map<const Vector2> m(d);
-    _measurement = Line2D(m);
-    return true;
-  }
-
-  virtual bool getMeasurementData(number_t* d) const {
-    Eigen::Map<Vector2> m(d);
-    m = _measurement;
-    return true;
-  }
-
-  virtual int measurementDimension() const { return 2; }
-
-  virtual bool setMeasurementFromState() {
-    const VertexLine2D* v1 = static_cast<const VertexLine2D*>(_vertices[0]);
-    const VertexLine2D* v2 = static_cast<const VertexLine2D*>(_vertices[1]);
-    _measurement = Line2D((Vector2)(v2->estimate()) - (Vector2)v1->estimate());
-    return true;
-  }
-
-  virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*) { return 0; }
-#ifndef NUMERIC_JACOBIAN_THREE_D_TYPES
-  virtual void linearizeOplus();
-#endif
-};
-
-}  // namespace g2o
-#endif
diff --git a/g2o/types/slam2d_addons/edge_line2d_pointxy.cpp b/g2o/types/slam2d_addons/edge_line2d_pointxy.cpp
deleted file mode 100644
index 0ac47474..00000000
--- a/g2o/types/slam2d_addons/edge_line2d_pointxy.cpp
+++ /dev/null
@@ -1,160 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_line2d_pointxy.h"
-
-#ifdef WINDOWS
-#include <windows.h>
-#endif
-
-#ifdef G2O_HAVE_OPENGL
-#ifdef __APPLE__
-#include <OpenGL/gl.h>
-#else
-#include <GL/gl.h>
-#endif
-#endif
-
-namespace g2o {
-
-  EdgeLine2DPointXY::EdgeLine2DPointXY() :
-    BaseBinaryEdge<1, number_t, VertexLine2D, VertexPointXY>()
-  {
-  }
-
-  bool EdgeLine2DPointXY::read(std::istream& is)
-  {
-    is >> _measurement;
-    is >> information()(0,0);
-    return true;
-  }
-
-  bool EdgeLine2DPointXY::write(std::ostream& os) const
-  {
-    os << measurement() << " ";
-    os << information()(0,0);
-    return os.good();
-  }
-
-  // void EdgeLine2DPointXY::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-  // {
-  //   assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexLine2D position by VertexPointXY");
-
-  //   VertexLine2D* vi     = static_cast<VertexLine2D*>(_vertices[0]);
-  //   VertexPointXY* vj = static_cast<VertexPointXY*>(_vertices[1]);
-  //   if (from.count(vi) > 0 && to == vj) {
-  //     Line2D T=vi->estimate();
-  //     Vector2 est=_measurement;
-  //     est[0] += T.rotation().angle();
-  //     est[0] = normalize_theta(est[0]);
-  //     Vector2 n(cos(est[0]), sin(est[0]));
-  //     est[1] += n.dot(T.translation());
-  //     vj->setEstimate(est);
-  //   }
-  // }
-
-// #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-//   void EdgeLine2DPointXY::linearizeOplus()
-//   {
-//     const VertexLine2D* vi     = static_cast<const VertexLine2D*>(_vertices[0]);
-//     const VertexPointXY* vj = static_cast<const VertexPointXY*>(_vertices[1]);
-//     const number_t& x1        = vi->estimate().translation()[0];
-//     const number_t& y1        = vi->estimate().translation()[1];
-//     const number_t& th1       = vi->estimate().rotation().angle();
-//     const number_t& x2        = vj->estimate()[0];
-//     const number_t& y2        = vj->estimate()[1];
-
-//     number_t aux_1 = cos(th1) ;
-//     number_t aux_2 = -aux_1 ;
-//     number_t aux_3 = sin(th1) ;
-
-//     _jacobianOplusXi( 0 , 0 ) = aux_2 ;
-//     _jacobianOplusXi( 0 , 1 ) = -aux_3 ;
-//     _jacobianOplusXi( 0 , 2 ) = aux_1*y2-aux_1*y1-aux_3*x2+aux_3*x1 ;
-//     _jacobianOplusXi( 1 , 0 ) = aux_3 ;
-//     _jacobianOplusXi( 1 , 1 ) = aux_2 ;
-//     _jacobianOplusXi( 1 , 2 ) = -aux_3*y2+aux_3*y1-aux_1*x2+aux_1*x1 ;
-
-//     _jacobianOplusXj( 0 , 0 ) = aux_1 ;
-//     _jacobianOplusXj( 0 , 1 ) = aux_3 ;
-//     _jacobianOplusXj( 1 , 0 ) = -aux_3 ;
-//     _jacobianOplusXj( 1 , 1 ) = aux_1 ;
-//   }
-// #endif
-
-//   EdgeLine2DPointXYWriteGnuplotAction::EdgeLine2DPointXYWriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeLine2DPointXY).name()){}
-
-//   HyperGraphElementAction* EdgeLine2DPointXYWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-//     if (typeid(*element).name()!=_typeName)
-//       return nullptr;
-//     WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-//     if (!params->os){
-//       std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-//       return nullptr;
-//     }
-
-//     EdgeLine2DPointXY* e =  static_cast<EdgeLine2DPointXY*>(element);
-//     VertexLine2D* fromEdge = static_cast<VertexLine2D*>(e->vertex(0));
-//     VertexPointXY* toEdge   = static_cast<VertexPointXY*>(e->vertex(1));
-//     *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
-//       << " " << fromEdge->estimate().rotation().angle() << std::endl;
-//     *(params->os) << toEdge->estimate().x() << " " << toEdge->estimate().y() << std::endl;
-//     *(params->os) << std::endl;
-//     return this;
-//   }
-
-// #ifdef G2O_HAVE_OPENGL
-//   EdgeLine2DPointXYDrawAction::EdgeLine2DPointXYDrawAction(): DrawAction(typeid(EdgeLine2DPointXY).name()){}
-
-//   HyperGraphElementAction* EdgeLine2DPointXYDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-//                 HyperGraphElementAction::Parameters*  params_){
-//     if (typeid(*element).name()!=_typeName)
-//       return nullptr;
-
-//     refreshPropertyPtrs(params_);
-//     if (! _previousParams)
-//       return this;
-
-//     if (_show && !_show->value())
-//       return this;
-
-
-//     EdgeLine2DPointXY* e =  static_cast<EdgeLine2DPointXY*>(element);
-//     VertexLine2D* fromEdge = static_cast<VertexLine2D*>(e->vertex(0));
-//     VertexPointXY* toEdge   = static_cast<VertexPointXY*>(e->vertex(1));
-//     glColor3f(0.4f,0.4f,0.2f);
-//     glPushAttrib(GL_ENABLE_BIT);
-//     glDisable(GL_LIGHTING);
-//     glBegin(GL_LINES);
-//     glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),0.f);
-//     glVertex3f((float)toEdge->estimate().x(),(float)toEdge->estimate().y(),0.f);
-//     glEnd();
-//     glPopAttrib();
-//     return this;
-//   }
-// #endif
-
-} // end namespace
diff --git a/g2o/types/slam2d_addons/edge_line2d_pointxy.h b/g2o/types/slam2d_addons/edge_line2d_pointxy.h
deleted file mode 100644
index f3a20d9b..00000000
--- a/g2o/types/slam2d_addons/edge_line2d_pointxy.h
+++ /dev/null
@@ -1,103 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_LINE2D_POINTXY_H
-#define G2O_EDGE_LINE2D_POINTXY_H
-
-#include "g2o/config.h"
-#include "g2o/types/slam2d/vertex_point_xy.h"
-#include "vertex_line2d.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/stuff/misc.h"
-#include "g2o_types_slam2d_addons_api.h"
-
-namespace g2o {
-
-  class EdgeLine2DPointXY : public BaseBinaryEdge<1, number_t, VertexLine2D, VertexPointXY> //Avoid redefinition of BaseEdge in MSVC
-  {
-    public:
-      G2O_TYPES_SLAM2D_ADDONS_API EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      G2O_TYPES_SLAM2D_ADDONS_API EdgeLine2DPointXY();
-
-      G2O_TYPES_SLAM2D_ADDONS_API void computeError()
-      {
-        const VertexLine2D* l = static_cast<const VertexLine2D*>(_vertices[0]);
-        const VertexPointXY* p = static_cast<const VertexPointXY*>(_vertices[1]);
-        Vector2 n(std::cos(l->theta()), std::sin(l->theta()));
-        number_t prediction=n.dot(p->estimate())-l->rho();
-        _error[0] =  prediction - _measurement;
-      }
-
-      G2O_TYPES_SLAM2D_ADDONS_API virtual bool setMeasurementData(const number_t* d){
-	_measurement = *d;
-        return true;
-      }
-
-      G2O_TYPES_SLAM2D_ADDONS_API virtual bool getMeasurementData(number_t* d) const{
-        *d = _measurement;
-        return true;
-      }
-
-      G2O_TYPES_SLAM2D_ADDONS_API virtual int measurementDimension() const {return 1;}
-
-      G2O_TYPES_SLAM2D_ADDONS_API virtual bool setMeasurementFromState(){
-        const VertexLine2D* l = static_cast<const VertexLine2D*>(_vertices[0]);
-        const VertexPointXY* p = static_cast<const VertexPointXY*>(_vertices[1]);
-        Vector2 n(std::cos(l->theta()), std::sin(l->theta()));
-        number_t prediction=n.dot(p->estimate())-l->rho();
-	_measurement = prediction;
-        return true;
-      }
-
-      G2O_TYPES_SLAM2D_ADDONS_API virtual bool read(std::istream& is);
-      G2O_TYPES_SLAM2D_ADDONS_API virtual bool write(std::ostream& os) const;
-
-      /* virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to); */
-      /* virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) { (void) to; return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);} */
-/* #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES */
-/*       virtual void linearizeOplus(); */
-/* #endif */
-  };
-
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeLine2DPointXYWriteGnuplotAction: public WriteGnuplotAction { */
-/*   public: */
-/*     EdgeLine2DPointXYWriteGnuplotAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-
-/* #ifdef G2O_HAVE_OPENGL */
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeLine2DPointXYDrawAction: public DrawAction{ */
-/*   public: */
-/*     EdgeLine2DPointXYDrawAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-/* #endif */
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d_addons/edge_se2_line2d.cpp b/g2o/types/slam2d_addons/edge_se2_line2d.cpp
deleted file mode 100644
index 6f8dd4cc..00000000
--- a/g2o/types/slam2d_addons/edge_se2_line2d.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_line2d.h"
-
-namespace g2o {
-
-  EdgeSE2Line2D::EdgeSE2Line2D() :
-    BaseBinaryEdge<2, Line2D, VertexSE2, VertexLine2D>()
-  {
-  }
-
-  bool EdgeSE2Line2D::read(std::istream& is)
-  {
-    internal::readVector(is, _measurement);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSE2Line2D::write(std::ostream& os) const
-  {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE2Line2D::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-  {
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexSE2 position by VertexLine2D");
-
-    VertexSE2* vi     = static_cast<VertexSE2*>(_vertices[0]);
-    VertexLine2D* vj = static_cast<VertexLine2D*>(_vertices[1]);
-    if (from.count(vi) > 0 && to == vj) {
-      SE2 T=vi->estimate();
-      Vector2 est=_measurement;
-      est[0] += T.rotation().angle();
-      est[0] = normalize_theta(est[0]);
-      Vector2 n(std::cos(est[0]), std::sin(est[0]));
-      est[1] += n.dot(T.translation());
-      vj->setEstimate(est);
-    }
-  }
-
-// #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-//   void EdgeSE2Line2D::linearizeOplus()
-//   {
-//     const VertexSE2* vi     = static_cast<const VertexSE2*>(_vertices[0]);
-//     const VertexLine2D* vj = static_cast<const VertexLine2D*>(_vertices[1]);
-//     const number_t& x1        = vi->estimate().translation()[0];
-//     const number_t& y1        = vi->estimate().translation()[1];
-//     const number_t& th1       = vi->estimate().rotation().angle();
-//     const number_t& x2        = vj->estimate()[0];
-//     const number_t& y2        = vj->estimate()[1];
-
-//     number_t aux_1 = cos(th1) ;
-//     number_t aux_2 = -aux_1 ;
-//     number_t aux_3 = sin(th1) ;
-
-//     _jacobianOplusXi( 0 , 0 ) = aux_2 ;
-//     _jacobianOplusXi( 0 , 1 ) = -aux_3 ;
-//     _jacobianOplusXi( 0 , 2 ) = aux_1*y2-aux_1*y1-aux_3*x2+aux_3*x1 ;
-//     _jacobianOplusXi( 1 , 0 ) = aux_3 ;
-//     _jacobianOplusXi( 1 , 1 ) = aux_2 ;
-//     _jacobianOplusXi( 1 , 2 ) = -aux_3*y2+aux_3*y1-aux_1*x2+aux_1*x1 ;
-
-//     _jacobianOplusXj( 0 , 0 ) = aux_1 ;
-//     _jacobianOplusXj( 0 , 1 ) = aux_3 ;
-//     _jacobianOplusXj( 1 , 0 ) = -aux_3 ;
-//     _jacobianOplusXj( 1 , 1 ) = aux_1 ;
-//   }
-// #endif
-
-//   EdgeSE2Line2DWriteGnuplotAction::EdgeSE2Line2DWriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSE2Line2D).name()){}
-
-//   HyperGraphElementAction* EdgeSE2Line2DWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-//     if (typeid(*element).name()!=_typeName)
-//       return nullptr;
-//     WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-//     if (!params->os){
-//       std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-//       return nullptr;
-//     }
-
-//     EdgeSE2Line2D* e =  static_cast<EdgeSE2Line2D*>(element);
-//     VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-//     VertexLine2D* toEdge   = static_cast<VertexLine2D*>(e->vertex(1));
-//     *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
-//       << " " << fromEdge->estimate().rotation().angle() << std::endl;
-//     *(params->os) << toEdge->estimate().x() << " " << toEdge->estimate().y() << std::endl;
-//     *(params->os) << std::endl;
-//     return this;
-//   }
-
-// #ifdef G2O_HAVE_OPENGL
-//   EdgeSE2Line2DDrawAction::EdgeSE2Line2DDrawAction(): DrawAction(typeid(EdgeSE2Line2D).name()){}
-
-//   HyperGraphElementAction* EdgeSE2Line2DDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-//                 HyperGraphElementAction::Parameters*  params_){
-//     if (typeid(*element).name()!=_typeName)
-//       return nullptr;
-
-//     refreshPropertyPtrs(params_);
-//     if (! _previousParams)
-//       return this;
-
-//     if (_show && !_show->value())
-//       return this;
-
-
-//     EdgeSE2Line2D* e =  static_cast<EdgeSE2Line2D*>(element);
-//     VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-//     VertexLine2D* toEdge   = static_cast<VertexLine2D*>(e->vertex(1));
-//     glColor3f(0.4f,0.4f,0.2f);
-//     glPushAttrib(GL_ENABLE_BIT);
-//     glDisable(GL_LIGHTING);
-//     glBegin(GL_LINES);
-//     glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),0.f);
-//     glVertex3f((float)toEdge->estimate().x(),(float)toEdge->estimate().y(),0.f);
-//     glEnd();
-//     glPopAttrib();
-//     return this;
-//   }
-// #endif
-
-} // end namespace
diff --git a/g2o/types/slam2d_addons/edge_se2_line2d.h b/g2o/types/slam2d_addons/edge_se2_line2d.h
deleted file mode 100644
index c1eebfa3..00000000
--- a/g2o/types/slam2d_addons/edge_se2_line2d.h
+++ /dev/null
@@ -1,114 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_LINE2D_H
-#define G2O_EDGE_SE2_LINE2D_H
-
-#include "g2o/config.h"
-#include "g2o/types/slam2d/vertex_se2.h"
-#include "vertex_line2d.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/stuff/misc.h"
-#include "g2o_types_slam2d_addons_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Line2D : public BaseBinaryEdge<2, Line2D, VertexSE2, VertexLine2D>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      EdgeSE2Line2D();
-
-      void computeError()
-      {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexLine2D* l2 = static_cast<const VertexLine2D*>(_vertices[1]);
-        Vector2 prediction=l2->estimate();
-        SE2 iT=v1->estimate().inverse();
-        prediction[0] += iT.rotation().angle();
-        prediction[0] = normalize_theta(prediction[0]);
-        Vector2 n(std::cos(prediction[0]), std::sin(prediction[0]));
-        prediction[1] += n.dot(iT.translation());
-        _error =  prediction - _measurement;
-        _error [0] =  normalize_theta(_error[0]);
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        _measurement[0]=d[0];
-        _measurement[1]=d[1];
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const{
-        d[0] = _measurement[0];
-        d[1] = _measurement[1];
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 2;}
-
-      virtual bool setMeasurementFromState(){
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexLine2D* l2 = static_cast<const VertexLine2D*>(_vertices[1]);
-        Vector2 prediction=l2->estimate();
-        SE2 iT=v1->estimate().inverse();
-        prediction[0] += iT.rotation().angle();
-        prediction[0] = normalize_theta(prediction[0]);
-        Vector2 n(std::cos(prediction[0]), std::sin(prediction[0]));
-        prediction[1] += n.dot(iT.translation());
-        _measurement = prediction;
-        return true;
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) { (void) to; return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);}
-/* #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES */
-/*       virtual void linearizeOplus(); */
-/* #endif */
-  };
-
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Line2DWriteGnuplotAction: public WriteGnuplotAction { */
-/*   public: */
-/*     EdgeSE2Line2DWriteGnuplotAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-
-/* #ifdef G2O_HAVE_OPENGL */
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Line2DDrawAction: public DrawAction{ */
-/*   public: */
-/*     EdgeSE2Line2DDrawAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-/* #endif */
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d_addons/edge_se2_segment2d.cpp b/g2o/types/slam2d_addons/edge_se2_segment2d.cpp
deleted file mode 100644
index 8434da24..00000000
--- a/g2o/types/slam2d_addons/edge_se2_segment2d.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_segment2d.h"
-
-namespace g2o {
-
-EdgeSE2Segment2D::EdgeSE2Segment2D() : BaseBinaryEdge<4, Vector4, VertexSE2, VertexSegment2D>() {}
-
-bool EdgeSE2Segment2D::read(std::istream& is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeSE2Segment2D::write(std::ostream& os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-void EdgeSE2Segment2D::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
-  assert(from.size() == 1 && from.count(_vertices[0]) == 1 &&
-         "Can not initialize VertexSE2 position by VertexSegment2D. I could if i wanted. Not now");
-
-  VertexSE2* vi = static_cast<VertexSE2*>(_vertices[0]);
-  VertexSegment2D* vj = static_cast<VertexSegment2D*>(_vertices[1]);
-  if (from.count(vi) > 0 && to == vj) {
-    vj->setEstimateP1(vi->estimate() * measurementP1());
-    vj->setEstimateP2(vi->estimate() * measurementP2());
-  }
-}
-
-// #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
-//   void EdgeSE2Segment2D::linearizeOplus()
-//   {
-//     const VertexSE2* vi     = static_cast<const VertexSE2*>(_vertices[0]);
-//     const VertexSegment2D* vj = static_cast<const VertexSegment2D*>(_vertices[1]);
-//     const number_t& x1        = vi->estimate().translation()[0];
-//     const number_t& y1        = vi->estimate().translation()[1];
-//     const number_t& th1       = vi->estimate().rotation().angle();
-//     const number_t& x2        = vj->estimate()[0];
-//     const number_t& y2        = vj->estimate()[1];
-
-//     number_t aux_1 = cos(th1) ;
-//     number_t aux_2 = -aux_1 ;
-//     number_t aux_3 = sin(th1) ;
-
-//     _jacobianOplusXi( 0 , 0 ) = aux_2 ;
-//     _jacobianOplusXi( 0 , 1 ) = -aux_3 ;
-//     _jacobianOplusXi( 0 , 2 ) = aux_1*y2-aux_1*y1-aux_3*x2+aux_3*x1 ;
-//     _jacobianOplusXi( 1 , 0 ) = aux_3 ;
-//     _jacobianOplusXi( 1 , 1 ) = aux_2 ;
-//     _jacobianOplusXi( 1 , 2 ) = -aux_3*y2+aux_3*y1-aux_1*x2+aux_1*x1 ;
-
-//     _jacobianOplusXj( 0 , 0 ) = aux_1 ;
-//     _jacobianOplusXj( 0 , 1 ) = aux_3 ;
-//     _jacobianOplusXj( 1 , 0 ) = -aux_3 ;
-//     _jacobianOplusXj( 1 , 1 ) = aux_1 ;
-//   }
-// #endif
-
-//   EdgeSE2Segment2DWriteGnuplotAction::EdgeSE2Segment2DWriteGnuplotAction():
-//   WriteGnuplotAction(typeid(EdgeSE2Segment2D).name()){}
-
-//   HyperGraphElementAction* EdgeSE2Segment2DWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element,
-//   HyperGraphElementAction::Parameters* params_){
-//     if (typeid(*element).name()!=_typeName)
-//       return nullptr;
-//     WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-//     if (!params->os){
-//       std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-//       return nullptr;
-//     }
-
-//     EdgeSE2Segment2D* e =  static_cast<EdgeSE2Segment2D*>(element);
-//     VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-//     VertexSegment2D* toEdge   = static_cast<VertexSegment2D*>(e->vertex(1));
-//     *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
-//       << " " << fromEdge->estimate().rotation().angle() << std::endl;
-//     *(params->os) << toEdge->estimate().x() << " " << toEdge->estimate().y() << std::endl;
-//     *(params->os) << std::endl;
-//     return this;
-//   }
-
-// #ifdef G2O_HAVE_OPENGL
-//   EdgeSE2Segment2DDrawAction::EdgeSE2Segment2DDrawAction(): DrawAction(typeid(EdgeSE2Segment2D).name()){}
-
-//   HyperGraphElementAction* EdgeSE2Segment2DDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-//                 HyperGraphElementAction::Parameters*  params_){
-//     if (typeid(*element).name()!=_typeName)
-//       return nullptr;
-
-//     refreshPropertyPtrs(params_);
-//     if (! _previousParams)
-//       return this;
-
-//     if (_show && !_show->value())
-//       return this;
-
-//     EdgeSE2Segment2D* e =  static_cast<EdgeSE2Segment2D*>(element);
-//     VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
-//     VertexSegment2D* toEdge   = static_cast<VertexSegment2D*>(e->vertex(1));
-//     glColor3f(0.4f,0.4f,0.2f);
-//     glPushAttrib(GL_ENABLE_BIT);
-//     glDisable(GL_LIGHTING);
-//     glBegin(GL_LINES);
-//     glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),0.f);
-//     glVertex3f((float)toEdge->estimate().x(),(float)toEdge->estimate().y(),0.f);
-//     glEnd();
-//     glPopAttrib();
-//     return this;
-//   }
-// #endif
-
-}  // namespace g2o
diff --git a/g2o/types/slam2d_addons/edge_se2_segment2d.h b/g2o/types/slam2d_addons/edge_se2_segment2d.h
deleted file mode 100644
index 758e61d7..00000000
--- a/g2o/types/slam2d_addons/edge_se2_segment2d.h
+++ /dev/null
@@ -1,121 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_SEGMENT2D_H
-#define G2O_EDGE_SE2_SEGMENT2D_H
-
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/types/slam2d/vertex_se2.h"
-#include "g2o_types_slam2d_addons_api.h"
-#include "vertex_segment2d.h"
-
-namespace g2o {
-
-class EdgeSE2Segment2D
-    : public BaseBinaryEdge<4, Vector4, VertexSE2, VertexSegment2D>  // Avoid redefinition of BaseEdge in MSVC
-{
- public:
-  G2O_TYPES_SLAM2D_ADDONS_API EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2D();
-
-  G2O_TYPES_SLAM2D_ADDONS_API Vector2 measurementP1() { return Eigen::Map<const Vector2>(&(_measurement[0])); }
-  G2O_TYPES_SLAM2D_ADDONS_API Vector2 measurementP2() { return Eigen::Map<const Vector2>(&(_measurement[2])); }
-  G2O_TYPES_SLAM2D_ADDONS_API void setMeasurementP1(const Vector2& p1) {
-    Eigen::Map<Vector2> v(&_measurement[0]);
-    v = p1;
-  }
-  G2O_TYPES_SLAM2D_ADDONS_API void setMeasurementP2(const Vector2& p2) {
-    Eigen::Map<Vector2> v(&_measurement[2]);
-    v = p2;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API void computeError() {
-    const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-    const VertexSegment2D* l2 = static_cast<const VertexSegment2D*>(_vertices[1]);
-    Eigen::Map<Vector2> error1(&_error(0));
-    Eigen::Map<Vector2> error2(&_error(2));
-    SE2 iEst = v1->estimate().inverse();
-    error1 = (iEst * l2->estimateP1());
-    error2 = (iEst * l2->estimateP2());
-    _error = _error - _measurement;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool setMeasurementData(const number_t* d) {
-    Eigen::Map<const Vector4> data(d);
-    _measurement = data;
-    return true;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool getMeasurementData(number_t* d) const {
-    Eigen::Map<Vector4> data(d);
-    data = _measurement;
-    return true;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual int measurementDimension() const { return 4; }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool setMeasurementFromState() {
-    const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-    const VertexSegment2D* l2 = static_cast<const VertexSegment2D*>(_vertices[1]);
-    SE2 iEst = v1->estimate().inverse();
-    setMeasurementP1(iEst * l2->estimateP1());
-    setMeasurementP2(iEst * l2->estimateP2());
-    return true;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool read(std::istream& is);
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool write(std::ostream& os) const;
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-  G2O_TYPES_SLAM2D_ADDONS_API virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
-    (void)to;
-    return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
-  }
-  /* #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES */
-  /*       virtual void linearizeOplus(); */
-  /* #endif */
-};
-
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DWriteGnuplotAction: public WriteGnuplotAction { */
-/*   public: */
-/*     EdgeSE2Segment2DWriteGnuplotAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-
-/* #ifdef G2O_HAVE_OPENGL */
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DDrawAction: public DrawAction{ */
-/*   public: */
-/*     EdgeSE2Segment2DDrawAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-/* #endif */
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/types/slam2d_addons/edge_se2_segment2d_line.cpp b/g2o/types/slam2d_addons/edge_se2_segment2d_line.cpp
deleted file mode 100644
index 0e475164..00000000
--- a/g2o/types/slam2d_addons/edge_se2_segment2d_line.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_segment2d_line.h"
-
-namespace g2o {
-
-EdgeSE2Segment2DLine::EdgeSE2Segment2DLine() : BaseBinaryEdge<2, Vector2, VertexSE2, VertexSegment2D>() {}
-
-bool EdgeSE2Segment2DLine::read(std::istream& is) {
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeSE2Segment2DLine::write(std::ostream& os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam2d_addons/edge_se2_segment2d_line.h b/g2o/types/slam2d_addons/edge_se2_segment2d_line.h
deleted file mode 100644
index 3546f910..00000000
--- a/g2o/types/slam2d_addons/edge_se2_segment2d_line.h
+++ /dev/null
@@ -1,120 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_SEGMENT2D_LINE_H
-#define G2O_EDGE_SE2_SEGMENT2D_LINE_H
-
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/types/slam2d/vertex_se2.h"
-#include "g2o_types_slam2d_addons_api.h"
-#include "vertex_segment2d.h"
-
-namespace g2o {
-
-class EdgeSE2Segment2DLine
-    : public BaseBinaryEdge<2, Vector2, VertexSE2, VertexSegment2D>  // Avoid redefinition of BaseEdge in MSVC
-{
- public:
-  G2O_TYPES_SLAM2D_ADDONS_API EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DLine();
-
-  G2O_TYPES_SLAM2D_ADDONS_API number_t theta() const { return _measurement[0]; }
-  G2O_TYPES_SLAM2D_ADDONS_API number_t rho() const { return _measurement[1]; }
-
-  G2O_TYPES_SLAM2D_ADDONS_API void setTheta(number_t t) { _measurement[0] = t; }
-  G2O_TYPES_SLAM2D_ADDONS_API void setRho(number_t r) { _measurement[1] = r; }
-
-  G2O_TYPES_SLAM2D_ADDONS_API void computeError() {
-    const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-    const VertexSegment2D* l2 = static_cast<const VertexSegment2D*>(_vertices[1]);
-    SE2 iEst = v1->estimate().inverse();
-    Vector2 predP1 = iEst * l2->estimateP1();
-    Vector2 predP2 = iEst * l2->estimateP2();
-    Vector2 dP = predP2 - predP1;
-    Vector2 normal(dP.y(), -dP.x());
-    normal.normalize();
-    Vector2 prediction(std::atan2(normal.y(), normal.x()), predP1.dot(normal) * .5 + predP2.dot(normal) * .5);
-
-    _error = prediction - _measurement;
-    _error[0] = normalize_theta(_error[0]);
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool setMeasurementData(const number_t* d) {
-    Eigen::Map<const Vector2> data(d);
-    _measurement = data;
-    return true;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool getMeasurementData(number_t* d) const {
-    Eigen::Map<Vector2> data(d);
-    data = _measurement;
-    return true;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual int measurementDimension() const { return 2; }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool setMeasurementFromState() {
-    const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-    const VertexSegment2D* l2 = static_cast<const VertexSegment2D*>(_vertices[1]);
-    SE2 iEst = v1->estimate().inverse();
-    Vector2 predP1 = iEst * l2->estimateP1();
-    Vector2 predP2 = iEst * l2->estimateP2();
-    Vector2 dP = predP2 - predP1;
-    Vector2 normal(dP.y(), -dP.x());
-    normal.normalize();
-    Vector2 prediction(std::atan2(normal.y(), normal.x()), predP1.dot(normal) * .5 + predP2.dot(normal) * .5);
-    _measurement = prediction;
-    return true;
-  }
-
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool read(std::istream& is);
-  G2O_TYPES_SLAM2D_ADDONS_API virtual bool write(std::ostream& os) const;
-
-  /* #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES */
-  /*       virtual void linearizeOplus(); */
-  /* #endif */
-};
-
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DLineWriteGnuplotAction: public WriteGnuplotAction { */
-/*   public: */
-/*     EdgeSE2Segment2DLineWriteGnuplotAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-
-/* #ifdef G2O_HAVE_OPENGL */
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DLineDrawAction: public DrawAction{ */
-/*   public: */
-/*     EdgeSE2Segment2DLineDrawAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-/* #endif */
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/types/slam2d_addons/edge_se2_segment2d_pointLine.cpp b/g2o/types/slam2d_addons/edge_se2_segment2d_pointLine.cpp
deleted file mode 100644
index b759080c..00000000
--- a/g2o/types/slam2d_addons/edge_se2_segment2d_pointLine.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se2_segment2d_pointLine.h"
-
-namespace g2o {
-
-EdgeSE2Segment2DPointLine::EdgeSE2Segment2DPointLine()
-    : BaseBinaryEdge<3, Vector3, VertexSE2, VertexSegment2D>(), _pointNum(0) {}
-
-bool EdgeSE2Segment2DPointLine::read(std::istream& is) {
-  is >> _pointNum;
-  internal::readVector(is, _measurement);
-  return readInformationMatrix(is);
-}
-
-bool EdgeSE2Segment2DPointLine::write(std::ostream& os) const {
-  os << _pointNum << " ";
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam2d_addons/edge_se2_segment2d_pointLine.h b/g2o/types/slam2d_addons/edge_se2_segment2d_pointLine.h
deleted file mode 100644
index 09afaa77..00000000
--- a/g2o/types/slam2d_addons/edge_se2_segment2d_pointLine.h
+++ /dev/null
@@ -1,129 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE2_SEGMENT2D_POINTLINE_H
-#define G2O_EDGE_SE2_SEGMENT2D_POINTLINE_H
-
-#include "g2o/config.h"
-#include "g2o/types/slam2d/vertex_se2.h"
-#include "vertex_segment2d.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam2d_addons_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DPointLine : public BaseBinaryEdge<3, Vector3, VertexSE2, VertexSegment2D>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      EdgeSE2Segment2DPointLine();
-
-      number_t   theta() const {return _measurement[2];}
-      Vector2 point()   const {Eigen::Map<const Vector2> p(&_measurement[0]); return p;}
-
-      void   setTheta(number_t t)  {_measurement[2] = t;}
-      void   setPoint(const Vector2& p_)  {Eigen::Map<Vector2> p(&_measurement[0]); p=p_; }
-
-      int pointNum() const {return _pointNum;}
-      void setPointNum(int pn) {_pointNum = pn;}
-
-      void computeError()
-      {
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexSegment2D* l2 = static_cast<const VertexSegment2D*>(_vertices[1]);
-        SE2 iEst=v1->estimate().inverse();
-        Vector2 predP1 = iEst * l2->estimateP1();
-        Vector2 predP2 = iEst * l2->estimateP2();
-        Vector2 dP = predP2 - predP1;
-        Vector2 normal(dP.y(), -dP.x()); normal.normalize();
-        Vector3 prediction;
-        prediction [2] = std::atan2(normal.y(), normal.x());
-        Eigen::Map<Vector2> pt(&prediction[0]);
-        pt = (_pointNum==0) ? predP1 : predP2;
-        _error = prediction - _measurement;
-        _error[2]=normalize_theta(_error[2]);
-      }
-
-      virtual bool setMeasurementData(const number_t* d) {
-        Eigen::Map<const Vector3> data(d);
-        _measurement = data;
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-        Eigen::Map<Vector3> data(d);
-        data = _measurement;
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 3;}
-
-      virtual bool setMeasurementFromState(){
-        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
-        const VertexSegment2D* l2 = static_cast<const VertexSegment2D*>(_vertices[1]);
-        SE2 iEst=v1->estimate().inverse();
-        Vector2 predP1 = iEst * l2->estimateP1();
-        Vector2 predP2 = iEst * l2->estimateP2();
-        Vector2 dP = predP2 - predP1;
-        Vector2 normal(dP.y(), -dP.x()); normal.normalize();
-        Vector3 prediction;
-        prediction [2] = std::atan2(normal.y(), normal.x());
-        Eigen::Map<Vector2> pt(&prediction[0]);
-        pt = (_pointNum==0)?predP1:predP2;
-        setMeasurement(prediction);
-        return true;
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-  protected:
-      int _pointNum;
-
-/* #ifndef NUMERIC_JACOBIAN_TWO_D_TYPES */
-/*       virtual void linearizeOplus(); */
-/* #endif */
-  };
-
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DPointLineWriteGnuplotAction: public WriteGnuplotAction { */
-/*   public: */
-/*     EdgeSE2Segment2DPointLineWriteGnuplotAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-
-/* #ifdef G2O_HAVE_OPENGL */
-/*   class G2O_TYPES_SLAM2D_ADDONS_API EdgeSE2Segment2DPointLineDrawAction: public DrawAction{ */
-/*   public: */
-/*     EdgeSE2Segment2DPointLineDrawAction(); */
-/*     virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,  */
-/*             HyperGraphElementAction::Parameters* params_); */
-/*   }; */
-/* #endif */
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam2d_addons/g2o_types_slam2d_addons_api.h b/g2o/types/slam2d_addons/g2o_types_slam2d_addons_api.h
deleted file mode 100644
index 2f5e320f..00000000
--- a/g2o/types/slam2d_addons/g2o_types_slam2d_addons_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_SLAM2D_ADDONS_API_H
-#define G2O_TYPES_SLAM2D_ADDONS_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_slam2d_addons_EXPORTS
-#define G2O_TYPES_SLAM2D_ADDONS_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SLAM2D_ADDONS_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SLAM2D_ADDONS_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SLAM2D_ADDONS_API
-#endif
-
-#endif // G2O_TYPES_SLAM2D_ADDONS_API_H
diff --git a/g2o/types/slam2d_addons/line_2d.h b/g2o/types/slam2d_addons/line_2d.h
deleted file mode 100644
index f05b268d..00000000
--- a/g2o/types/slam2d_addons/line_2d.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINE2D_H
-#define G2O_LINE2D_H
-
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-#include "g2o/types/slam2d/se2.h"
-#include "g2o_types_slam2d_addons_api.h"
-
-namespace g2o {
-
-struct Line2D : public Vector2 {
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  Line2D() { setZero(); }
-  Line2D(const Vector2& v) {
-    (*this)(0) = v(0);
-    (*this)(1) = v(1);
-  }
-};
-
-inline Line2D operator*(const SE2& t, const Line2D& l) {
-  Line2D est = l;
-  est[0] += t.rotation().angle();
-  est[0] = normalize_theta(est[0]);
-  Vector2 n(std::cos(est[0]), std::sin(est[0]));
-  est[1] += n.dot(t.translation());
-  return est;
-}
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/types/slam2d_addons/types_slam2d_addons.cpp b/g2o/types/slam2d_addons/types_slam2d_addons.cpp
deleted file mode 100644
index f753fdd1..00000000
--- a/g2o/types/slam2d_addons/types_slam2d_addons.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_slam2d_addons.h"
-
-#include "g2o/core/factory.h"
-
-#include "g2o/stuff/macros.h"
-
-#include <iostream>
-
-namespace g2o {
-
-  G2O_REGISTER_TYPE_GROUP(slam2d_segment);
-
-  G2O_REGISTER_TYPE(VERTEX_SEGMENT2D, VertexSegment2D);
-  G2O_REGISTER_TYPE(VERTEX_LINE2D, VertexLine2D);
-
-  G2O_REGISTER_TYPE(EDGE_SE2_SEGMENT2D, EdgeSE2Segment2D);
-  G2O_REGISTER_TYPE(EDGE_SE2_SEGMENT2D_LINE, EdgeSE2Segment2DLine);
-  G2O_REGISTER_TYPE(EDGE_SE2_SEGMENT2D_POINTLINE, EdgeSE2Segment2DPointLine);
-  G2O_REGISTER_TYPE(EDGE_SE2_LINE2D, EdgeSE2Line2D);
-	G2O_REGISTER_TYPE(EDGE_LINE2D, EdgeLine2D);
-  G2O_REGISTER_TYPE(EDGE_LINE2D_POINTXY, EdgeLine2DPointXY);
-
-#ifdef G2O_HAVE_OPENGL
-  G2O_REGISTER_ACTION(VertexSegment2DDrawAction);
-  G2O_REGISTER_ACTION(VertexLine2DDrawAction);
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d_addons/types_slam2d_addons.h b/g2o/types/slam2d_addons/types_slam2d_addons.h
deleted file mode 100644
index ddb9b97d..00000000
--- a/g2o/types/slam2d_addons/types_slam2d_addons.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_SLAM2D_SEGMENT_
-#define G2O_TYPES_SLAM2D_SEGMENT_
-
-#include "g2o/config.h"
-#include "g2o/types/slam2d/types_slam2d.h"
-
-// line slam ver 1
-#include "edge_se2_segment2d.h"
-#include "edge_se2_segment2d_line.h"
-#include "edge_se2_segment2d_pointLine.h"
-
-// line slam ver 2
-#include "edge_se2_line2d.h"
-#include "edge_line2d_pointxy.h"
-#include "edge_line2d.h"
-
-#endif
diff --git a/g2o/types/slam2d_addons/vertex_line2d.cpp b/g2o/types/slam2d_addons/vertex_line2d.cpp
deleted file mode 100644
index 5d61be99..00000000
--- a/g2o/types/slam2d_addons/vertex_line2d.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_line2d.h"
-
-#ifdef WINDOWS
-#include <windows.h>
-#endif
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-namespace g2o {
-
-  VertexLine2D::VertexLine2D() :
-    BaseVertex<2, Line2D>(), p1Id(-1), p2Id(-1)
-  {
-    _estimate.setZero();
-  }
-
-  bool VertexLine2D::read(std::istream& is)
-  {
-    is >> _estimate[0] >> _estimate[1] >> p1Id >> p2Id;
-    return true;
-  }
-
-  bool VertexLine2D::write(std::ostream& os) const
-  {
-    os << estimate()(0) << " " << estimate()(1) << " " << p1Id << " " << p2Id;
-    return os.good();
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  VertexLine2DDrawAction::VertexLine2DDrawAction() : DrawAction(typeid(VertexLine2D).name()), _pointSize(nullptr) {}
-
-  bool VertexLine2DDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (! DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _pointSize = _previousParams->makeProperty<FloatProperty>(_typeName + "::POINT_SIZE", 1.);
-    } else {
-      _pointSize = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexLine2DDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                     HyperGraphElementAction::Parameters* params_ ){
-
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    VertexLine2D* that = static_cast<VertexLine2D*>(element);
-    glPushAttrib(GL_CURRENT_BIT | GL_BLEND);
-    if (_pointSize) {
-      glPointSize(_pointSize->value());
-    }
-    Vector2 n(std::cos(that->theta()), std::sin(that->theta()));
-    Vector2 pmiddle=n*that->rho();
-    Vector2 t(-n.y(), n.x());
-    number_t l1{},l2 = 10;
-    VertexPointXY *vp1=0, *vp2=0;
-    vp1=dynamic_cast<VertexPointXY*> (that->graph()->vertex(that->p1Id));
-    vp2=dynamic_cast<VertexPointXY*> (that->graph()->vertex(that->p2Id));
-
-    glColor4f(0.8f,0.5f,0.3f,0.3f);
-    if (vp1 && vp2) {
-      glColor4f(0.8f,0.5f,0.3f,0.7f);
-    } else if (vp1 || vp2){
-      glColor4f(0.8f,0.5f,0.3f,0.5f);
-    }
-
-    if (vp1) {
-      glColor4f(0.8f,0.5f,0.3f,0.7f);
-      l1 = t.dot(vp1->estimate()-pmiddle);
-    }
-    if (vp2) {
-      glColor4f(0.8f,0.5f,0.3f,0.7f);
-      l2 = t.dot(vp2->estimate()-pmiddle);
-    }
-    Vector2 p1=pmiddle+t*l1;
-    Vector2 p2=pmiddle+t*l2;
-    glBegin(GL_LINES);
-    glVertex3f((float)p1.x(),p1.y(),0.f);
-    glVertex3f((float)p2.x(),p2.y(),0.f);
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d_addons/vertex_line2d.h b/g2o/types/slam2d_addons/vertex_line2d.h
deleted file mode 100644
index 8f8375de..00000000
--- a/g2o/types/slam2d_addons/vertex_line2d.h
+++ /dev/null
@@ -1,109 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_LINE2D_H
-#define G2O_VERTEX_LINE2D_H
-
-#include "g2o_types_slam2d_addons_api.h"
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "g2o/stuff/misc.h"
-#include "g2o/types/slam2d/vertex_point_xy.h"
-#include "line_2d.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM2D_ADDONS_API VertexLine2D : public BaseVertex<2, Line2D>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexLine2D();
-
-      number_t theta() const {return _estimate[0]; }
-      void setTheta(number_t t) { _estimate[0] = t; }
-
-      number_t rho() const {return _estimate[1]; }
-      void setRho(number_t r) { _estimate[1] = r; }
-
-      virtual void setToOriginImpl() {
-        _estimate.setZero();
-      }
-
-      virtual bool setEstimateDataImpl(const number_t* est){
-        Eigen::Map<const Vector2> v(est);
-        _estimate=Line2D(v);
-        return true;
-      }
-
-      virtual bool getEstimateData(number_t* est) const{
-        Eigen::Map<Vector2> v(est);
-        v=_estimate;
-        return true;
-      }
-
-      virtual int estimateDimension() const {
-        return 2;
-      }
-
-      virtual bool setMinimalEstimateDataImpl(const number_t* est){
-        return setEstimateData(est);
-      }
-
-      virtual bool getMinimalEstimateData(number_t* est) const{
-        return getEstimateData(est);
-      }
-
-      virtual int minimalEstimateDimension() const {
-        return 2;
-      }
-
-      virtual void oplusImpl(const number_t* update)
-      {
-        _estimate += Eigen::Map<const Vector2>(update);
-        _estimate(0) = normalize_theta(_estimate(0));
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-      int p1Id, p2Id;
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM2D_ADDONS_API VertexLine2DDrawAction: public DrawAction{
-  public:
-    VertexLine2DDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_);
-  protected:
-    FloatProperty *_pointSize;
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/slam2d_addons/vertex_segment2d.cpp b/g2o/types/slam2d_addons/vertex_segment2d.cpp
deleted file mode 100644
index d200cc8e..00000000
--- a/g2o/types/slam2d_addons/vertex_segment2d.cpp
+++ /dev/null
@@ -1,119 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_segment2d.h"
-
-#ifdef WINDOWS
-#include <windows.h>
-#endif
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-#include <typeinfo>
-
-#include "g2o/stuff/macros.h"
-
-namespace g2o {
-
-  VertexSegment2D::VertexSegment2D() :
-    BaseVertex<4, Vector4>()
-  {
-    _estimate.setZero();
-  }
-
-  bool VertexSegment2D::read(std::istream& is)
-  {
-    return internal::readVector(is, _estimate);
-  }
-
-  bool VertexSegment2D::write(std::ostream& os) const
-  {
-    return internal::writeVector(os, estimate());
-  }
-
-  VertexSegment2DWriteGnuplotAction::VertexSegment2DWriteGnuplotAction(): WriteGnuplotAction(typeid(VertexSegment2D).name()){}
-
-  HyperGraphElementAction* VertexSegment2DWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    VertexSegment2D* v =  static_cast<VertexSegment2D*>(element);
-    *(params->os) << v->estimateP1().x() << " " << v->estimateP1().y() << std::endl;
-    *(params->os) << v->estimateP2().x() << " " << v->estimateP2().y() << std::endl;
-    *(params->os) << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  VertexSegment2DDrawAction::VertexSegment2DDrawAction()
-      : DrawAction(typeid(VertexSegment2D).name()), _pointSize(nullptr) {}
-
-  bool VertexSegment2DDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (! DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _pointSize = _previousParams->makeProperty<FloatProperty>(_typeName + "::POINT_SIZE", 1.);
-    } else {
-      _pointSize = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexSegment2DDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                     HyperGraphElementAction::Parameters* params_ ){
-
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    VertexSegment2D* that = static_cast<VertexSegment2D*>(element);
-    glColor3f(0.8f,0.5f,0.3f);
-    if (_pointSize) {
-      glPointSize(_pointSize->value());
-    }
-    glBegin(GL_LINES);
-    glVertex3f((float)that->estimateP1().x(),(float)that->estimateP1().y(),0.f);
-    glVertex3f((float)that->estimateP2().x(),(float)that->estimateP2().y(),0.f);
-    glEnd();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam2d_addons/vertex_segment2d.h b/g2o/types/slam2d_addons/vertex_segment2d.h
deleted file mode 100644
index ab7e67a9..00000000
--- a/g2o/types/slam2d_addons/vertex_segment2d.h
+++ /dev/null
@@ -1,108 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_SEGMENT_2D_H
-#define G2O_VERTEX_SEGMENT_2D_H
-
-#include <Eigen/Core>
-
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "g2o_types_slam2d_addons_api.h"
-
-namespace g2o {
-
-class G2O_TYPES_SLAM2D_ADDONS_API VertexSegment2D : public BaseVertex<4, Vector4> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-  VertexSegment2D();
-
-  Vector2 estimateP1() const { return Eigen::Map<const Vector2>(&(_estimate[0])); }
-  Vector2 estimateP2() const { return Eigen::Map<const Vector2>(&(_estimate[2])); }
-  void setEstimateP1(const Vector2& p1) {
-    Eigen::Map<Vector2> v(&_estimate[0]);
-    v = p1;
-  }
-  void setEstimateP2(const Vector2& p2) {
-    Eigen::Map<Vector2> v(&_estimate[2]);
-    v = p2;
-  }
-
-  virtual void setToOriginImpl() { _estimate.setZero(); }
-
-  virtual bool setEstimateDataImpl(const number_t* est) {
-    Eigen::Map<const Vector4> v(est);
-    _estimate = v;
-    return true;
-  }
-
-  virtual bool getEstimateData(number_t* est) const {
-    Eigen::Map<Vector4> v(est);
-    v = _estimate;
-    return true;
-  }
-
-  virtual int estimateDimension() const { return 4; }
-
-  virtual bool setMinimalEstimateDataImpl(const number_t* est) { return setEstimateData(est); }
-
-  virtual bool getMinimalEstimateData(number_t* est) const { return getEstimateData(est); }
-
-  virtual int minimalEstimateDimension() const { return 4; }
-
-  virtual void oplusImpl(const number_t* update) {
-    Eigen::Map<const Vector4> upd(update);
-    _estimate += upd;
-  }
-
-  virtual bool read(std::istream& is);
-  virtual bool write(std::ostream& os) const;
-};
-
-class G2O_TYPES_SLAM2D_ADDONS_API VertexSegment2DWriteGnuplotAction : public WriteGnuplotAction {
- public:
-  VertexSegment2DWriteGnuplotAction();
-  virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-                                              HyperGraphElementAction::Parameters* params_);
-};
-
-#ifdef G2O_HAVE_OPENGL
-class G2O_TYPES_SLAM2D_ADDONS_API VertexSegment2DDrawAction : public DrawAction {
- public:
-  VertexSegment2DDrawAction();
-  virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-                                              HyperGraphElementAction::Parameters* params_);
-
- protected:
-  FloatProperty* _pointSize;
-  virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-};
-#endif
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/types/slam3d/CMakeLists.txt b/g2o/types/slam3d/CMakeLists.txt
deleted file mode 100644
index 2c0deb30..00000000
--- a/g2o/types/slam3d/CMakeLists.txt
+++ /dev/null
@@ -1,61 +0,0 @@
-add_library(types_slam3d ${G2O_LIB_TYPE}
-  dquat2mat.cpp dquat2mat.h
-  isometry3d_mappings.h
-  isometry3d_mappings.cpp
-  isometry3d_gradients.cpp
-  isometry3d_gradients.h
-  vertex_se3.cpp
-  vertex_se3.h
-  parameter_se3_offset.cpp
-  parameter_se3_offset.h
-  edge_se3.cpp
-  edge_se3.h
-  edge_se3_offset.cpp
-  edge_se3_offset.h
-  vertex_pointxyz.cpp
-  vertex_pointxyz.h
-  parameter_camera.cpp
-  parameter_camera.h
-  parameter_stereo_camera.cpp
-  parameter_stereo_camera.h
-  edge_se3_pointxyz.cpp
-  edge_se3_pointxyz.h
-  edge_se3_pointxyz_disparity.cpp
-  edge_se3_pointxyz_disparity.h
-  edge_se3_pointxyz_depth.cpp
-  edge_se3_pointxyz_depth.h
-  edge_se3_prior.cpp
-  edge_se3_prior.h
-  edge_se3_xyzprior.cpp
-  edge_se3_xyzprior.h
-  edge_se3_lotsofxyz.cpp
-  edge_se3_lotsofxyz.h
-  edge_xyz_prior.cpp
-  edge_xyz_prior.h
-  se3quat.h
-  se3_ops.h se3_ops.hpp
-  edge_pointxyz.cpp edge_pointxyz.h
-  types_slam3d.cpp
-  types_slam3d.h
-)
-
-
-set_target_properties(types_slam3d PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_slam3d)
-if (APPLE)
-  set_target_properties(types_slam3d PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_slam3d core)
-if(G2O_HAVE_OPENGL)
-  target_link_libraries(types_slam3d opengl_helper ${OPENGL_gl_LIBRARY} )
-endif()
-
-install(TARGETS types_slam3d
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/slam3d)
diff --git a/g2o/types/slam3d/dquat2mat.cpp b/g2o/types/slam3d/dquat2mat.cpp
deleted file mode 100644
index cac14b55..00000000
--- a/g2o/types/slam3d/dquat2mat.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "dquat2mat.h"
-#include <iostream>
-namespace g2o {
-  namespace internal {
-    using namespace std;
-
-#include "dquat2mat_maxima_generated.cpp"
-
-    int _q2m(number_t& S, number_t& qw, const number_t&  r00 , const number_t&  r10 , const number_t&  r20 , const number_t&  r01 , const number_t&  r11 , const number_t&  r21 , const number_t&  r02 , const number_t&  r12 , const number_t&  r22 ){
-      number_t tr=r00 + r11 + r22;
-      if (tr > 0) { 
-	S = sqrt(tr + 1.0) * 2; // S=4*qw 
-	qw = 0.25 * S;
-	// qx = (r21 - r12) / S;
-	// qy = (r02 - r20) / S; 
-	// qz = (r10 - r01) / S; 
-	return 0;
-      } else if ((r00 > r11)&(r00 > r22)) { 
-	S = sqrt(1.0 + r00 - r11 - r22) * 2; // S=4*qx 
-	qw = (r21 - r12) / S;
-	// qx = 0.25 * S;
-	// qy = (r01 + r10) / S; 
-	// qz = (r02 + r20) / S; 
-	return 1;
-      } else if (r11 > r22) { 
-	S = sqrt(1.0 + r11 - r00 - r22) * 2; // S=4*qy
-	qw = (r02 - r20) / S;
-	// qx = (r01 + r10) / S; 
-	// qy = 0.25 * S;
-	return 2;
-      } else { 
-	S = sqrt(1.0 + r22 - r00 - r11) * 2; // S=4*qz
-	qw = (r10 - r01) / S;
-	// qx = (r02 + r20) / S;
-	// qy = (r12 + r21) / S;
-	// qz = 0.25 * S;
-	return 3;
-      }
-    }
-    
-    void  compute_dq_dR ( Eigen::Matrix<number_t, 3, 9, Eigen::ColMajor>&  dq_dR , const number_t&  r11 , const number_t&  r21 , const number_t&  r31 , const number_t&  r12 , const number_t&  r22 , const number_t&  r32 , const number_t&  r13 , const number_t&  r23 , const number_t&  r33 ){
-      number_t qw;
-      number_t S;
-      int whichCase=_q2m( S, qw, r11 ,  r21 ,  r31 ,  r12 ,  r22 ,  r32 ,  r13 ,  r23 ,  r33 );
-      S*=.25;
-      switch(whichCase){
-      case 0: compute_dq_dR_w(dq_dR, S, r11 ,  r21 ,  r31 ,  r12 ,  r22 ,  r32 ,  r13 ,  r23 ,  r33 ); 
-	break;
-      case 1: compute_dq_dR_x(dq_dR, S, r11 ,  r21 ,  r31 ,  r12 ,  r22 ,  r32 ,  r13 ,  r23 ,  r33 ); 
-	break;
-      case 2: compute_dq_dR_y(dq_dR, S, r11 ,  r21 ,  r31 ,  r12 ,  r22 ,  r32 ,  r13 ,  r23 ,  r33 ); 
-	break;
-      case 3: compute_dq_dR_z(dq_dR, S, r11 ,  r21 ,  r31 ,  r12 ,  r22 ,  r32 ,  r13 ,  r23 ,  r33 ); 
-	break;
-      }
-      if (qw<=0)
-	dq_dR *= -1;
-    }
-  }
-}
diff --git a/g2o/types/slam3d/dquat2mat.h b/g2o/types/slam3d/dquat2mat.h
deleted file mode 100644
index f571d5d2..00000000
--- a/g2o/types/slam3d/dquat2mat.h
+++ /dev/null
@@ -1,40 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef _DQUAT2MAT_H_
-#define _DQUAT2MAT_H_
-#include <Eigen/Core>
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-  namespace internal {
-
-    void  G2O_TYPES_SLAM3D_API compute_dq_dR ( Eigen::Matrix<number_t, 3 , 9, Eigen::ColMajor>&  dq_dR , const number_t&  r11 , const number_t&  r21 , const number_t&  r31 , const number_t&  r12 , const number_t&  r22 , const number_t&  r32 , const number_t&  r13 , const number_t&  r23 , const number_t&  r33 );
-
-    void  G2O_TYPES_SLAM3D_API compute_dR_dq ( Eigen::Matrix<number_t, 9 , 3, Eigen::ColMajor>&  dR_dq , const number_t&  qx , const number_t&  qy , const number_t&  qz , const number_t&  qw ) ;
-  }
-}
-#endif
diff --git a/g2o/types/slam3d/dquat2mat.wxm b/g2o/types/slam3d/dquat2mat.wxm
deleted file mode 100644
index 24a4a98a..00000000
--- a/g2o/types/slam3d/dquat2mat.wxm
+++ /dev/null
@@ -1,237 +0,0 @@
-/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
-/* [ Created with wxMaxima version 11.04.0 ] */
-
-/* [wxMaxima: comment start ]
-wxMaxima 0.8.2 http://wxmaxima.sourceforge.net
-Maxima 5.17.1 http://maxima.sourceforge.net
-Using Lisp GNU Common Lisp (GCL) GCL 2.6.7 (aka GCL)
-Distributed under the GNU Public License. See the file COPYING.
-Dedicated to the memory of William Schelter.
-The function bug_report() provides bug reporting information.
-   [wxMaxima: comment end   ] */
-
-/* [wxMaxima: input   start ] */
-/*routines to produce C++ code*/
-
-matchdeclare(__b,integerp)$
-matchdeclare(__a,lambda([e],true))$
-defrule(makefloat,div(__a,__b),__a/float(__b))$
-defrule(addfrac,pow(__a,-1),1./__a)$
-
-cstring(expr):=(
-    e:subst(div,"/",subst(pow,"^",expr)),
-    e2:apply2(e,makefloat,addfrac),
-    string(subst("/",div,e2))
-)$
-
-
-printargs(args):=(
- for d in args do (
-    sprint(", const double& ", d))
-)$
-
-printretarg(name,expr):=(
-    e:last(expr),
-    if (matrixp(e)) then (
-     s:matrix_size(e),
-     sprint("Eigen::Matrix<double,"),
-     sprint(s[1],",",s[2]),
-     sprint(">& "),
-     sprint(name)
-    ) else if (listp(e)) then (
-     s:length(e),
-     sprint("Eigen::Vector<double,"),
-     sprint(s, ">& "),
-     sprint(name)
-    ) else (
-     sprint ("double&", name)      
-    )
-)$                                                
-
-printretexpr(name,expr):=(
-    if (matrixp(expr)) then (
-        printmatrix(name,expr)
-    ) else if (listp(expr)) then (
-        printlist(name,expr)
-    ) else (
-        sprint ("  ",name,"=",cstring(expr))
-    )
-)$
-
-
-printdef(expr) := (sprint("  double ", first(expr), "=", cstring(second(expr)), ";"), 
-                                freshline())$
-
-printmatrix(dest,exp):=(
-    if (matrixp(expr)) then(
-        s:matrix_size(expr),
-        for r:1 thru s[1] step 1 do(
-            for c:1 thru s[2] step 1 do(
-                sprint ("  ",dest,"(",r-1,",",c-1,") ="),
-                sprint(cstring(expr[r,c])),
-                sprint(";"),
-                freshline()
-            )
-        )
-
-    ) 
-)$
-
-printlist(dest,expr):=(
-    if (listp(expr)) then(
-        s:length(expr),
-        for r:1 thru s step 1 do(
-            sprint ("  ",dest,"(",r-1,") ="),
-            sprint(cstring(expr[r])),
-            sprint(";"),
-            freshline()
-        )
-
-    ) 
-)$
-
-block2c(name,expr) :=
-        if ?equal(op(expr), block) then (
-                for d in reverse(rest(reverse(rest(expr)))) do printdef(d),
-                printretexpr(name,last(expr)))
-        else
-                printretexpr(name,expr)$
-
-expr2c(funcname, expr, outarg, args) := (
-        sprint("void ",funcname, "("),
-
-        printretarg(outarg,expr),
-        printargs(args),
-        sprint(") {"),
-        freshline(),
-        expr2:subst(pow, "^", expr), 
-        block2c(outarg, expr2),
-        sprint("}"),
-        freshline(),
-        freshline(),
-        freshline(),
-        freshline()
-)$
-/* [wxMaxima: input   end   ] */
-
-/* [wxMaxima: input   start ] */
-mat2lin(A):=[A[1,1], A[2,1], A[3,1], A[1,2], A[2,2], A[3,2], A[1,3], A[2,3], A[3,3]]$
-
-lin2mat(r):=matrix([r[1],r[4],r[7]], [r[2],r[5],r[8]], [r[3],r[6],r[9]])$
-
-R:matrix([r11,r12,r13],[r21,r22,r23],[r31,r32,r33])$
-
-lin2mat(mat2lin(R))$
-/* [wxMaxima: input   end   ] */
-
-/* [wxMaxima: input   start ] */
-_fullQuat2mat(qx, qy, qz, qw) := matrix([qw*qw + qx*qx - qy*qy - qz*qz, 2*(qx*qy - qw*qz), 2*(qx*qz + qw*qy)],
-    [2*(qx*qy + qz*qw), qw*qw - qx*qx + qy*qy - qz*qz, 2*(qy*qz - qx*qw)],
-    [2*(qx*qz - qy*qw), 2*(qy*qz + qx*qw), qw*qw - qx*qx - qy*qy + qz*qz])$
-
-fullQuat2mat(q) := _fullQuat2mat(q[1], q[2], q[3], q[4])$
-fullQuat2linMat(q) := mat2lin(fullQuat2mat(q))$
-
-mat2fullQuat(R) := 
-  [(R[3,2]-R[2,3])/(2*sqrt(1+R[1,1]+R[2,2]+R[3,3])),
-   (R[1,3]-R[3,1])/(2*sqrt(1+R[1,1]+R[2,2]+R[3,3])),
-   (R[2,1]-R[1,2])/(2*sqrt(1+R[1,1]+R[2,2]+R[3,3])),
-    .5*sqrt(1+R[1,1]+R[2,2]+R[3,3])]$
-
-linMat2fullQuat(r) :=mat2fullQuat(lin2mat(r))$
-
-w3(q):=sqrt(1.-q[1]^2-q[2]^2-q[3]^2)$
-
-quat2mat(q):= fullQuat2mat([q[1], q[2], q[3], w3(q)])$
-quat2linMat(q):= fullQuat2linMat([q[1], q[2], q[3], w3(q)])$
-mat2quat(R):= [(R[3,2]-R[2,3])/(2*sqrt(1+R[1,1]+R[2,2]+R[3,3])),
-   (R[1,3]-R[3,1])/(2*sqrt(1+R[1,1]+R[2,2]+R[3,3])),
-   (R[2,1]-R[1,2])/(2*sqrt(1+R[1,1]+R[2,2]+R[3,3]))]$
-
-linMat2quat(r) := mat2quat(lin2mat(r))$
-/* [wxMaxima: input   end   ] */
-
-/* [wxMaxima: input   start ] */
-dr_dq:jacobian(quat2linMat([qx, qy, qz]), [qx, qy, qz])$
-dr_dq:ratsubst(qw,sqrt(1.-qx^2-qy^2-qz^2),dr_dq)$
-dr_dqx:diff(quat2mat([qx, qy, qz]), qx)$
-dr_dqy:diff(quat2mat([qx, qy, qz]), qy)$
-dr_dqz:diff(quat2mat([qx, qy, qz]), qz)$
-Sx:ev(dr_dqx, qx:0, qy:0, qz:0)$
-Sy:ev(dr_dqy, qx:0, qy:0, qz:0)$
-Sz:ev(dr_dqz, qx:0, qy:0, qz:0)$
-SxT:transpose(Sx)$
-SyT:transpose(Sy)$
-SzT:transpose(Sz)$
-
-
-s_times_t:[Sx.[tx,ty, tz], Sy.[tx,ty, tz], Sz.[tx,ty, tz]]$
-st_times_t:[SxT.[tx,ty, tz], SyT.[tx,ty, tz], SzT.[tx,ty, tz]]$
-R:matrix([r11, r12, r13],[r21, r22, r23],[r31, r32, r33])$
-s_times_R:[Sx.R, Sy.R, Sz.R]$
-st_times_R:[SxT.R, SyT.R, SzT.R]$
-
-dq_dr:jacobian(linMat2quat([r00, r10, r20, r01, r11, r21, r02, r12, r22]), [r00, r10, r20, r01, r11, r21, r02, r12, r22])$
-dq_dr_old:ratsubst(qw,.5*sqrt(r00+r11+r22+1),dq_dr);
-/* [wxMaxima: input   end   ] */
-
-/* [wxMaxima: input   start ] */
-S_w(r00, r11, r22) := sqrt(1 + r00 + r11 + r22) * 2$ 
-m2q_w(r00, r10, r20, r01, r11, r21, r02, r12, r22):=
-[(r21 - r12) / S_w(r00, r11, r22),
- (r02 - r20) / S_w(r00, r11, r22), 
- (r10 - r01) / S_w(r00, r11, r22)]$
-
-S_x(r00, r11, r22) := sqrt(1.0 + r00 - r11 - r22) * 2$
-m2q_x(r00, r10, r20, r01, r11, r21, r02, r12, r22):=
-[ 0.25 * S_x(r00, r11, r22),
-  (r01 + r10) / S_x(r00, r11, r22), 
-  (r02 + r20) / S_x(r00, r11, r22)]$
-
-S_y(r00, r11, r22) := sqrt(1.0 - r00 + r11 - r22) * 2$
-m2q_y(r00, r10, r20, r01, r11, r21, r02, r12, r22):=
-[ (r01 + r10) / S_y(r00, r11, r22), 
-  0.25 * S_y(r00, r11, r22),
-  (r12 + r21) / S_y(r00, r11, r22)
- ]$
-
-S_z(r00, r11, r22) := sqrt(1.0 - r00 - r11 + r22) * 2$
-m2q_z(r00, r10, r20, r01, r11, r21, r02, r12, r22):=
-[
-  (r02 + r20) / S_z(r00, r11, r22),
-  (r12 + r21) / S_z(r00, r11, r22),
-  0.25 * S_z(r00, r11, r22)
-]$
-
-dq_dR_w:jacobian(m2q_w(r00, r10, r20, r01, r11, r21, r02, r12, r22),[r00, r10, r20, r01, r11, r21, r02, r12, r22])$
-dq_dR_w:ratsubst(qw, .25*S_w(r00, r11, r22), dq_dR_w);
-
-dq_dR_x:jacobian(m2q_x(r00, r10, r20, r01, r11, r21, r02, r12, r22),[r00, r10, r20, r01, r11, r21, r02, r12, r22])$
-dq_dR_x:ratsubst(qx, .25*S_x(r00, r11, r22), dq_dR_x);
-
-dq_dR_y:jacobian(m2q_y(r00, r10, r20, r01, r11, r21, r02, r12, r22),[r00, r10, r20, r01, r11, r21, r02, r12, r22])$
-dq_dR_y:ratsubst(qy, .25*S_y(r00, r11, r22), dq_dR_y);
-
-dq_dR_z:jacobian(m2q_z(r00, r10, r20, r01, r11, r21, r02, r12, r22),[r00, r10, r20, r01, r11, r21, r02, r12, r22])$
-dq_dR_z:ratsubst(qz, .25*S_z(r00, r11, r22), dq_dR_z);
-/* [wxMaxima: input   end   ] */
-
-/* [wxMaxima: input   start ] */
-optimprefix:_aux$
-opt_dR_dq:optimize(dr_dq);
-opt_dq_dR_old:optimize(dq_dr_old);
-opt_dq_dR_w:optimize(dq_dR_w);
-opt_dq_dR_x:optimize(dq_dR_x);
-opt_dq_dR_y:optimize(dq_dR_y);
-opt_dq_dR_z:optimize(dq_dR_z);
-
-with_stdout("dquat2mat_maxima_generated.cpp",
-        expr2c("compute_dq_dR_w", opt_dq_dR_w, "dq_dR_w", [qw, r00, r10, r20, r01, r11, r21, r02, r12, r22]),
-        expr2c("compute_dq_dR_x", opt_dq_dR_x, "dq_dR_x", [qx, r00, r10, r20, r01, r11, r21, r02, r12, r22]),
-        expr2c("compute_dq_dR_y", opt_dq_dR_y, "dq_dR_y", [qy, r00, r10, r20, r01, r11, r21, r02, r12, r22]),
-        expr2c("compute_dq_dR_z", opt_dq_dR_z, "dq_dR_z", [qz, r00, r10, r20, r01, r11, r21, r02, r12, r22]),
-        expr2c("compute_dR_dq", opt_dR_dq, "dR_dq", [qx, qy, qz, qw]))$
-/* [wxMaxima: input   end   ] */
-
-/* Maxima can't load/batch files which end with a comment! */
-"Created with wxMaxima"$
diff --git a/g2o/types/slam3d/dquat2mat_maxima_generated.cpp b/g2o/types/slam3d/dquat2mat_maxima_generated.cpp
deleted file mode 100644
index d5dcf65c..00000000
--- a/g2o/types/slam3d/dquat2mat_maxima_generated.cpp
+++ /dev/null
@@ -1,237 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-void  compute_dq_dR_w ( Eigen::Matrix<number_t, 3 , 9 >&  dq_dR_w , const number_t&  qw , const number_t&  r00 , const number_t&  r10 , const number_t&  r20 , const number_t&  r01 , const number_t&  r11 , const number_t&  r21 , const number_t&  r02 , const number_t&  r12 , const number_t&  r22 ) { 
-  (void) r00;
-  (void) r11;
-  (void) r22;
-  number_t  _aux1 = 1/pow(qw,3) ; 
-  number_t  _aux2 = -0.03125*(r21-r12)*_aux1 ; 
-  number_t  _aux3 = 1/qw ; 
-  number_t  _aux4 = 0.25*_aux3 ; 
-  number_t  _aux5 = -0.25*_aux3 ; 
-  number_t  _aux6 = 0.03125*(r20-r02)*_aux1 ; 
-  number_t  _aux7 = -0.03125*(r10-r01)*_aux1 ; 
-   dq_dR_w ( 0 , 0 ) = _aux2 ; 
-   dq_dR_w ( 0 , 1 ) = 0 ; 
-   dq_dR_w ( 0 , 2 ) = 0 ; 
-   dq_dR_w ( 0 , 3 ) = 0 ; 
-   dq_dR_w ( 0 , 4 ) = _aux2 ; 
-   dq_dR_w ( 0 , 5 ) = _aux4 ; 
-   dq_dR_w ( 0 , 6 ) = 0 ; 
-   dq_dR_w ( 0 , 7 ) = _aux5 ; 
-   dq_dR_w ( 0 , 8 ) = _aux2 ; 
-   dq_dR_w ( 1 , 0 ) = _aux6 ; 
-   dq_dR_w ( 1 , 1 ) = 0 ; 
-   dq_dR_w ( 1 , 2 ) = _aux5 ; 
-   dq_dR_w ( 1 , 3 ) = 0 ; 
-   dq_dR_w ( 1 , 4 ) = _aux6 ; 
-   dq_dR_w ( 1 , 5 ) = 0 ; 
-   dq_dR_w ( 1 , 6 ) = _aux4 ; 
-   dq_dR_w ( 1 , 7 ) = 0 ; 
-   dq_dR_w ( 1 , 8 ) = _aux6 ; 
-   dq_dR_w ( 2 , 0 ) = _aux7 ; 
-   dq_dR_w ( 2 , 1 ) = _aux4 ; 
-   dq_dR_w ( 2 , 2 ) = 0 ; 
-   dq_dR_w ( 2 , 3 ) = _aux5 ; 
-   dq_dR_w ( 2 , 4 ) = _aux7 ; 
-   dq_dR_w ( 2 , 5 ) = 0 ; 
-   dq_dR_w ( 2 , 6 ) = 0 ; 
-   dq_dR_w ( 2 , 7 ) = 0 ; 
-   dq_dR_w ( 2 , 8 ) = _aux7 ; 
-} 
-void  compute_dq_dR_x ( Eigen::Matrix<number_t, 3 , 9 >&  dq_dR_x , const number_t&  qx , const number_t&  r00 , const number_t&  r10 , const number_t&  r20 , const number_t&  r01 , const number_t&  r11 , const number_t&  r21 , const number_t&  r02 , const number_t&  r12 , const number_t&  r22 ) { 
-  (void) r00;
-  (void) r11;
-  (void) r21;
-  (void) r12;
-  (void) r22;
-  number_t  _aux1 = 1/qx ; 
-  number_t  _aux2 = -0.125*_aux1 ; 
-  number_t  _aux3 = 1/pow(qx,3) ; 
-  number_t  _aux4 = r10+r01 ; 
-  number_t  _aux5 = 0.25*_aux1 ; 
-  number_t  _aux6 = 0.03125*_aux3*_aux4 ; 
-  number_t  _aux7 = r20+r02 ; 
-  number_t  _aux8 = 0.03125*_aux3*_aux7 ; 
-   dq_dR_x ( 0 , 0 ) = 0.125*_aux1 ; 
-   dq_dR_x ( 0 , 1 ) = 0 ; 
-   dq_dR_x ( 0 , 2 ) = 0 ; 
-   dq_dR_x ( 0 , 3 ) = 0 ; 
-   dq_dR_x ( 0 , 4 ) = _aux2 ; 
-   dq_dR_x ( 0 , 5 ) = 0 ; 
-   dq_dR_x ( 0 , 6 ) = 0 ; 
-   dq_dR_x ( 0 , 7 ) = 0 ; 
-   dq_dR_x ( 0 , 8 ) = _aux2 ; 
-   dq_dR_x ( 1 , 0 ) = -0.03125*_aux3*_aux4 ; 
-   dq_dR_x ( 1 , 1 ) = _aux5 ; 
-   dq_dR_x ( 1 , 2 ) = 0 ; 
-   dq_dR_x ( 1 , 3 ) = _aux5 ; 
-   dq_dR_x ( 1 , 4 ) = _aux6 ; 
-   dq_dR_x ( 1 , 5 ) = 0 ; 
-   dq_dR_x ( 1 , 6 ) = 0 ; 
-   dq_dR_x ( 1 , 7 ) = 0 ; 
-   dq_dR_x ( 1 , 8 ) = _aux6 ; 
-   dq_dR_x ( 2 , 0 ) = -0.03125*_aux3*_aux7 ; 
-   dq_dR_x ( 2 , 1 ) = 0 ; 
-   dq_dR_x ( 2 , 2 ) = _aux5 ; 
-   dq_dR_x ( 2 , 3 ) = 0 ; 
-   dq_dR_x ( 2 , 4 ) = _aux8 ; 
-   dq_dR_x ( 2 , 5 ) = 0 ; 
-   dq_dR_x ( 2 , 6 ) = _aux5 ; 
-   dq_dR_x ( 2 , 7 ) = 0 ; 
-   dq_dR_x ( 2 , 8 ) = _aux8 ; 
-} 
-void  compute_dq_dR_y ( Eigen::Matrix<number_t, 3 , 9 >&  dq_dR_y , const number_t&  qy , const number_t&  r00 , const number_t&  r10 , const number_t&  r20 , const number_t&  r01 , const number_t&  r11 , const number_t&  r21 , const number_t&  r02 , const number_t&  r12 , const number_t&  r22 ) { 
-  (void) r00;
-  (void) r20;
-  (void) r11;
-  (void) r02;
-  (void) r22;
-  number_t  _aux1 = 1/pow(qy,3) ; 
-  number_t  _aux2 = r10+r01 ; 
-  number_t  _aux3 = 0.03125*_aux1*_aux2 ; 
-  number_t  _aux4 = 1/qy ; 
-  number_t  _aux5 = 0.25*_aux4 ; 
-  number_t  _aux6 = -0.125*_aux4 ; 
-  number_t  _aux7 = r21+r12 ; 
-  number_t  _aux8 = 0.03125*_aux1*_aux7 ; 
-   dq_dR_y ( 0 , 0 ) = _aux3 ; 
-   dq_dR_y ( 0 , 1 ) = _aux5 ; 
-   dq_dR_y ( 0 , 2 ) = 0 ; 
-   dq_dR_y ( 0 , 3 ) = _aux5 ; 
-   dq_dR_y ( 0 , 4 ) = -0.03125*_aux1*_aux2 ; 
-   dq_dR_y ( 0 , 5 ) = 0 ; 
-   dq_dR_y ( 0 , 6 ) = 0 ; 
-   dq_dR_y ( 0 , 7 ) = 0 ; 
-   dq_dR_y ( 0 , 8 ) = _aux3 ; 
-   dq_dR_y ( 1 , 0 ) = _aux6 ; 
-   dq_dR_y ( 1 , 1 ) = 0 ; 
-   dq_dR_y ( 1 , 2 ) = 0 ; 
-   dq_dR_y ( 1 , 3 ) = 0 ; 
-   dq_dR_y ( 1 , 4 ) = 0.125*_aux4 ; 
-   dq_dR_y ( 1 , 5 ) = 0 ; 
-   dq_dR_y ( 1 , 6 ) = 0 ; 
-   dq_dR_y ( 1 , 7 ) = 0 ; 
-   dq_dR_y ( 1 , 8 ) = _aux6 ; 
-   dq_dR_y ( 2 , 0 ) = _aux8 ; 
-   dq_dR_y ( 2 , 1 ) = 0 ; 
-   dq_dR_y ( 2 , 2 ) = 0 ; 
-   dq_dR_y ( 2 , 3 ) = 0 ; 
-   dq_dR_y ( 2 , 4 ) = -0.03125*_aux1*_aux7 ; 
-   dq_dR_y ( 2 , 5 ) = _aux5 ; 
-   dq_dR_y ( 2 , 6 ) = 0 ; 
-   dq_dR_y ( 2 , 7 ) = _aux5 ; 
-   dq_dR_y ( 2 , 8 ) = _aux8 ; 
-} 
-void  compute_dq_dR_z ( Eigen::Matrix<number_t, 3 , 9 >&  dq_dR_z , const number_t&  qz , const number_t&  r00 , const number_t&  r10 , const number_t&  r20 , const number_t&  r01 , const number_t&  r11 , const number_t&  r21 , const number_t&  r02 , const number_t&  r12 , const number_t&  r22 ) { 
-  (void) r00;
-  (void) r10;
-  (void) r01;
-  (void) r11;
-  (void) r22;
-  number_t  _aux1 = 1/pow(qz,3) ; 
-  number_t  _aux2 = r20+r02 ; 
-  number_t  _aux3 = 0.03125*_aux1*_aux2 ; 
-  number_t  _aux4 = 1/qz ; 
-  number_t  _aux5 = 0.25*_aux4 ; 
-  number_t  _aux6 = r21+r12 ; 
-  number_t  _aux7 = 0.03125*_aux1*_aux6 ; 
-  number_t  _aux8 = -0.125*_aux4 ; 
-   dq_dR_z ( 0 , 0 ) = _aux3 ; 
-   dq_dR_z ( 0 , 1 ) = 0 ; 
-   dq_dR_z ( 0 , 2 ) = _aux5 ; 
-   dq_dR_z ( 0 , 3 ) = 0 ; 
-   dq_dR_z ( 0 , 4 ) = _aux3 ; 
-   dq_dR_z ( 0 , 5 ) = 0 ; 
-   dq_dR_z ( 0 , 6 ) = _aux5 ; 
-   dq_dR_z ( 0 , 7 ) = 0 ; 
-   dq_dR_z ( 0 , 8 ) = -0.03125*_aux1*_aux2 ; 
-   dq_dR_z ( 1 , 0 ) = _aux7 ; 
-   dq_dR_z ( 1 , 1 ) = 0 ; 
-   dq_dR_z ( 1 , 2 ) = 0 ; 
-   dq_dR_z ( 1 , 3 ) = 0 ; 
-   dq_dR_z ( 1 , 4 ) = _aux7 ; 
-   dq_dR_z ( 1 , 5 ) = _aux5 ; 
-   dq_dR_z ( 1 , 6 ) = 0 ; 
-   dq_dR_z ( 1 , 7 ) = _aux5 ; 
-   dq_dR_z ( 1 , 8 ) = -0.03125*_aux1*_aux6 ; 
-   dq_dR_z ( 2 , 0 ) = _aux8 ; 
-   dq_dR_z ( 2 , 1 ) = 0 ; 
-   dq_dR_z ( 2 , 2 ) = 0 ; 
-   dq_dR_z ( 2 , 3 ) = 0 ; 
-   dq_dR_z ( 2 , 4 ) = _aux8 ; 
-   dq_dR_z ( 2 , 5 ) = 0 ; 
-   dq_dR_z ( 2 , 6 ) = 0 ; 
-   dq_dR_z ( 2 , 7 ) = 0 ; 
-   dq_dR_z ( 2 , 8 ) = 0.125*_aux4 ; 
-} 
-void  compute_dR_dq ( Eigen::Matrix<number_t, 9 , 3 >&  dR_dq , const number_t&  qx , const number_t&  qy , const number_t&  qz , const number_t&  qw ) { 
-  number_t  _aux1 = -4*qy ; 
-  number_t  _aux2 = -4*qz ; 
-  number_t  _aux3 = 1/qw ; 
-  number_t  _aux4 = 2*qx*qz ; 
-  number_t  _aux5 = -_aux3*(_aux4-2*qw*qy) ; 
-  number_t  _aux6 = 2*qy*qz ; 
-  number_t  _aux7 = -_aux3*(_aux6-2*qw*qx) ; 
-  number_t  _aux8 = -2*pow(qw,2) ; 
-  number_t  _aux9 = _aux8+2*pow(qz,2) ; 
-  number_t  _aux10 = 2*qw*qz ; 
-  number_t  _aux11 = (_aux10+2*qx*qy)*_aux3 ; 
-  number_t  _aux12 = _aux8+2*pow(qy,2) ; 
-  number_t  _aux13 = _aux3*(_aux6+2*qw*qx) ; 
-  number_t  _aux14 = _aux3*(_aux4+2*qw*qy) ; 
-  number_t  _aux15 = -4*qx ; 
-  number_t  _aux16 = _aux8+2*pow(qx,2) ; 
-  number_t  _aux17 = (_aux10-2*qx*qy)*_aux3 ; 
-   dR_dq ( 0 , 0 ) = 0 ; 
-   dR_dq ( 0 , 1 ) = _aux1 ; 
-   dR_dq ( 0 , 2 ) = _aux2 ; 
-   dR_dq ( 1 , 0 ) = _aux5 ; 
-   dR_dq ( 1 , 1 ) = _aux7 ; 
-   dR_dq ( 1 , 2 ) = -_aux3*_aux9 ; 
-   dR_dq ( 2 , 0 ) = _aux11 ; 
-   dR_dq ( 2 , 1 ) = _aux12*_aux3 ; 
-   dR_dq ( 2 , 2 ) = _aux13 ; 
-   dR_dq ( 3 , 0 ) = _aux14 ; 
-   dR_dq ( 3 , 1 ) = _aux13 ; 
-   dR_dq ( 3 , 2 ) = _aux3*_aux9 ; 
-   dR_dq ( 4 , 0 ) = _aux15 ; 
-   dR_dq ( 4 , 1 ) = 0 ; 
-   dR_dq ( 4 , 2 ) = _aux2 ; 
-   dR_dq ( 5 , 0 ) = -_aux16*_aux3 ; 
-   dR_dq ( 5 , 1 ) = _aux17 ; 
-   dR_dq ( 5 , 2 ) = _aux5 ; 
-   dR_dq ( 6 , 0 ) = _aux17 ; 
-   dR_dq ( 6 , 1 ) = -_aux12*_aux3 ; 
-   dR_dq ( 6 , 2 ) = _aux7 ; 
-   dR_dq ( 7 , 0 ) = _aux16*_aux3 ; 
-   dR_dq ( 7 , 1 ) = _aux11 ; 
-   dR_dq ( 7 , 2 ) = _aux14 ; 
-   dR_dq ( 8 , 0 ) = _aux15 ; 
-   dR_dq ( 8 , 1 ) = _aux1 ; 
-   dR_dq ( 8 , 2 ) = 0 ; 
-} 
diff --git a/g2o/types/slam3d/edge_pointxyz.cpp b/g2o/types/slam3d/edge_pointxyz.cpp
deleted file mode 100644
index eb33659e..00000000
--- a/g2o/types/slam3d/edge_pointxyz.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_pointxyz.h"
-
-namespace g2o {
-
-  EdgePointXYZ::EdgePointXYZ() :
-    BaseBinaryEdge<3, Vector3, VertexPointXYZ, VertexPointXYZ>()
-  {
-    _information.setIdentity();
-    _error.setZero();
-  }
-
-  bool EdgePointXYZ::read(std::istream& is)
-  {
-    Vector3 p;
-    is >> p[0] >> p[1] >> p[2];
-    setMeasurement(p);
-    for (int i = 0; i < 3; ++i)
-      for (int j = i; j < 3; ++j) {
-        is >> information()(i, j);
-        if (i != j)
-          information()(j, i) = information()(i, j);
-      }
-    return true;
-  }
-
-  bool EdgePointXYZ::write(std::ostream& os) const
-  {
-    Vector3 p = measurement();
-    os << p.x() << " " << p.y() << " " << p.z();
-    for (int i = 0; i < 3; ++i)
-      for (int j = i; j < 3; ++j)
-        os << " " << information()(i, j);
-    return os.good();
-  }
-
-
-#ifndef NUMERIC_JACOBIAN_THREE_D_TYPES
-  void EdgePointXYZ::linearizeOplus()
-  {
-    _jacobianOplusXi=-Matrix3::Identity();
-    _jacobianOplusXj= Matrix3::Identity();
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam3d/edge_pointxyz.h b/g2o/types/slam3d/edge_pointxyz.h
deleted file mode 100644
index 79d94c43..00000000
--- a/g2o/types/slam3d/edge_pointxyz.h
+++ /dev/null
@@ -1,86 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_POINTXYZ_H
-#define G2O_EDGE_POINTXYZ_H
-
-#include "vertex_pointxyz.h"
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM3D_API EdgePointXYZ : public BaseBinaryEdge<3, Vector3, VertexPointXYZ, VertexPointXYZ>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-        EdgePointXYZ();
-
-      void computeError()
-      {
-        const VertexPointXYZ* v1 = static_cast<const VertexPointXYZ*>(_vertices[0]);
-        const VertexPointXYZ* v2 = static_cast<const VertexPointXYZ*>(_vertices[1]);
-        _error = (v2->estimate()-v1->estimate())-_measurement;
-      }
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void setMeasurement(const Vector3& m){
-        _measurement = m;
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        _measurement=Vector3(d[0], d[1], d[2]);
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-	Eigen::Map<Vector3> m(d);
-	m=_measurement;
-        return true;
-      }
-
-      virtual int measurementDimension() const {return 3;}
-
-      virtual bool setMeasurementFromState() {
-        const VertexPointXYZ* v1 = static_cast<const VertexPointXYZ*>(_vertices[0]);
-        const VertexPointXYZ* v2 = static_cast<const VertexPointXYZ*>(_vertices[1]);
-        _measurement = v2->estimate()-v1->estimate();
-        return true;
-      }
-
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 0;}
-#ifndef NUMERIC_JACOBIAN_THREE_D_TYPES
-      virtual void linearizeOplus();
-#endif
-  };
-
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d/edge_se3.cpp b/g2o/types/slam3d/edge_se3.cpp
deleted file mode 100644
index 03813c30..00000000
--- a/g2o/types/slam3d/edge_se3.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3.h"
-#include "isometry3d_gradients.h"
-#include <iostream>
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-  using namespace std;
-
-  EdgeSE3::EdgeSE3() : BaseBinaryEdge<6, Isometry3, VertexSE3, VertexSE3>() {
-    information().setIdentity();
-  }
-
-  bool EdgeSE3::read(std::istream& is) {
-    Vector7 meas;
-    internal::readVector(is, meas);
-    // normalize the quaternion to recover numerical precision lost by storing as human readable text
-    Vector4::MapType(meas.data() + 3).normalize();
-    setMeasurement(internal::fromVectorQT(meas));
-    if (is.bad()) return false;
-    readInformationMatrix(is);
-    return is.good() || is.eof();
-  }
-
-  bool EdgeSE3::write(std::ostream& os) const {
-    internal::writeVector(os, internal::toVectorQT(measurement()));
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE3::computeError() {
-    VertexSE3 *from = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3 *to   = static_cast<VertexSE3*>(_vertices[1]);
-    Isometry3 delta=_inverseMeasurement * from->estimate().inverse() * to->estimate();
-    _error=internal::toVectorMQT(delta);
-  }
-
-  bool EdgeSE3::setMeasurementFromState(){
-    VertexSE3 *from = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3 *to   = static_cast<VertexSE3*>(_vertices[1]);
-    Isometry3 delta = from->estimate().inverse() * to->estimate();
-    setMeasurement(delta);
-    return true;
-  }
-
-  void EdgeSE3::linearizeOplus(){
-    // BaseBinaryEdge<6, Isometry3, VertexSE3, VertexSE3>::linearizeOplus();
-    // return;
-
-    VertexSE3 *from = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3 *to   = static_cast<VertexSE3*>(_vertices[1]);
-    Isometry3 E;
-    const Isometry3& Xi=from->estimate();
-    const Isometry3& Xj=to->estimate();
-    const Isometry3& Z=_measurement;
-    internal::computeEdgeSE3Gradient(E, _jacobianOplusXi , _jacobianOplusXj, Z, Xi, Xj);
-  }
-
-  void EdgeSE3::initialEstimate(const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* /*to_*/) {
-    VertexSE3 *from = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3 *to   = static_cast<VertexSE3*>(_vertices[1]);
-
-    if (from_.count(from) > 0) {
-      to->setEstimate(from->estimate() * _measurement);
-    } else
-      from->setEstimate(to->estimate() * _measurement.inverse());
-    //cerr << "IE" << endl;
-  }
-
-  EdgeSE3WriteGnuplotAction::EdgeSE3WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSE3).name()){}
-
-  HyperGraphElementAction* EdgeSE3WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    EdgeSE3* e =  static_cast<EdgeSE3*>(element);
-    VertexSE3* fromEdge = static_cast<VertexSE3*>(e->vertices()[0]);
-    VertexSE3* toEdge   = static_cast<VertexSE3*>(e->vertices()[1]);
-    Vector6 fromV, toV;
-    fromV=internal::toVectorMQT(fromEdge->estimate());
-    toV=internal::toVectorMQT(toEdge->estimate());
-    for (int i=0; i<6; i++){
-      *(params->os) << fromV[i] << " ";
-    }
-    for (int i=0; i<6; i++){
-      *(params->os) << toV[i] << " ";
-    }
-    *(params->os) << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE3DrawAction::EdgeSE3DrawAction(): DrawAction(typeid(EdgeSE3).name()){}
-
-  HyperGraphElementAction* EdgeSE3DrawAction::operator()(HyperGraph::HyperGraphElement* element,
-               HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    EdgeSE3* e =  static_cast<EdgeSE3*>(element);
-    VertexSE3* fromEdge = static_cast<VertexSE3*>(e->vertices()[0]);
-    VertexSE3* toEdge   = static_cast<VertexSE3*>(e->vertices()[1]);
-    if (! fromEdge || ! toEdge)
-      return this;
-    glColor3f(POSE_EDGE_COLOR);
-    glPushAttrib(GL_ENABLE_BIT);
-    glDisable(GL_LIGHTING);
-    glBegin(GL_LINES);
-    glVertex3f((float)fromEdge->estimate().translation().x(),(float)fromEdge->estimate().translation().y(),(float)fromEdge->estimate().translation().z());
-    glVertex3f((float)toEdge->estimate().translation().x(),(float)toEdge->estimate().translation().y(),(float)toEdge->estimate().translation().z());
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d/edge_se3.h b/g2o/types/slam3d/edge_se3.h
deleted file mode 100644
index 6d121b41..00000000
--- a/g2o/types/slam3d/edge_se3.h
+++ /dev/null
@@ -1,110 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_H_
-#define G2O_EDGE_SE3_H_
-
-#include "g2o/core/base_binary_edge.h"
-
-#include "g2o_types_slam3d_api.h"
-#include "vertex_se3.h"
-
-namespace g2o {
-
-  /**
-   * \brief Edge between two 3D pose vertices
-   *
-   * The transformation between the two vertices is given as an Isometry3.
-   * If z denotes the measurement, then the error function is given as follows:
-   * z^-1 * (x_i^-1 * x_j)
-   */
-  class G2O_TYPES_SLAM3D_API EdgeSE3 : public BaseBinaryEdge<6, Isometry3, VertexSE3, VertexSE3> {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE3();
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      void computeError();
-
-      virtual void setMeasurement(const Isometry3& m){
-        _measurement = m;
-        _inverseMeasurement = m.inverse();
-      }
-
-      virtual bool setMeasurementData(const number_t* d){
-        Eigen::Map<const Vector7> v(d);
-        setMeasurement(internal::fromVectorQT(v));
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const{
-        Eigen::Map<Vector7> v(d);
-        v = internal::toVectorQT(_measurement);
-        return true;
-      }
-
-      void linearizeOplus();
-
-      virtual int measurementDimension() const {return 7;}
-
-      virtual bool setMeasurementFromState() ;
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& /*from*/, 
-          OptimizableGraph::Vertex* /*to*/) { 
-        return 1.;
-      }
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    protected:
-      Isometry3 _inverseMeasurement;
-  };
-
-  /**
-   * \brief Output the pose-pose constraint to Gnuplot data file
-   */
-  class G2O_TYPES_SLAM3D_API EdgeSE3WriteGnuplotAction: public WriteGnuplotAction {
-  public:
-    EdgeSE3WriteGnuplotAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  /**
-   * \brief Visualize a 3D pose-pose constraint
-   */
-  class G2O_TYPES_SLAM3D_API EdgeSE3DrawAction: public DrawAction{
-  public:
-    EdgeSE3DrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-            HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-} // end namespace
-#endif
diff --git a/g2o/types/slam3d/edge_se3_lotsofxyz.cpp b/g2o/types/slam3d/edge_se3_lotsofxyz.cpp
deleted file mode 100644
index 8f4243ef..00000000
--- a/g2o/types/slam3d/edge_se3_lotsofxyz.cpp
+++ /dev/null
@@ -1,199 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_lotsofxyz.h"
-
-namespace g2o {
-
-EdgeSE3LotsOfXYZ::EdgeSE3LotsOfXYZ() : BaseMultiEdge<-1, VectorX>(), _observedPoints(0) { resize(0); }
-
-bool EdgeSE3LotsOfXYZ::setMeasurementFromState() {
-  VertexSE3 *pose = static_cast<VertexSE3 *>(_vertices[0]);
-
-  Eigen::Transform<number_t, 3, 1> poseinv = pose->estimate().inverse();
-
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    VertexPointXYZ *xyz = static_cast<VertexPointXYZ *>(_vertices[1 + i]);
-    //      const Vector3 &pt = xyz->estimate();
-    Vector3 m = poseinv * xyz->estimate();
-
-    unsigned int index = 3 * i;
-    _measurement[index] = m[0];
-    _measurement[index + 1] = m[1];
-    _measurement[index + 2] = m[2];
-  }
-  return true;
-}
-
-void EdgeSE3LotsOfXYZ::computeError() {
-  VertexSE3 *pose = static_cast<VertexSE3 *>(_vertices[0]);
-
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    VertexPointXYZ *xyz = static_cast<VertexPointXYZ *>(_vertices[1 + i]);
-    Vector3 m = pose->estimate().inverse() * xyz->estimate();
-
-    unsigned int index = 3 * i;
-    _error[index] = m[0] - _measurement[index];
-    _error[index + 1] = m[1] - _measurement[index + 1];
-    _error[index + 2] = m[2] - _measurement[index + 2];
-  }
-}
-
-void EdgeSE3LotsOfXYZ::linearizeOplus() {
-  g2o::VertexSE3 *pose = (g2o::VertexSE3 *)(_vertices[0]);
-
-  // initialize Ji matrix
-  MatrixX Ji;
-  unsigned int rows = 3 * (_vertices.size() - 1);
-  Ji.resize(rows, 6);
-  Ji.fill(0);
-
-  Matrix3 poseRot = pose->estimate().inverse().rotation();
-
-  for (unsigned int i = 1; i < _vertices.size(); i++) {
-    g2o::VertexPointXYZ *point = (g2o::VertexPointXYZ *)(_vertices[i]);
-    Vector3 Zcam = pose->estimate().inverse() * point->estimate();
-
-    unsigned int index = 3 * (i - 1);
-
-    // Ji.block<3,3>(index,0) = -poseRot;
-    Ji.block<3, 3>(index, 0) = -Matrix3::Identity();
-
-    Ji(index, 3) = -0.0;
-    Ji(index, 4) = -2 * Zcam(2);
-    Ji(index, 5) = 2 * Zcam(1);
-
-    Ji(index + 1, 3) = 2 * Zcam(2);
-    Ji(index + 1, 4) = -0.0;
-    Ji(index + 1, 5) = -2 * Zcam(0);
-
-    Ji(index + 2, 3) = -2 * Zcam(1);
-    Ji(index + 2, 4) = 2 * Zcam(0);
-    Ji(index + 2, 5) = -0.0;
-
-    MatrixX Jj;
-    Jj.resize(rows, 3);
-    Jj.fill(0);
-    Jj.block<3, 3>(index, 0) = poseRot;
-
-    _jacobianOplus[i] = Jj;
-  }
-
-  _jacobianOplus[0] = Ji;
-}
-
-bool EdgeSE3LotsOfXYZ::read(std::istream &is) {
-  is >> _observedPoints;
-
-  setSize(_observedPoints + 1);
-
-  // read the measurements
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    unsigned int index = 3 * i;
-    is >> _measurement[index] >> _measurement[index + 1] >> _measurement[index + 2];
-  }
-
-  // read the information matrix
-  for (unsigned int i = 0; i < _observedPoints * 3; i++) {
-    // fill the "upper triangle" part of the matrix
-    for (unsigned int j = i; j < _observedPoints * 3; j++) {
-      is >> information()(i, j);
-    }
-
-    // fill the lower triangle part
-    for (unsigned int j = 0; j < i; j++) {
-      information()(i, j) = information()(j, i);
-    }
-  }
-  return true;
-}
-
-bool EdgeSE3LotsOfXYZ::write(std::ostream &os) const {
-  // write number of observed points
-  os << "|| " << _observedPoints;
-
-  // write measurements
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    unsigned int index = 3 * i;
-    os << " " << _measurement[index] << " " << _measurement[index + 1] << " " << _measurement[index + 2];
-  }
-
-  // write information matrix
-  for (unsigned int i = 0; i < _observedPoints * 3; i++) {
-    for (unsigned int j = i; j < _observedPoints * 3; j++) {
-      os << " " << information()(i, j);
-    }
-  }
-  return os.good();
-}
-
-void EdgeSE3LotsOfXYZ::initialEstimate(const OptimizableGraph::VertexSet &fixed, OptimizableGraph::Vertex *toEstimate) {
-  (void)toEstimate;
-
-  assert(initialEstimatePossible(fixed, toEstimate) && "Bad vertices specified");
-
-  VertexSE3 *pose = static_cast<VertexSE3 *>(_vertices[0]);
-
-#ifdef _MSC_VER
-  std::vector<bool> estimate_this(_observedPoints, true);
-#else
-  bool estimate_this[_observedPoints];
-  for (unsigned int i = 0; i < _observedPoints; i++) {
-    estimate_this[i] = true;
-  }
-#endif
-
-  for (std::set<HyperGraph::Vertex *>::iterator it = fixed.begin(); it != fixed.end(); ++it) {
-    for (unsigned int i = 1; i < _vertices.size(); i++) {
-      VertexPointXYZ *vert = static_cast<VertexPointXYZ *>(_vertices[i]);
-      if (vert->id() == (*it)->id()) estimate_this[i - 1] = false;
-    }
-  }
-
-  for (unsigned int i = 1; i < _vertices.size(); i++) {
-    if (estimate_this[i - 1]) {
-      unsigned int index = 3 * (i - 1);
-      Vector3 submeas(_measurement[index], _measurement[index + 1], _measurement[index + 2]);
-      VertexPointXYZ *vert = static_cast<VertexPointXYZ *>(_vertices[i]);
-      vert->setEstimate(pose->estimate() * submeas);
-    }
-  }
-}
-
-number_t EdgeSE3LotsOfXYZ::initialEstimatePossible(const OptimizableGraph::VertexSet &fixed,
-                                                   OptimizableGraph::Vertex *toEstimate) {
-  (void)toEstimate;
-
-  for (std::set<HyperGraph::Vertex *>::iterator it = fixed.begin(); it != fixed.end(); ++it) {
-    if (_vertices[0]->id() == (*it)->id()) {
-      return 1.0;
-    }
-  }
-
-  return -1.0;
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d/edge_se3_lotsofxyz.h b/g2o/types/slam3d/edge_se3_lotsofxyz.h
deleted file mode 100644
index 9269175c..00000000
--- a/g2o/types/slam3d/edge_se3_lotsofxyz.h
+++ /dev/null
@@ -1,72 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SE3_LOTSOF_XYZ
-#define G2O_SE3_LOTSOF_XYZ
-
-#include "g2o/config.h"
-#include "g2o_types_slam3d_api.h"
-#include "g2o/core/base_multi_edge.h"
-#include "vertex_se3.h"
-#include "vertex_pointxyz.h"
-
-namespace g2o{
-
-  class G2O_TYPES_SLAM3D_API EdgeSE3LotsOfXYZ : public BaseMultiEdge<-1, VectorX>{
-
-    protected:
-      unsigned int _observedPoints;
-
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE3LotsOfXYZ();
-
-      void setSize(int vertices){
-        resize(vertices);
-        _observedPoints = vertices-1;
-        _measurement.resize(_observedPoints*3, 1);
-        setDimension(_observedPoints*3);
-      }
-
-      virtual void computeError();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual bool setMeasurementFromState();
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*);
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet&, OptimizableGraph::Vertex*);
-
-      virtual void linearizeOplus();
-
-  };
-
-}
-
-
-
-#endif // G2O_SE3_LOTSOF_XYZ
diff --git a/g2o/types/slam3d/edge_se3_offset.cpp b/g2o/types/slam3d/edge_se3_offset.cpp
deleted file mode 100644
index 0a0d0771..00000000
--- a/g2o/types/slam3d/edge_se3_offset.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_offset.h"
-#include "isometry3d_gradients.h"
-#include "parameter_se3_offset.h"
-
-#include <iostream>
-
-namespace g2o {
-  using namespace std;
-  using namespace Eigen;
-
-  EdgeSE3Offset::EdgeSE3Offset() : EdgeSE3() {
-    information().setIdentity();
-    _offsetFrom = 0;
-    _offsetTo = 0;
-    _cacheFrom = 0;
-    _cacheTo = 0;
-    resizeParameters(2);
-    installParameter(_offsetFrom, 0);
-    installParameter(_offsetTo, 1);
-  }
-
-  bool EdgeSE3Offset::resolveCaches(){
-    assert(_offsetFrom && _offsetTo);
-
-    ParameterVector pv(2);
-    pv[0]=_offsetFrom;
-    resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],"CACHE_SE3_OFFSET",pv);
-    pv[0]=_offsetTo;
-    resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],"CACHE_SE3_OFFSET",pv);
-    return (_cacheFrom && _cacheTo);
-  }
-
-  bool EdgeSE3Offset::read(std::istream& is) {
-    bool state = readParamIds(is);
-
-    Vector7 meas;
-    state &= internal::readVector(is, meas);
-    // normalize the quaternion to recover numerical precision lost by storing as human readable text
-    Vector4::MapType(meas.data() + 3).normalize();
-    setMeasurement(internal::fromVectorQT(meas));
-
-    state &= readInformationMatrix(is);
-    return state;
-  }
-
-  bool EdgeSE3Offset::write(std::ostream& os) const {
-    writeParamIds(os);
-    internal::writeVector(os, internal::toVectorQT(_measurement));
-    writeInformationMatrix(os);
-    return os.good();
-  }
-
-  void EdgeSE3Offset::computeError() {
-    Isometry3 delta=_inverseMeasurement * _cacheFrom->w2n() * _cacheTo->n2w();
-    _error=internal::toVectorMQT(delta);
-  }
-
-  bool EdgeSE3Offset::setMeasurementFromState(){
-    Isometry3 delta = _cacheFrom->w2n() * _cacheTo->n2w();
-    setMeasurement(delta);
-    return true;
-  }
-
-  void EdgeSE3Offset::linearizeOplus() {
-    // BaseBinaryEdge<6, SE3Quat, VertexSE3, VertexSE3>::linearizeOplus();
-
-    VertexSE3* from = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3* to = static_cast<VertexSE3*>(_vertices[1]);
-    Isometry3 E;
-    const Isometry3& Xi = from->estimate();
-    const Isometry3& Xj = to->estimate();
-    const Isometry3& Pi = _cacheFrom->offsetParam()->offset();
-    const Isometry3& Pj = _cacheTo->offsetParam()->offset();
-    const Isometry3& Z = _measurement;
-    internal::computeEdgeSE3Gradient(E, _jacobianOplusXi, _jacobianOplusXj, Z, Xi, Xj, Pi, Pj);
-  }
-
-  void EdgeSE3Offset::initialEstimate(const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* /*to_*/) {
-    VertexSE3 *from = static_cast<VertexSE3*>(_vertices[0]);
-    VertexSE3 *to   = static_cast<VertexSE3*>(_vertices[1]);
-
-    Isometry3 virtualMeasurement = _cacheFrom->offsetParam()->offset() * measurement() * _cacheTo->offsetParam()->offset().inverse();
-
-    if (from_.count(from) > 0) {
-      to->setEstimate(from->estimate() * virtualMeasurement);
-    } else
-      from->setEstimate(to->estimate() * virtualMeasurement.inverse());
-  }
-
-}
diff --git a/g2o/types/slam3d/edge_se3_offset.h b/g2o/types/slam3d/edge_se3_offset.h
deleted file mode 100644
index 205ed0f6..00000000
--- a/g2o/types/slam3d/edge_se3_offset.h
+++ /dev/null
@@ -1,70 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_OFFSET_H_
-#define G2O_EDGE_SE3_OFFSET_H_
-
-
-#include "edge_se3.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-  class ParameterSE3Offset;
-  class CacheSE3Offset;
-
-  /**
-   * \brief Offset edge
-   */
-  // first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_SLAM3D_API EdgeSE3Offset : public EdgeSE3 {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE3Offset();
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      void computeError();
-
-
-      void linearizeOplus();
-
-      virtual bool setMeasurementFromState() ;
-
-      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& /*from*/, 
-          OptimizableGraph::Vertex* /*to*/) { 
-        return 1.;
-      }
-
-      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    protected:
-      virtual bool resolveCaches();
-      ParameterSE3Offset *_offsetFrom, *_offsetTo;
-      CacheSE3Offset  *_cacheFrom, *_cacheTo;
-  };
-
-} // end namespace
-#endif
diff --git a/g2o/types/slam3d/edge_se3_pointxyz.cpp b/g2o/types/slam3d/edge_se3_pointxyz.cpp
deleted file mode 100644
index 05efa6c4..00000000
--- a/g2o/types/slam3d/edge_se3_pointxyz.cpp
+++ /dev/null
@@ -1,187 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_pointxyz.h"
-#include "parameter_se3_offset.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-#include <iostream>
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-  using namespace std;
-
-  // point to camera projection, monocular
-  EdgeSE3PointXYZ::EdgeSE3PointXYZ() : BaseBinaryEdge<3, Vector3, VertexSE3, VertexPointXYZ>() {
-    information().setIdentity();
-    J.fill(0);
-    J.block<3,3>(0,0) = -Matrix3::Identity();
-    cache = 0;
-    offsetParam = 0;
-    resizeParameters(1);
-    installParameter(offsetParam, 0);
-  }
-
-  bool EdgeSE3PointXYZ::resolveCaches(){
-    ParameterVector pv(1);
-    pv[0]=offsetParam;
-    resolveCache(cache, (OptimizableGraph::Vertex*)_vertices[0],"CACHE_SE3_OFFSET",pv);
-    return cache != 0;
-  }
-
-  bool EdgeSE3PointXYZ::read(std::istream& is) {
-    readParamIds(is);
-    Vector3 meas;
-    internal::readVector(is, meas);
-    setMeasurement(meas);
-    readInformationMatrix(is);
-    return is.good() || is.eof();
-  }
-
-  bool EdgeSE3PointXYZ::write(std::ostream& os) const {
-    bool state = writeParamIds(os);
-    state &= internal::writeVector(os, measurement());
-    state &= writeInformationMatrix(os);
-    return state;
-  }
-
-  void EdgeSE3PointXYZ::computeError() {
-    // from cam to point (track)
-    //VertexSE3 *cam = static_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = static_cast<VertexPointXYZ*>(_vertices[1]);
-
-    Vector3 perr = cache->w2n() * point->estimate();
-
-    // error, which is backwards from the normal observed - calculated
-    // _measurement is the measured projection
-    _error = perr - _measurement;
-    //    std::cout << _error << std::endl << std::endl;
-  }
-
-  void EdgeSE3PointXYZ::linearizeOplus() {
-    //VertexSE3 *cam = static_cast<VertexSE3 *>(_vertices[0]);
-    VertexPointXYZ *vp = static_cast<VertexPointXYZ *>(_vertices[1]);
-
-    Vector3 Zcam = cache->w2l() * vp->estimate();
-
-    //  J(0,3) = -0.0;
-    J(0,4) = -2*Zcam(2);
-    J(0,5) = 2*Zcam(1);
-
-    J(1,3) = 2*Zcam(2);
-    //  J(1,4) = -0.0;
-    J(1,5) = -2*Zcam(0);
-
-    J(2,3) = -2*Zcam(1);
-    J(2,4) = 2*Zcam(0);
-    //  J(2,5) = -0.0;
-
-    J.block<3,3>(0,6) = cache->w2l().rotation();
-
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> Jhom = offsetParam->inverseOffset().rotation() * J;
-
-    _jacobianOplusXi = Jhom.block<3,6>(0,0);
-    _jacobianOplusXj = Jhom.block<3,3>(0,6);
-
-    // std::cerr << "just linearized." << std::endl;
-    // std::cerr << "_jacobianOplusXi:" << std::endl << _jacobianOplusXi << std::endl;
-    // std::cerr << "_jacobianOplusXj:" << std::endl << _jacobianOplusXj << std::endl;
-  }
-
-
-  bool EdgeSE3PointXYZ::setMeasurementFromState(){
-    //VertexSE3 *cam = static_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = static_cast<VertexPointXYZ*>(_vertices[1]);
-
-    // calculate the projection
-    const Vector3 &pt = point->estimate();
-    // SE3OffsetCache* vcache = (SE3OffsetCache*) cam->getCache(_cacheIds[0]);
-    // if (! vcache){
-    //   cerr << "fatal error in retrieving cache" << endl;
-    // }
-
-    Vector3 perr = cache->w2n() * pt;
-    _measurement = perr;
-    return true;
-  }
-
-
-  void EdgeSE3PointXYZ::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to)
-  {
-    (void) from; (void) to;
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexDepthCam position by VertexTrackXYZ");
-
-    VertexSE3 *cam = dynamic_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = dynamic_cast<VertexPointXYZ*>(_vertices[1]);
-    // SE3OffsetCache* vcache = (SE3OffsetCache* ) cam->getCache(_cacheIds[0]);
-    // if (! vcache){
-    //   cerr << "fatal error in retrieving cache" << endl;
-    // }
-    // SE3OffsetParameters* params=vcache->params;
-    Vector3 p=_measurement;
-    point->setEstimate(cam->estimate() * (offsetParam->offset() * p));
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE3PointXYZDrawAction::EdgeSE3PointXYZDrawAction(): DrawAction(typeid(EdgeSE3PointXYZ).name()){}
-
-  HyperGraphElementAction* EdgeSE3PointXYZDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-               HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    EdgeSE3PointXYZ* e =  static_cast<EdgeSE3PointXYZ*>(element);
-    VertexSE3* fromEdge = static_cast<VertexSE3*>(e->vertex(0));
-    VertexPointXYZ* toEdge   = static_cast<VertexPointXYZ*>(e->vertex(1));
-    if (! fromEdge || ! toEdge)
-      return this;
-    Isometry3 fromTransform=fromEdge->estimate() * e->offsetParameter()->offset();
-    glColor3f(LANDMARK_EDGE_COLOR);
-    glPushAttrib(GL_ENABLE_BIT);
-    glDisable(GL_LIGHTING);
-    glBegin(GL_LINES);
-    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),(float)fromTransform.translation().z());
-    glVertex3f((float)toEdge->estimate().x(),(float)toEdge->estimate().y(),(float)toEdge->estimate().z());
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam3d/edge_se3_pointxyz.h b/g2o/types/slam3d/edge_se3_pointxyz.h
deleted file mode 100644
index ce72ea49..00000000
--- a/g2o/types/slam3d/edge_se3_pointxyz.h
+++ /dev/null
@@ -1,102 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_POINT_XYZ_H_
-#define G2O_EDGE_SE3_POINT_XYZ_H_
-
-#include "g2o/core/base_binary_edge.h"
-
-#include "vertex_se3.h"
-#include "vertex_pointxyz.h"
-#include "parameter_se3_offset.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-
-  /*! \class EdgeSE3PointXYZ
-   * \brief g2o edge from a track to a point node
-   */
-  // first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_SLAM3D_API EdgeSE3PointXYZ : public BaseBinaryEdge<3, Vector3, VertexSE3, VertexPointXYZ> {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSE3PointXYZ();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 3-vector
-    void computeError();
-    // jacobian
-    virtual void linearizeOplus();
-
-
-    virtual void setMeasurement(const Vector3& m){
-      _measurement = m;
-    }
-
-    virtual bool setMeasurementData(const number_t* d){
-      Eigen::Map<const Vector3> v(d);
-      _measurement = v;
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const{
-      Eigen::Map<Vector3> v(d);
-      v=_measurement;
-      return true;
-    }
-
-    virtual int measurementDimension() const {return 3;}
-
-    virtual bool setMeasurementFromState() ;
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from,
-             OptimizableGraph::Vertex* to) {
-      (void) to;
-      return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
-    }
-
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    const ParameterSE3Offset* offsetParameter() { return offsetParam; }
-  private:
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> J; // jacobian before projection
-    ParameterSE3Offset* offsetParam;
-    CacheSE3Offset* cache;
-    virtual bool resolveCaches();
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class EdgeSE3PointXYZDrawAction: public DrawAction{
-  public:
-    EdgeSE3PointXYZDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-}
-#endif
diff --git a/g2o/types/slam3d/edge_se3_pointxyz_depth.cpp b/g2o/types/slam3d/edge_se3_pointxyz_depth.cpp
deleted file mode 100644
index afd22f46..00000000
--- a/g2o/types/slam3d/edge_se3_pointxyz_depth.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_pointxyz_depth.h"
-
-namespace g2o {
-
-  // point to camera projection, monocular
-  EdgeSE3PointXYZDepth::EdgeSE3PointXYZDepth()
-      : BaseBinaryEdge<3, Vector3, VertexSE3, VertexPointXYZ>(), cache(nullptr) {
-    resizeParameters(1);
-    installParameter(params, 0);
-    information().setIdentity();
-    information()(2,2)=100;
-    J.fill(0);
-    J.block<3,3>(0,0) = -Matrix3::Identity();
-  }
-
-  bool EdgeSE3PointXYZDepth::resolveCaches(){
-    ParameterVector pv(1);
-    pv[0]=params;
-    resolveCache(cache, (OptimizableGraph::Vertex*)_vertices[0],"CACHE_CAMERA",pv);
-    return cache != 0;
-  }
-
-  bool EdgeSE3PointXYZDepth::read(std::istream& is) {
-    readParamIds(is);
-    internal::readVector(is, _measurement); // measured keypoint
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSE3PointXYZDepth::write(std::ostream& os) const {
-    writeParamIds(os);
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE3PointXYZDepth::computeError() {
-    // from cam to point (track)
-    //VertexSE3 *cam = static_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = static_cast<VertexPointXYZ*>(_vertices[1]);
-
-    Vector3 p = cache->w2i() * point->estimate();
-    Vector3 perr;
-    perr.head<2>() = p.head<2>()/p(2);
-    perr(2) = p(2);
-
-    // error, which is backwards from the normal observed - calculated
-    // _measurement is the measured projection
-    _error = perr - _measurement;
-  }
-
-  void EdgeSE3PointXYZDepth::linearizeOplus() {
-    //VertexSE3 *cam = static_cast<VertexSE3 *>(_vertices[0]);
-    VertexPointXYZ *vp = static_cast<VertexPointXYZ *>(_vertices[1]);
-
-    const Vector3& pt = vp->estimate();
-
-    Vector3 Zcam = cache->w2l() * pt;
-
-    //  J(0,3) = -0.0;
-    J(0,4) = -2*Zcam(2);
-    J(0,5) = 2*Zcam(1);
-
-    J(1,3) = 2*Zcam(2);
-    //  J(1,4) = -0.0;
-    J(1,5) = -2*Zcam(0);
-
-    J(2,3) = -2*Zcam(1);
-    J(2,4) = 2*Zcam(0);
-    //  J(2,5) = -0.0;
-
-    J.block<3,3>(0,6) = cache->w2l().rotation();
-
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> Jprime = params->Kcam_inverseOffsetR()  * J;
-    Vector3 Zprime = cache->w2i() * pt;
-
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> Jhom;
-    Jhom.block<2,9>(0,0) = 1/(Zprime(2)*Zprime(2)) * (Jprime.block<2,9>(0,0)*Zprime(2) - Zprime.head<2>() * Jprime.block<1,9>(2,0));
-    Jhom.block<1,9>(2,0) = Jprime.block<1,9>(2,0);
-
-    _jacobianOplusXi = Jhom.block<3,6>(0,0);
-    _jacobianOplusXj = Jhom.block<3,3>(0,6);
-  }
-
-
-  bool EdgeSE3PointXYZDepth::setMeasurementFromState(){
-    //VertexSE3 *cam = static_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = static_cast<VertexPointXYZ*>(_vertices[1]);
-
-    // calculate the projection
-    const Vector3& pt = point->estimate();
-
-    Vector3 p = cache->w2i() * pt;
-    Vector3 perr;
-    perr.head<2>() = p.head<2>()/p(2);
-    perr(2) = p(2);
-    _measurement = perr;
-    return true;
-  }
-
-
-  void EdgeSE3PointXYZDepth::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
-  {
-    (void) from;
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexDepthCam position by VertexTrackXYZ");
-
-    VertexSE3 *cam = dynamic_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = dynamic_cast<VertexPointXYZ*>(_vertices[1]);
-    const Eigen::Matrix<number_t, 3, 3, Eigen::ColMajor>& invKcam = params->invKcam();
-    Vector3 p;
-    p(2) = _measurement(2);
-    p.head<2>() = _measurement.head<2>()*p(2);
-    p=invKcam*p;
-    point->setEstimate(cam->estimate() * (params->offset() * p));
-  }
-
-}
diff --git a/g2o/types/slam3d/edge_se3_pointxyz_depth.h b/g2o/types/slam3d/edge_se3_pointxyz_depth.h
deleted file mode 100644
index 1a17ecf9..00000000
--- a/g2o/types/slam3d/edge_se3_pointxyz_depth.h
+++ /dev/null
@@ -1,87 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_PROJECT_DEPTH_H_
-#define G2O_EDGE_PROJECT_DEPTH_H_
-
-#include "g2o/core/base_binary_edge.h"
-
-#include "vertex_se3.h"
-#include "vertex_pointxyz.h"
-#include "parameter_camera.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-
-  /*! \class EdgeProjectDepth
-   * \brief g2o edge from a track to a depth camera node using a depth measurement (true distance, not disparity)
-   */
-  class G2O_TYPES_SLAM3D_API EdgeSE3PointXYZDepth : public BaseBinaryEdge<3, Vector3, VertexSE3, VertexPointXYZ> {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSE3PointXYZDepth();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 3-vector
-    void computeError();
-    // jacobian
-    virtual void linearizeOplus();
-
-    virtual bool setMeasurementData(const number_t* d){
-      Eigen::Map<const Vector3> v(d);
-      _measurement = v;
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const{
-      Eigen::Map<Vector3> v(d);
-      v=_measurement;
-      return true;
-    }
-
-    virtual int measurementDimension() const {return 3;}
-
-    virtual bool setMeasurementFromState() ;
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from,
-             OptimizableGraph::Vertex* to) {
-      (void) to;
-      return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
-    }
-
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-  private:
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> J; // jacobian before projection
-
-    virtual bool resolveCaches();
-    ParameterCamera* params;
-    CacheCamera* cache;
-  };
-
-}
-#endif
diff --git a/g2o/types/slam3d/edge_se3_pointxyz_disparity.cpp b/g2o/types/slam3d/edge_se3_pointxyz_disparity.cpp
deleted file mode 100644
index 34dab0d2..00000000
--- a/g2o/types/slam3d/edge_se3_pointxyz_disparity.cpp
+++ /dev/null
@@ -1,202 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_pointxyz_disparity.h"
-
-#include <iostream>
-#include <iomanip>
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-  using namespace std;
-
-
-  // point to camera projection, monocular
-  EdgeSE3PointXYZDisparity::EdgeSE3PointXYZDisparity()
-      : BaseBinaryEdge<3, Vector3, VertexSE3, VertexPointXYZ>(), params(nullptr), cache(nullptr) {
-    resizeParameters(1);
-    installParameter(params, 0);
-    information().setIdentity();
-    information()(2, 2) = 1000.;
-    J.fill(0);
-    J.block<3, 3>(0, 0) = -Matrix3::Identity();
-  }
-
-  bool EdgeSE3PointXYZDisparity::resolveCaches(){
-    ParameterVector pv(1);
-    pv[0]=params;
-    resolveCache(cache, (OptimizableGraph::Vertex*)_vertices[0],"CACHE_CAMERA",pv);
-    return cache != 0;
-  }
-
-
-  bool EdgeSE3PointXYZDisparity::read(std::istream& is) {
-    readParamIds(is);
-    internal::readVector(is, _measurement);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSE3PointXYZDisparity::write(std::ostream& os) const {
-    writeParamIds(os);
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE3PointXYZDisparity::computeError() {
-    //VertexSE3 *cam = static_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = static_cast<VertexPointXYZ*>(_vertices[1]);
-    const Vector3& pt = point->estimate();
-
-    Vector3 p = cache->w2i() * pt;
-
-    Vector3 perr;
-    perr.head<2>() = p.head<2>()/p(2);
-    perr(2) = 1/p(2);
-
-    // error, which is backwards from the normal observed - calculated
-    // _measurement is the measured projection
-    _error = perr - _measurement;
-  }
-
-#ifdef EDGE_PROJECT_DISPARITY_ANALYTIC_JACOBIAN
-
-  void EdgeSE3PointXYZDisparity::linearizeOplus() {
-    //VertexSE3 *cam = static_cast<VertexSE3 *>(_vertices[0]);
-    VertexPointXYZ *vp = static_cast<VertexPointXYZ *>(_vertices[1]);
-
-    const Vector3& pt = vp->estimate();
-
-    Vector3 Zcam = cache->w2l() * vp->estimate();
-
-    //  J(0,3) = -0.0;
-    J(0,4) = -2*Zcam(2);
-    J(0,5) = 2*Zcam(1);
-
-    J(1,3) = 2*Zcam(2);
-    //  J(1,4) = -0.0;
-    J(1,5) = -2*Zcam(0);
-
-    J(2,3) = -2*Zcam(1);
-    J(2,4) = 2*Zcam(0);
-    //  J(2,5) = -0.0;
-
-    J.block<3,3>(0,6) = cache->w2l().rotation();
-
-    //Eigen::Matrix<number_t,3,9,Eigen::ColMajor> Jprime = vcache->params->Kcam_inverseOffsetR  * J;
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> Jprime = params->Kcam_inverseOffsetR()  * J;
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> Jhom;
-    Vector3 Zprime = cache->w2i() * pt;
-
-    Jhom.block<2,9>(0,0) = 1/(Zprime(2)*Zprime(2)) * (Jprime.block<2,9>(0,0)*Zprime(2) - Zprime.head<2>() * Jprime.block<1,9>(2,0));
-    Jhom.block<1,9>(2,0) = - 1/(Zprime(2)*Zprime(2)) * Jprime.block<1,9>(2,0);
-
-    _jacobianOplusXi = Jhom.block<3,6>(0,0);
-    _jacobianOplusXj = Jhom.block<3,3>(0,6);
-  }
-
-#endif
-
-  bool EdgeSE3PointXYZDisparity::setMeasurementFromState(){
-    //VertexSE3 *cam = static_cast< VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = static_cast<VertexPointXYZ*>(_vertices[1]);
-    const Vector3 &pt = point->estimate();
-
-    // VertexCameraCache* vcache = (VertexCameraCache*) cam->getCache(_cacheIds[0]);
-    // if (! vcache){
-    //   cerr << "fatal error in retrieving cache" << endl;
-    // }
-
-    Vector3 p = cache->w2i() * pt;
-
-    Vector3 perr;
-    perr.head<2>() = p.head<2>()/p(2);
-    perr(2) = 1/p(2);
-
-    // error, which is backwards from the normal observed - calculated
-    // _measurement is the measured projection
-    _measurement = perr;
-    return true;
-  }
-
-  void EdgeSE3PointXYZDisparity::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to*/)
-  {
-    (void) from;
-    assert(from.size() == 1 && from.count(_vertices[0]) == 1 && "Can not initialize VertexDepthCam position by VertexTrackXYZ");
-    VertexSE3 *cam = dynamic_cast<VertexSE3*>(_vertices[0]);
-    VertexPointXYZ *point = dynamic_cast<VertexPointXYZ*>(_vertices[1]);
-
-    // VertexCameraCache* vcache = (VertexCameraCache* ) cam->getCache(_cacheIds[0]);
-    // if (! vcache){
-    //   cerr << "fatal error in retrieving cache" << endl;
-    // }
-    //ParameterCamera* params=vcache->params;
-    const Eigen::Matrix<number_t, 3, 3, Eigen::ColMajor>& invKcam = params->invKcam();
-    Vector3 p;
-    number_t w=1./_measurement(2);
-    p.head<2>() = _measurement.head<2>()*w;
-    p(2) = w;
-    p = invKcam * p;
-    p = cam->estimate() * (params->offset() * p);
-    point->setEstimate(p);
-  }
-
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeProjectDisparityDrawAction::EdgeProjectDisparityDrawAction(): DrawAction(typeid(EdgeSE3PointXYZDisparity).name()){}
-
-  HyperGraphElementAction* EdgeProjectDisparityDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                HyperGraphElementAction::Parameters*  params_ ){
-  if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-    EdgeSE3PointXYZDisparity* e =  static_cast<EdgeSE3PointXYZDisparity*>(element);
-    VertexSE3* fromEdge = static_cast<VertexSE3*>(e->vertices()[0]);
-    VertexPointXYZ* toEdge   = static_cast<VertexPointXYZ*>(e->vertices()[1]);
-    if (! fromEdge || ! toEdge)
-      return this;
-    Isometry3 fromTransform=fromEdge->estimate() * e->cameraParameter()->offset();
-    glColor3f(LANDMARK_EDGE_COLOR);
-    glPushAttrib(GL_ENABLE_BIT);
-    glDisable(GL_LIGHTING);
-    glBegin(GL_LINES);
-    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),(float)fromTransform.translation().z());
-    glVertex3f((float)toEdge->estimate().x(),(float)toEdge->estimate().y(),(float)toEdge->estimate().z());
-    glEnd();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d/edge_se3_pointxyz_disparity.h b/g2o/types/slam3d/edge_se3_pointxyz_disparity.h
deleted file mode 100644
index f55416be..00000000
--- a/g2o/types/slam3d/edge_se3_pointxyz_disparity.h
+++ /dev/null
@@ -1,102 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_POINTXYZ_DISPARITY_H_
-#define G2O_EDGE_SE3_POINTXYZ_DISPARITY_H_
-
-#include "vertex_se3.h"
-#include "vertex_pointxyz.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "g2o/core/base_binary_edge.h"
-#include "parameter_camera.h"
-
-#define EDGE_PROJECT_DISPARITY_ANALYTIC_JACOBIAN
-namespace g2o {
-
-  /**
-   * \brief edge from a track to a depth camera node using a disparity measurement
-   *
-   * the disparity measurement is normalized: disparity / (focal_x * baseline)
-   */
-  // first two args are the measurement type, second two the connection classes
-  class G2O_TYPES_SLAM3D_API EdgeSE3PointXYZDisparity : public BaseBinaryEdge<3, Vector3, VertexSE3, VertexPointXYZ> {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    EdgeSE3PointXYZDisparity();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    // return the error estimate as a 3-vector
-    void computeError();
-
-#ifdef EDGE_PROJECT_DISPARITY_ANALYTIC_JACOBIAN
-    virtual void linearizeOplus();
-#endif
-
-    virtual bool setMeasurementData(const number_t* d){
-      Eigen::Map<const Vector3> v(d);
-      _measurement = v;
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const{
-      Eigen::Map<Vector3> v(d);
-      v=_measurement;
-      return true;
-    }
-
-    virtual int measurementDimension() const {return 3;}
-
-    virtual bool setMeasurementFromState();
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from,
-             OptimizableGraph::Vertex* to) {
-      (void) to;
-      return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
-    }
-
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
-    const ParameterCamera* cameraParameter() const { return params; }
-  private:
-    Eigen::Matrix<number_t,3,9,Eigen::ColMajor> J; // jacobian before projection
-    virtual bool resolveCaches();
-    ParameterCamera* params;
-    CacheCamera* cache;
-  };
-
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM3D_API EdgeProjectDisparityDrawAction: public DrawAction{
-  public:
-    EdgeProjectDisparityDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-}
-#endif
diff --git a/g2o/types/slam3d/edge_se3_prior.cpp b/g2o/types/slam3d/edge_se3_prior.cpp
deleted file mode 100644
index 665185cd..00000000
--- a/g2o/types/slam3d/edge_se3_prior.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_prior.h"
-
-#include <iostream>
-
-#include "isometry3d_gradients.h"
-
-namespace g2o {
-using namespace std;
-
-// point to camera projection, monocular
-EdgeSE3Prior::EdgeSE3Prior() : BaseUnaryEdge<6, Isometry3, VertexSE3>() {
-  setMeasurement(Isometry3::Identity());
-  information().setIdentity();
-  _cache = 0;
-  _offsetParam = 0;
-  resizeParameters(1);
-  installParameter(_offsetParam, 0);
-}
-
-bool EdgeSE3Prior::resolveCaches() {
-  assert(_offsetParam);
-  ParameterVector pv(1);
-  pv[0] = _offsetParam;
-  resolveCache(_cache, (OptimizableGraph::Vertex*)_vertices[0], "CACHE_SE3_OFFSET", pv);
-  return _cache != 0;
-}
-
-bool EdgeSE3Prior::read(std::istream& is) {
-  bool state = readParamIds(is);
-  Vector7 meas;
-  state &= internal::readVector(is, meas);
-  setMeasurement(internal::fromVectorQT(meas));
-  state &= readInformationMatrix(is);
-  return state;
-}
-
-bool EdgeSE3Prior::write(std::ostream& os) const {
-  writeParamIds(os);
-  internal::writeVector(os, internal::toVectorQT(measurement()));
-  writeInformationMatrix(os);
-  return os.good();
-}
-
-void EdgeSE3Prior::computeError() {
-  Isometry3 delta = _inverseMeasurement * _cache->n2w();
-  _error = internal::toVectorMQT(delta);
-}
-
-void EdgeSE3Prior::linearizeOplus() {
-  VertexSE3* from = static_cast<VertexSE3*>(_vertices[0]);
-  Isometry3 E;
-  Isometry3 Z, X, P;
-  X = from->estimate();
-  P = _cache->offsetParam()->offset();
-  Z = _measurement;
-  internal::computeEdgeSE3PriorGradient(E, _jacobianOplusXi, Z, X, P);
-}
-
-bool EdgeSE3Prior::setMeasurementFromState() {
-  setMeasurement(_cache->n2w());
-  return true;
-}
-
-void EdgeSE3Prior::initialEstimate(const OptimizableGraph::VertexSet& /*from_*/, OptimizableGraph::Vertex* /*to_*/) {
-  VertexSE3* v = static_cast<VertexSE3*>(_vertices[0]);
-  assert(v && "Vertex for the Prior edge is not set");
-
-  Isometry3 newEstimate = _offsetParam->offset().inverse() * measurement();
-  // do not set translation, as that part of the information is all zero
-  if (_information.block<3, 3>(0, 0).array().abs().sum() == 0) {
-    newEstimate.translation() = v->estimate().translation();
-  }
-  // do not set rotation, as that part of the information is all zero
-  if (_information.block<3, 3>(3, 3).array().abs().sum() == 0) {
-    newEstimate.matrix().block<3, 3>(0, 0) = internal::extractRotation(v->estimate());
-  }
-  v->setEstimate(newEstimate);
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d/edge_se3_prior.h b/g2o/types/slam3d/edge_se3_prior.h
deleted file mode 100644
index 73940022..00000000
--- a/g2o/types/slam3d/edge_se3_prior.h
+++ /dev/null
@@ -1,92 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_PRIOR_H_
-#define G2O_EDGE_SE3_PRIOR_H_
-
-#include "g2o/core/base_unary_edge.h"
-#include "g2o_types_slam3d_api.h"
-#include "parameter_se3_offset.h"
-#include "vertex_se3.h"
-
-namespace g2o {
-/**
- * \brief prior for an SE3 element
- *
- * Provides a prior for a 3d pose vertex. Again the measurement is represented by an
- * Isometry3 matrix.
- */
-class G2O_TYPES_SLAM3D_API EdgeSE3Prior : public BaseUnaryEdge<6, Isometry3, VertexSE3> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  EdgeSE3Prior();
-  virtual bool read(std::istream& is);
-  virtual bool write(std::ostream& os) const;
-
-  // return the error estimate as a 3-vector
-  void computeError();
-
-  // jacobian
-  virtual void linearizeOplus();
-
-  virtual void setMeasurement(const Isometry3& m) {
-    _measurement = m;
-    _inverseMeasurement = m.inverse();
-  }
-
-  virtual bool setMeasurementData(const number_t* d) {
-    Eigen::Map<const Vector7> v(d);
-    _measurement = internal::fromVectorQT(v);
-    _inverseMeasurement = _measurement.inverse();
-    return true;
-  }
-
-  virtual bool getMeasurementData(number_t* d) const {
-    Eigen::Map<Vector7> v(d);
-    v = internal::toVectorQT(_measurement);
-    return true;
-  }
-
-  virtual int measurementDimension() const { return 7; }
-
-  virtual bool setMeasurementFromState();
-
-  virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& /*from*/,
-                                           OptimizableGraph::Vertex* /*to*/) {
-    return 1.;
-  }
-
-  virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
-
- protected:
-  Isometry3 _inverseMeasurement;
-  virtual bool resolveCaches();
-  ParameterSE3Offset* _offsetParam;
-  CacheSE3Offset* _cache;
-};
-
-}  // namespace g2o
-#endif
diff --git a/g2o/types/slam3d/edge_se3_xyzprior.cpp b/g2o/types/slam3d/edge_se3_xyzprior.cpp
deleted file mode 100644
index 805f8a01..00000000
--- a/g2o/types/slam3d/edge_se3_xyzprior.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_xyzprior.h"
-
-namespace g2o {
-
-  EdgeSE3XYZPrior::EdgeSE3XYZPrior() : BaseUnaryEdge<3, Vector3, g2o::VertexSE3>()
-  {
-    information().setIdentity();
-    setMeasurement(Vector3::Zero());
-    _cache = 0;
-    _offsetParam = 0;
-    resizeParameters(1);
-    installParameter(_offsetParam, 0);
-  }
-
-  bool EdgeSE3XYZPrior::resolveCaches(){
-    assert(_offsetParam);
-    ParameterVector pv(1);
-    pv[0] = _offsetParam;
-    resolveCache(_cache, (OptimizableGraph::Vertex*)_vertices[0], "CACHE_SE3_OFFSET", pv);
-    return _cache != 0;
-  }
-
-  bool EdgeSE3XYZPrior::read(std::istream& is)
-  {
-    readParamIds(is);
-    internal::readVector(is, _measurement);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeSE3XYZPrior::write(std::ostream& os) const {
-    writeParamIds(os);
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE3XYZPrior::computeError() {
-    const VertexSE3* v = static_cast<const VertexSE3*>(_vertices[0]);
-    _error = v->estimate().translation() - _measurement;
-  }
-
-  void EdgeSE3XYZPrior::linearizeOplus() {
-    _jacobianOplusXi << Matrix3::Identity();
-  }
-
-  bool EdgeSE3XYZPrior::setMeasurementFromState() {
-    const VertexSE3* v = static_cast<const VertexSE3*>(_vertices[0]);
-    _measurement = v->estimate().translation();
-    return true;
-  }
-
-  void EdgeSE3XYZPrior::initialEstimate(const OptimizableGraph::VertexSet& /*from_*/, OptimizableGraph::Vertex* /*to_*/) {
-    VertexSE3 *v = static_cast<VertexSE3*>(_vertices[0]);
-    assert(v && "Vertex for the Prior edge is not set");
-
-    Isometry3 newEstimate = _offsetParam->offset().inverse() * Eigen::Translation3d(measurement());
-    if (_information.block<3,3>(0,0).array().abs().sum() == 0){ // do not set translation, as that part of the information is all zero
-      newEstimate.translation() = v->estimate().translation();
-    }
-    v->setEstimate(newEstimate);
-  }
-
-} // end namespace
diff --git a/g2o/types/slam3d/edge_se3_xyzprior.h b/g2o/types/slam3d/edge_se3_xyzprior.h
deleted file mode 100644
index 0d12c507..00000000
--- a/g2o/types/slam3d/edge_se3_xyzprior.h
+++ /dev/null
@@ -1,78 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_PRIOR_XYZ_H
-#define G2O_EDGE_SE3_PRIOR_XYZ_H
-
-#include "vertex_se3.h"
-#include "g2o/core/base_unary_edge.h"
-#include "parameter_se3_offset.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-  /**
-   * \brief Prior for a 3D pose with constraints only in xyz direction
-   */
-  class G2O_TYPES_SLAM3D_API EdgeSE3XYZPrior : public BaseUnaryEdge<3, Vector3, VertexSE3>
-  {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeSE3XYZPrior();
-
-    virtual bool setMeasurementData(const number_t* d) {
-      Eigen::Map<const Vector3> v(d);
-      _measurement = v;
-      return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const {
-      Eigen::Map<Vector3> v(d);
-      v = _measurement;
-      return true;
-    }
-
-    virtual int measurementDimension() const {return Dimension;}
-
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-    virtual void computeError();
-    virtual void linearizeOplus();
-    virtual bool setMeasurementFromState();
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& /*from*/, OptimizableGraph::Vertex* /*to*/) {return 1.;}
-    virtual void initialEstimate(const OptimizableGraph::VertexSet& /*from_*/, OptimizableGraph::Vertex* /*to_*/);
-
-    const ParameterSE3Offset* offsetParameter() { return _offsetParam; }
-
-  protected:
-    virtual bool resolveCaches();
-    ParameterSE3Offset* _offsetParam;
-    CacheSE3Offset* _cache;
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d/edge_xyz_prior.cpp b/g2o/types/slam3d/edge_xyz_prior.cpp
deleted file mode 100644
index ed54cf97..00000000
--- a/g2o/types/slam3d/edge_xyz_prior.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_xyz_prior.h"
-#include <iostream>
-
-namespace g2o {
-  using namespace std;
-
-  EdgeXYZPrior::EdgeXYZPrior() : BaseUnaryEdge<3, Vector3, VertexPointXYZ>() {
-    information().setIdentity();
-  }
-
-  bool EdgeXYZPrior::read(std::istream& is) {
-    internal::readVector(is, _measurement);
-    return readInformationMatrix(is);
-  }
-
-  bool EdgeXYZPrior::write(std::ostream& os) const {
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeXYZPrior::computeError() {
-    const VertexPointXYZ* v = static_cast<const VertexPointXYZ*>(_vertices[0]);
-    _error = v->estimate() - _measurement;
-  }
-
-  void EdgeXYZPrior::linearizeOplus(){
-      _jacobianOplusXi = Matrix3::Identity();
-  }
-
-  bool EdgeXYZPrior::setMeasurementFromState(){
-      const VertexPointXYZ* v = static_cast<const VertexPointXYZ*>(_vertices[0]);
-      _measurement = v->estimate();
-      return true;
-  }
-}
diff --git a/g2o/types/slam3d/edge_xyz_prior.h b/g2o/types/slam3d/edge_xyz_prior.h
deleted file mode 100644
index 91272659..00000000
--- a/g2o/types/slam3d/edge_xyz_prior.h
+++ /dev/null
@@ -1,76 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_XYZ_PRIOR_H_
-#define G2O_EDGE_XYZ_PRIOR_H_
-
-#include "g2o/core/base_unary_edge.h"
-#include "g2o_types_slam3d_api.h"
-#include "vertex_pointxyz.h"
-
-namespace g2o {
-  /**
-   * \brief prior for an XYZ vertex (VertexPointXYZ)
-   *
-   * Provides a prior for a 3d point vertex. The measurement is represented by a
-   * Vector3 with a corresponding 3x3 upper triangle covariance matrix (upper triangle only).
-   */
-  class G2O_TYPES_SLAM3D_API EdgeXYZPrior : public BaseUnaryEdge<3, Vector3, VertexPointXYZ> {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    EdgeXYZPrior();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    void computeError();
-
-    // jacobian
-    virtual void linearizeOplus();
-
-    virtual bool setMeasurementData(const number_t* d){
-        Eigen::Map<const Vector3> v(d);
-        _measurement = v;
-        return true;
-    }
-
-    virtual bool getMeasurementData(number_t* d) const{
-        Eigen::Map<Vector3> v(d);
-        v = _measurement;
-        return true;
-    }
-
-    virtual int measurementDimension() const { return 3; }
-
-    virtual bool setMeasurementFromState() ;
-
-    virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& /*from*/,
-             OptimizableGraph::Vertex* /*to*/) {
-      return 0;
-    }
-  };
-
-}
-#endif
diff --git a/g2o/types/slam3d/g2o_types_slam3d_api.h b/g2o/types/slam3d/g2o_types_slam3d_api.h
deleted file mode 100644
index b26c0716..00000000
--- a/g2o/types/slam3d/g2o_types_slam3d_api.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-/***************************************************************************
- *  Description: import/export macros for creating DLLS with Microsoft
- *	compiler. Any exported function needs to be declared with the
- *  appropriate G2O_XXXX_API macro. Also, there must be separate macros
- *  for each DLL (arrrrrgh!!!)
- *
- *  17 Jan 2012
- *  Email: pupilli@cs.bris.ac.uk
- ****************************************************************************/
-#ifndef G2O_TYPES_SLAM3D_API_H
-#define G2O_TYPES_SLAM3D_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_slam3d_EXPORTS
-#define G2O_TYPES_SLAM3D_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SLAM3D_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SLAM3D_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SLAM3D_API
-#endif
-
-#endif // G2O_TYPES_SLAM3D_API_H
diff --git a/g2o/types/slam3d/isometry3d_gradients.cpp b/g2o/types/slam3d/isometry3d_gradients.cpp
deleted file mode 100644
index 3a661617..00000000
--- a/g2o/types/slam3d/isometry3d_gradients.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "isometry3d_gradients.h"
-#include <iostream>
-namespace g2o {
-  using namespace std;
-  using namespace Eigen;
-
-  namespace internal {
-  #include "dquat2mat.cpp"
-  } // end namespace internal
-
-} // end namespace
diff --git a/g2o/types/slam3d/isometry3d_gradients.h b/g2o/types/slam3d/isometry3d_gradients.h
deleted file mode 100644
index 621de2c3..00000000
--- a/g2o/types/slam3d/isometry3d_gradients.h
+++ /dev/null
@@ -1,329 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_ISOMETRY3D_GRADIENTS_H_
-#define G2O_ISOMETRY3D_GRADIENTS_H_
-
-#include "isometry3d_mappings.h"
-#include "dquat2mat.h"
-
-#include <Eigen/Core>
-
-namespace g2o {
-  namespace internal {
-    // forward declaration
-    /* void G2O_TYPES_SLAM3D_API compute_dq_dR (Eigen::Matrix<number_t, 3 , 9, Eigen::ColMajor>&  dq_dR , const number_t&  r11 , const number_t&  r21 , const number_t&  r31 , const number_t&  r12 , const number_t&  r22 , const number_t&  r32 , const number_t&  r13 , const number_t&  r23 , const number_t&  r33 );  */
-
-    template <typename Derived, typename DerivedOther, bool transposed = false>
-    inline void skew(Eigen::MatrixBase<Derived>& s, const Eigen::MatrixBase<DerivedOther>& v){
-      const number_t x=2*v(0);
-      const number_t y=2*v(1);
-      const number_t z=2*v(2);
-      if (transposed)
-        s << 0., -z, y, z, 0, -x, -y, x, 0;
-      else
-        s << 0., z, -y, -z, 0, x, y, -x, 0;
-    }
-
-    template <typename Derived, typename DerivedOther>
-    inline void skewT(Eigen::MatrixBase<Derived>& s, const Eigen::MatrixBase<DerivedOther>& v){
-      skew<Derived, DerivedOther, true>(s, v);
-    }
-
-    template <typename Derived, typename DerivedOther, bool transposed = false>
-    void skew(Eigen::MatrixBase<Derived>& Sx,
-        Eigen::MatrixBase<Derived>& Sy,
-        Eigen::MatrixBase<Derived>& Sz,
-        const Eigen::MatrixBase<DerivedOther>& R){
-      const number_t
-        r11=2*R(0,0), r12=2*R(0,1), r13=2*R(0,2),
-        r21=2*R(1,0), r22=2*R(1,1), r23=2*R(1,2),
-        r31=2*R(2,0), r32=2*R(2,1), r33=2*R(2,2);
-      if (transposed) {
-        Sx << 0, 0, 0, r31, r32, r33, -r21, -r22, -r23;
-        Sy << -r31, -r32, -r33, 0, 0, 0, r11, r12, r13;
-        Sz << r21, r22, r23, -r11, -r12, -r13, 0, 0, 0;
-      } else {
-        Sx << 0, 0, 0, -r31, -r32, -r33, r21, r22, r23;
-        Sy << r31, r32, r33, 0, 0, 0, -r11, -r12, -r13;
-        Sz << -r21, -r22, -r23, r11, r12, r13, 0, 0, 0;
-      }
-    }
-
-    template <typename Derived, typename DerivedOther>
-    inline void skewT(Eigen::MatrixBase<Derived>& Sx,
-        Eigen::MatrixBase<Derived>& Sy,
-        Eigen::MatrixBase<Derived>& Sz,
-        const Eigen::MatrixBase<DerivedOther>& R){
-      skew<Derived, DerivedOther, true>(Sx, Sy, Sz, R);
-    }
-
-  template <typename Derived>
-  void computeEdgeSE3Gradient(Isometry3& E,
-                              Eigen::MatrixBase<Derived> const & JiConstRef,
-                              Eigen::MatrixBase<Derived> const & JjConstRef,
-                              const Isometry3& Z,
-                              const Isometry3& Xi,
-                              const Isometry3& Xj,
-                              const Isometry3& Pi/*=Isometry3()*/,
-                              const Isometry3& Pj/*=Isometry3()*/)
-  {
-    Eigen::MatrixBase<Derived>& Ji = const_cast<Eigen::MatrixBase<Derived>&>(JiConstRef);
-    Eigen::MatrixBase<Derived>& Jj = const_cast<Eigen::MatrixBase<Derived>&>(JjConstRef);
-    Ji.derived().resize(6,6);
-    Jj.derived().resize(6,6);
-    // compute the error at the linearization point
-    const Isometry3 A=Z.inverse()*Pi.inverse();
-    const Isometry3 B=Xi.inverse()*Xj;
-    const Isometry3& C=Pj;
-
-    const Isometry3 AB=A*B;
-    const Isometry3 BC=B*C;
-    E=AB*C;
-
-    Isometry3::ConstLinearPart Re = extractRotation(E);
-    Isometry3::ConstLinearPart Ra = extractRotation(A);
-    //const Matrix3 Rb = extractRotation(B);
-    Isometry3::ConstLinearPart Rc = extractRotation(C);
-    Isometry3::ConstTranslationPart tc = C.translation();
-    //Isometry3::ConstTranslationParttab=AB.translation();
-    Isometry3::ConstLinearPart Rab = extractRotation(AB);
-    Isometry3::ConstTranslationPart tbc = BC.translation();
-    Isometry3::ConstLinearPart Rbc = extractRotation(BC);
-
-    Eigen::Matrix<number_t, 3 , 9, Eigen::ColMajor>  dq_dR;
-    compute_dq_dR (dq_dR,
-        Re(0,0),Re(1,0),Re(2,0),
-        Re(0,1),Re(1,1),Re(2,1),
-        Re(0,2),Re(1,2),Re(2,2));
-
-    Ji.setZero();
-    Jj.setZero();
-
-    // dte/dti
-    Ji.template block<3,3>(0,0)=-Ra;
-
-    // dte/dtj
-    Jj.template block<3,3>(0,0)=Rab;
-
-    // dte/dqi
-    {
-      Matrix3 S;
-      skewT(S,tbc);
-      Ji.template block<3,3>(0,3)=Ra*S;
-    }
-
-    // dte/dqj
-    {
-      Matrix3 S;
-      skew(S,tc);
-      Jj.template block<3,3>(0,3)=Rab*S;
-    }
-
-    // dre/dqi
-    {
-      number_t buf[27];
-      Eigen::Map<Eigen::Matrix<number_t, 9, 3, Eigen::ColMajor> > M(buf);
-      Matrix3 Sxt,Syt,Szt;
-      internal::skewT(Sxt,Syt,Szt,Rbc);
-#ifdef __clang__
-      Matrix3 temp = Rab * Sxt;
-      Eigen::Map<Matrix3> M2(temp.data());
-      Eigen::Map<Matrix3> Mx(buf);    Mx = M2;
-      temp = Ra*Syt;
-      Eigen::Map<Matrix3> My(buf+9);  My = M2;
-      temp = Ra*Szt;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz = M2;
-#else
-      Eigen::Map<Matrix3> Mx(buf);    Mx = Ra*Sxt;
-      Eigen::Map<Matrix3> My(buf+9);  My = Ra*Syt;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz = Ra*Szt;
-#endif
-      Ji.template block<3,3>(3,3) = dq_dR * M;
-    }
-
-    // dre/dqj
-    {
-      number_t buf[27];
-      Eigen::Map <Eigen::Matrix<number_t, 9, 3, Eigen::ColMajor> > M(buf);
-      Matrix3 Sx,Sy,Sz;
-      internal::skew(Sx,Sy,Sz,Rc);
-#ifdef __clang__
-      Matrix3 temp = Rab * Sx;
-      Eigen::Map<Matrix3> M2(temp.data());
-      Eigen::Map<Matrix3> Mx(buf);    Mx = M2;
-      temp = Rab*Sy;
-      Eigen::Map<Matrix3> My(buf+9);  My = M2;
-      temp = Rab*Sz;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz = M2;
-#else
-      Eigen::Map<Matrix3> Mx(buf);    Mx = Rab*Sx;
-      Eigen::Map<Matrix3> My(buf+9);  My = Rab*Sy;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz = Rab*Sz;
-#endif
-      Jj.template block<3,3>(3,3) = dq_dR * M;
-    }
-  }
-
-  template <typename Derived>
-  void computeEdgeSE3Gradient(Isometry3& E,
-                              Eigen::MatrixBase<Derived> const & JiConstRef,
-                              Eigen::MatrixBase<Derived> const & JjConstRef,
-                              const Isometry3& Z,
-                              const Isometry3& Xi,
-                              const Isometry3& Xj)
-  {
-    Eigen::MatrixBase<Derived>& Ji = const_cast<Eigen::MatrixBase<Derived>&>(JiConstRef);
-    Eigen::MatrixBase<Derived>& Jj = const_cast<Eigen::MatrixBase<Derived>&>(JjConstRef);
-    Ji.derived().resize(6,6);
-    Jj.derived().resize(6,6);
-    // compute the error at the linearization point
-    const Isometry3 A=Z.inverse();
-    const Isometry3 B=Xi.inverse()*Xj;
-
-    E=A*B;
-
-    Isometry3::ConstLinearPart Re = extractRotation(E);
-    Isometry3::ConstLinearPart Ra = extractRotation(A);
-    Isometry3::ConstLinearPart Rb = extractRotation(B);
-    Isometry3::ConstTranslationPart tb = B.translation();
-
-    Eigen::Matrix<number_t, 3, 9, Eigen::ColMajor>  dq_dR;
-    compute_dq_dR (dq_dR,
-        Re(0,0),Re(1,0),Re(2,0),
-        Re(0,1),Re(1,1),Re(2,1),
-        Re(0,2),Re(1,2),Re(2,2));
-
-    Ji.setZero();
-    Jj.setZero();
-
-    // dte/dti
-    Ji.template block<3,3>(0,0)=-Ra;
-
-    // dte/dtj
-    Jj.template block<3,3>(0,0)=Re;
-
-    // dte/dqi
-    {
-      Matrix3 S;
-      skewT(S,tb);
-      Ji.template block<3,3>(0,3)=Ra*S;
-    }
-
-    // dte/dqj: this is zero
-
-    number_t buf[27];
-    Eigen::Map<Eigen::Matrix<number_t, 9, 3, Eigen::ColMajor> > M(buf);
-    Matrix3 Sxt,Syt,Szt;
-    // dre/dqi
-    {
-      skewT(Sxt,Syt,Szt,Rb);
-      Eigen::Map<Matrix3> Mx(buf);    Mx.noalias() = Ra*Sxt;
-      Eigen::Map<Matrix3> My(buf+9);  My.noalias() = Ra*Syt;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz.noalias() = Ra*Szt;
-      Ji.template block<3,3>(3,3) = dq_dR * M;
-    }
-
-    // dre/dqj
-    {
-      Matrix3& Sx = Sxt;
-      Matrix3& Sy = Syt;
-      Matrix3& Sz = Szt;
-      skew(Sx,Sy,Sz,Matrix3::Identity());
-      Eigen::Map<Matrix3> Mx(buf);    Mx.noalias() = Re*Sx;
-      Eigen::Map<Matrix3> My(buf+9);  My.noalias() = Re*Sy;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz.noalias() = Re*Sz;
-      Jj.template block<3,3>(3,3) = dq_dR * M;
-    }
-  }
-
-
-  template <typename Derived>
-  void computeEdgeSE3PriorGradient(Isometry3& E,
-                                   const Eigen::MatrixBase<Derived>& JConstRef,
-                                   const Isometry3& Z,
-                                   const Isometry3& X,
-                                   const Isometry3& P=Isometry3::Identity())
-  {
-    Eigen::MatrixBase<Derived>& J = const_cast<Eigen::MatrixBase<Derived>&>(JConstRef);
-    J.derived().resize(6,6);
-    // compute the error at the linearization point
-    const Isometry3 A = Z.inverse()*X;
-    const Isometry3& B = P;
-    Isometry3::ConstLinearPart Ra = extractRotation(A);
-    Isometry3::ConstLinearPart Rb = extractRotation(B);
-    Isometry3::ConstTranslationPart tb = B.translation();
-    E = A*B;
-    Isometry3::ConstLinearPart Re = extractRotation(E);
-
-    Eigen::Matrix<number_t, 3, 9, Eigen::ColMajor> dq_dR;
-    compute_dq_dR (dq_dR,
-        Re(0,0),Re(1,0),Re(2,0),
-        Re(0,1),Re(1,1),Re(2,1),
-        Re(0,2),Re(1,2),Re(2,2));
-
-    J.setZero();
-
-    // dte/dt
-    J.template block<3,3>(0,0)=Ra;
-
-    // dte/dq =0
-    // dte/dqj
-    {
-      Matrix3 S;
-      skew(S,tb);
-      J.template block<3,3>(0,3)=Ra*S;
-    }
-
-    // dre/dt =0
-
-    // dre/dq
-    {
-      number_t buf[27];
-      Eigen::Map<Eigen::Matrix<number_t, 9, 3, Eigen::ColMajor> > M(buf);
-      Matrix3 Sx,Sy,Sz;
-      internal::skew(Sx,Sy,Sz,Rb);
-#ifdef __clang__
-      Matrix3 temp = Ra * Sx;
-      Eigen::Map<Matrix3> M2(temp.data());
-      Eigen::Map<Matrix3> Mx(buf);    Mx = M2;
-      temp = Ra*Sy;
-      Eigen::Map<Matrix3> My(buf+9);  My = M2;
-      temp = Ra*Sz;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz = M2;
-#else
-      Eigen::Map<Matrix3> Mx(buf);    Mx = Ra*Sx;
-      Eigen::Map<Matrix3> My(buf+9);  My = Ra*Sy;
-      Eigen::Map<Matrix3> Mz(buf+18); Mz = Ra*Sz;
-#endif
-      J.template block<3,3>(3,3) = dq_dR * M;
-    }
-
-  }
-
-} // end namespace internal
-} // end namespace g2o
-#endif
diff --git a/g2o/types/slam3d/isometry3d_mappings.cpp b/g2o/types/slam3d/isometry3d_mappings.cpp
deleted file mode 100644
index a02cc269..00000000
--- a/g2o/types/slam3d/isometry3d_mappings.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat, G. Grisetti, R. Kmmerle, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "isometry3d_mappings.h"
-#include "g2o/stuff/misc.h"
-
-namespace g2o {
-  namespace internal {
-
-    Quaternion normalized(const Quaternion& q) {
-      Quaternion q2(q);
-      normalize(q2);
-      return q2;
-    }
-
-    Quaternion& normalize(Quaternion& q){
-      q.normalize();
-      if (q.w()<0) {
-        q.coeffs() *= -1;
-      }
-      return q;
-    }
-
-    // functions to handle the rotation part
-    Vector3 toEuler(const Matrix3& R) {
-      Quaternion q(R);
-      const number_t& q0 = q.w();
-      const number_t& q1 = q.x();
-      const number_t& q2 = q.y();
-      const number_t& q3 = q.z();
-      number_t roll = std::atan2(2*(q0*q1+q2*q3), 1-2*(q1*q1+q2*q2));
-      number_t pitch = std::asin(2*(q0*q2-q3*q1));
-      number_t yaw = std::atan2(2*(q0*q3+q1*q2), 1-2*(q2*q2+q3*q3));
-      return Vector3(roll, pitch, yaw);
-    }
-
-    Matrix3 fromEuler(const Vector3& v) {
-      //UNOPTIMIZED
-      number_t roll  = v[0];
-      number_t pitch = v[1];
-      number_t yaw   = v[2];
-      number_t sy = std::sin(yaw*cst(0.5));
-      number_t cy = std::cos(yaw*cst(0.5));
-      number_t sp = std::sin(pitch*cst(0.5));
-      number_t cp = std::cos(pitch*cst(0.5));
-      number_t sr = std::sin(roll*cst(0.5));
-      number_t cr = std::cos(roll*cst(0.5));
-      number_t w = cr*cp*cy + sr*sp*sy;
-      number_t x = sr*cp*cy - cr*sp*sy;
-      number_t y = cr*sp*cy + sr*cp*sy;
-      number_t z = cr*cp*sy - sr*sp*cy;
-      return Quaternion(w,x,y,z).toRotationMatrix();
-    }
-
-    Vector3 toCompactQuaternion(const Matrix3& R) {
-      Quaternion q(R);
-      normalize(q);
-      // return (x,y,z) of the quaternion
-      return q.coeffs().head<3>();
-    }
-
-    Matrix3 fromCompactQuaternion(const Vector3& v) {
-      number_t w = 1-v.squaredNorm();
-      if (w<0)
-        return Matrix3::Identity();
-      else
-        w=sqrt(w);
-      return Quaternion(w, v[0], v[1], v[2]).toRotationMatrix();
-    }
-
-    // functions to handle the toVector of the whole transformations
-    Vector6 toVectorMQT(const Isometry3& t) {
-      Vector6 v;
-      v.block<3,1>(3,0) = toCompactQuaternion(extractRotation(t));
-      v.block<3,1>(0,0) = t.translation();
-      return v;
-    }
-
-    Vector6 toVectorET(const Isometry3& t) {
-      Vector6 v;
-      v.block<3,1>(3,0)=toEuler(extractRotation(t));
-      v.block<3,1>(0,0) = t.translation();
-      return v;
-    }
-
-    Vector7 toVectorQT(const Isometry3& t){
-      Quaternion q(extractRotation(t));
-      q.normalize();
-      Vector7 v;
-      v[3] = q.x(); v[4] = q.y(); v[5] = q.z(); v[6] = q.w();
-      v.block<3,1>(0,0) = t.translation();
-      return v;
-    }
-
-    Isometry3 fromVectorMQT(const Vector6& v){
-      Isometry3 t;
-      t = fromCompactQuaternion(v.block<3,1>(3,0));
-      t.translation() = v.block<3,1>(0,0);
-      return t;
-    }
-
-    Isometry3 fromVectorET(const Vector6& v) {
-      Isometry3 t;
-      t = fromEuler(v.block<3,1>(3,0));
-      t.translation() = v.block<3,1>(0,0);
-      return t;
-    }
-
-    Isometry3 fromVectorQT(const Vector7& v) {
-      Isometry3 t;
-      t=Quaternion(v[6], v[3], v[4], v[5]).toRotationMatrix();
-      t.translation() = v.head<3>();
-      return t;
-    }
-
-    SE3Quat toSE3Quat(const Isometry3& t)
-    {
-      SE3Quat result(t.matrix().topLeftCorner<3,3>(), t.translation());
-      return result;
-    }
-
-    Isometry3 fromSE3Quat(const SE3Quat& t)
-    {
-      Isometry3 result = (Isometry3) t.rotation();
-      result.translation() = t.translation();
-      return result;
-    }
-
-  } // end namespace internal
-} // end namespace g2o
diff --git a/g2o/types/slam3d/isometry3d_mappings.h b/g2o/types/slam3d/isometry3d_mappings.h
deleted file mode 100644
index 9bd6ba34..00000000
--- a/g2o/types/slam3d/isometry3d_mappings.h
+++ /dev/null
@@ -1,155 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat, G. Grisetti, R. Kmmerle, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_ISOMETRY3D_MAPPINGS_H_
-#define G2O_ISOMETRY3D_MAPPINGS_H_
-
-#include "g2o_types_slam3d_api.h"
-#include "se3quat.h"
-#include <Eigen/Core>
-
-namespace g2o {
-
-  /**
-   * internal functions used inside g2o.
-   * Those functions may disappear or change their meaning without further
-   * notification
-   */
-  namespace internal {
-
-    /**
-     * extract the rotation matrix from an Isometry3 matrix. Eigen itself
-     * performs an SVD decomposition to recover the nearest orthogonal matrix,
-     * since its rotation() function also handles a scaling matrix.  An Isometry3 does
-     * not have a scaling portion and we assume that the Isometry3 is
-     * numerically stable while we compute the error and the Jacobians.  Hence,
-     * we directly extract the rotation block out of the full matrix.
-     *
-     * Note, we could also call .linear() on the Isometry3. However, I dislike
-     * the name of that function a bit.
-     */
-    inline Isometry3::ConstLinearPart extractRotation(const Isometry3& A)
-    {
-      return A.matrix().topLeftCorner<3,3>();
-    }
-
-    /**
-     * computes the nearest orthogonal matrix of a rotation matrix which might
-     * be affected by numerical inaccuracies. We periodically call this function
-     * after performinag a large number of updates on vertices.
-     * This function computes an SVD to reconstruct the nearest orthogonal matrix.
-     */
-    template <typename Derived>
-    void nearestOrthogonalMatrix(const Eigen::MatrixBase<Derived>& R)
-    {
-      Eigen::JacobiSVD<Matrix3> svd(R, Eigen::ComputeFullU | Eigen::ComputeFullV);
-      number_t det = (svd.matrixU() * svd.matrixV().adjoint()).determinant();
-      Matrix3 scaledU(svd.matrixU());
-      scaledU.col(0) /= det;
-      const_cast<Eigen::MatrixBase<Derived>&>(R) = scaledU * svd.matrixV().transpose();
-    }
-
-    /**
-     * compute a fast approximation for the nearest orthogonal rotation matrix.
-     * The function computes the residual E = RR^T - I which is then used as follows:
-     * R := R - 1/2 R E
-     */
-    template <typename Derived>
-    void approximateNearestOrthogonalMatrix(const Eigen::MatrixBase<Derived>& R)
-    {
-      Matrix3 E = R.transpose() * R;
-      E.diagonal().array() -= 1;
-      const_cast<Eigen::MatrixBase<Derived>&>(R) -= 0.5 * R * E;
-    }
-
-    /**
-     * normalize the quaternion, such that ||q|| == 1 and q.w() > 0
-     */
-    G2O_TYPES_SLAM3D_API Quaternion normalized(const Quaternion& q);
-    /**
-     * as above, but in-place
-     */
-    G2O_TYPES_SLAM3D_API Quaternion& normalize(Quaternion& q);
-
-    // functions to handle the rotation part
-    /**
-     * Rotation matrix -> Euler angles (roll, pitch, yaw)
-     */
-    G2O_TYPES_SLAM3D_API Vector3 toEuler(const Matrix3& R);
-    /**
-     * Euler angles (roll, pitch, yaw) -> Rotation matrix
-     */
-    G2O_TYPES_SLAM3D_API Matrix3 fromEuler(const Vector3& v);
-    /**
-     * Rotation matrix -> (qx qy, qz)
-     */
-    G2O_TYPES_SLAM3D_API Vector3 toCompactQuaternion(const Matrix3& R);
-    /**
-     * (qx qy, qz) -> Rotation matrix, whereas (qx, qy, qz) are assumed to be
-     * part of a quaternion which was normalized with the function above.
-     */
-    G2O_TYPES_SLAM3D_API Matrix3 fromCompactQuaternion(const Vector3& v);
-
-    // functions to handle the toVector of the whole transformations
-    /**
-     * Isometry3 -> (x, y, z, qx, qy, qz)
-     */
-    G2O_TYPES_SLAM3D_API Vector6 toVectorMQT(const Isometry3& t);
-    /**
-     * Isometry3 -> (x, y, z, roll, pitch, yaw)
-     */
-    G2O_TYPES_SLAM3D_API Vector6 toVectorET(const Isometry3& t);
-    /**
-     * Isometry3 -> (x, y, z, qx, qy, qz, qw)
-     */
-    G2O_TYPES_SLAM3D_API Vector7 toVectorQT(const Isometry3& t);
-
-    /**
-     * (x, y, z, qx, qy, qz) -> Isometry3
-     */
-    G2O_TYPES_SLAM3D_API Isometry3 fromVectorMQT(const Vector6& v);
-    /**
-     * (x, y, z, roll, pitch, yaw) -> Isometry3
-     */
-    G2O_TYPES_SLAM3D_API Isometry3 fromVectorET(const Vector6& v);
-    /**
-     * (x, y, z, qx, qy, qz, qw) -> Isometry3
-     */
-    G2O_TYPES_SLAM3D_API Isometry3 fromVectorQT(const Vector7& v);
-
-    /**
-     * convert an Isometry3 to the old SE3Quat class
-     */
-    G2O_TYPES_SLAM3D_API SE3Quat toSE3Quat(const Isometry3& t);
-    /**
-     * convert from an old SE3Quat into Isometry3
-     */
-    G2O_TYPES_SLAM3D_API Isometry3 fromSE3Quat(const SE3Quat& t);
-
-  } // end namespace internal
-} // end namespace g2o
-
-#endif
diff --git a/g2o/types/slam3d/parameter_camera.cpp b/g2o/types/slam3d/parameter_camera.cpp
deleted file mode 100644
index 2c7cea95..00000000
--- a/g2o/types/slam3d/parameter_camera.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "parameter_camera.h"
-#include "isometry3d_gradients.h"
-#include "isometry3d_mappings.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-using namespace std;
-
-namespace g2o {
-
-  ParameterCamera::ParameterCamera(){
-    setId(-1);
-    setKcam(1,1,0.5,0.5);
-    setOffset();
-  }
-
-  void ParameterCamera::setOffset(const Isometry3& offset_){
-    ParameterSE3Offset::setOffset(offset_);
-    _Kcam_inverseOffsetR = _Kcam * inverseOffset().rotation();
-  }
-
-  void ParameterCamera::setKcam(number_t fx, number_t fy, number_t cx, number_t cy){
-    _Kcam.setZero();
-    _Kcam(0,0) = fx;
-    _Kcam(1,1) = fy;
-    _Kcam(0,2) = cx;
-    _Kcam(1,2) = cy;
-    _Kcam(2,2) = 1.0;
-    _invKcam = _Kcam.inverse();
-    _Kcam_inverseOffsetR = _Kcam * inverseOffset().rotation();
-  }
-
-
-  bool ParameterCamera::read(std::istream& is) {
-    Vector7 off;
-    internal::readVector(is, off);
-    // normalize the quaternion to recover numerical precision lost by storing as human readable text
-    Vector4::MapType(off.data()+3).normalize();
-    setOffset(internal::fromVectorQT(off));
-    number_t fx,fy,cx,cy;
-    is >> fx >> fy >> cx >> cy;
-    setKcam(fx,fy,cx,cy);
-    return is.good();
-  }
-
-  bool ParameterCamera::write(std::ostream& os) const {
-    internal::writeVector(os, internal::toVectorQT(_offset));
-    os << _Kcam(0,0) << " ";
-    os << _Kcam(1,1) << " ";
-    os << _Kcam(0,2) << " ";
-    os << _Kcam(1,2) << " ";
-    return os.good();
-  }
-
-  bool CacheCamera::resolveDependancies(){
-    if  (!CacheSE3Offset::resolveDependancies())
-      return false;
-    params = dynamic_cast<ParameterCamera*>(_parameters[0]);
-    return params != 0;
-  }
-
-  void CacheCamera::updateImpl(){
-    CacheSE3Offset::updateImpl();
-    _w2i.matrix().topLeftCorner<3,4>() = params->Kcam() * w2n().matrix().topLeftCorner<3,4>();
-  }
-
-#ifdef G2O_HAVE_OPENGL
-
-  CacheCameraDrawAction::CacheCameraDrawAction(): DrawAction(typeid(CacheCamera).name()){
-    _previousParams = (DrawAction::Parameters*)0x42;
-    refreshPropertyPtrs(0);
-  }
-
-
-  bool CacheCameraDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (! DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _cameraZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::CAMERA_Z", .05f);
-      _cameraSide = _previousParams->makeProperty<FloatProperty>(_typeName + "::CAMERA_SIDE", .05f);
-
-    } else {
-      _cameraZ = 0;
-      _cameraSide = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* CacheCameraDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                 HyperGraphElementAction::Parameters* params){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    CacheCamera* that = static_cast<CacheCamera*>(element);
-    refreshPropertyPtrs(params);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    glPushAttrib(GL_COLOR);
-    glColor3f(POSE_PARAMETER_COLOR);
-    glPushMatrix();
-    glMultMatrixd(that->camParams()->offset().cast<double>().data());
-    glRotatef(180.0f, 0.0f, 1.0f, 0.0f);
-    opengl::drawPyramid(_cameraSide->value(), _cameraZ->value());
-    glPopMatrix();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d/parameter_camera.h b/g2o/types/slam3d/parameter_camera.h
deleted file mode 100644
index aa6ad19e..00000000
--- a/g2o/types/slam3d/parameter_camera.h
+++ /dev/null
@@ -1,87 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_CAMERA_PARAMETERS_H_
-#define G2O_CAMERA_PARAMETERS_H_
-
-#include "g2o/core/hyper_graph_action.h"
-#include "parameter_se3_offset.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-  /**
-   * \brief parameters for a camera
-   */
-  class G2O_TYPES_SLAM3D_API ParameterCamera: public ParameterSE3Offset {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      ParameterCamera();
-      void setKcam(number_t fx, number_t fy, number_t cx, number_t cy);
-      void setOffset(const Isometry3& offset_ = Isometry3::Identity());
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      const Matrix3& Kcam() const { return _Kcam;}
-      const Matrix3& invKcam() const { return _invKcam;}
-      const Matrix3& Kcam_inverseOffsetR() const { return _Kcam_inverseOffsetR;}
-
-    protected:
-      Matrix3 _Kcam;
-      Matrix3 _invKcam;
-      Matrix3 _Kcam_inverseOffsetR;
-  };
-
-  class G2O_TYPES_SLAM3D_API CacheCamera: public CacheSE3Offset {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    //! parameters of the camera
-    const ParameterCamera* camParams() const {return params;}
-    //! return the world to image transform
-    const Affine3& w2i() const {return _w2i;}
-
-  protected:
-    virtual void updateImpl();
-    virtual bool resolveDependancies();
-    Affine3 _w2i; ///< world to image transform
-    ParameterCamera* params;
-  };
-
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM3D_API CacheCameraDrawAction: public DrawAction{
-    public:
-      CacheCameraDrawAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_ );
-    protected:
-      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-      FloatProperty* _cameraZ, *_cameraSide;
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d/parameter_se3_offset.cpp b/g2o/types/slam3d/parameter_se3_offset.cpp
deleted file mode 100644
index 9667195b..00000000
--- a/g2o/types/slam3d/parameter_se3_offset.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "parameter_se3_offset.h"
-#include "vertex_se3.h"
-#include "isometry3d_gradients.h"
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-namespace g2o {
-
-  ParameterSE3Offset::ParameterSE3Offset(){
-    setOffset();
-  }
-
-  void ParameterSE3Offset::setOffset(const Isometry3& offset_){
-    _offset = offset_;
-    _inverseOffset = _offset.inverse();
-  }
-
-  bool ParameterSE3Offset::read(std::istream& is) {
-    Vector7 off;
-    bool state = internal::readVector(is, off);
-    // normalize the quaternion to recover numerical precision lost by storing as human readable text
-    Vector4::MapType(off.data()+3).normalize();
-    setOffset(internal::fromVectorQT(off));
-    return state;
-  }
-
-  bool ParameterSE3Offset::write(std::ostream& os) const {
-    return internal::writeVector(os, internal::toVectorQT(_offset));
-  }
-
-  CacheSE3Offset::CacheSE3Offset() :
-    Cache(),
-    _offsetParam(0)
-  {
-  }
-
-  bool CacheSE3Offset::resolveDependancies(){
-    _offsetParam = dynamic_cast <ParameterSE3Offset*> (_parameters[0]);
-    return _offsetParam != 0;
-  }
-
-  void CacheSE3Offset::updateImpl(){
-    const VertexSE3* v = static_cast<const VertexSE3*>(vertex());
-    _n2w = v->estimate() * _offsetParam->offset();
-    _w2n = _n2w.inverse();
-    _w2l = v->estimate().inverse();
-  }
-
-  void CacheSE3Offset::setOffsetParam(ParameterSE3Offset* offsetParam)
-  {
-    _offsetParam = offsetParam;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  CacheSE3OffsetDrawAction::CacheSE3OffsetDrawAction(): DrawAction(typeid(CacheSE3Offset).name()){
-    _previousParams = (DrawAction::Parameters*)0x42;
-    refreshPropertyPtrs(0);
-  }
-
-
-  bool CacheSE3OffsetDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (! DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _cubeSide = _previousParams->makeProperty<FloatProperty>(_typeName + "::CUBE_SIDE", .05f);
-    } else {
-      _cubeSide = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* CacheSE3OffsetDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    CacheSE3Offset* that = static_cast<CacheSE3Offset*>(element);
-    refreshPropertyPtrs(params_);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-    float cs = _cubeSide ? _cubeSide->value() : 1.0f;
-    glPushAttrib(GL_COLOR);
-    glColor3f(POSE_PARAMETER_COLOR);
-    glPushMatrix();
-    glMultMatrixd(that->offsetParam()->offset().cast<double>().data());
-    opengl::drawBox(cs,cs,cs);
-    glPopMatrix();
-    glPopAttrib();
-    return this;
-  }
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam3d/parameter_se3_offset.h b/g2o/types/slam3d/parameter_se3_offset.h
deleted file mode 100644
index 32945f66..00000000
--- a/g2o/types/slam3d/parameter_se3_offset.h
+++ /dev/null
@@ -1,109 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_SE3_OFFSET_PARAMETERS_H_
-#define G2O_VERTEX_SE3_OFFSET_PARAMETERS_H_
-
-
-#include "g2o/core/hyper_graph_action.h"
-#include "g2o/core/cache.h"
-#include "g2o_types_slam3d_api.h"
-
-
-namespace g2o {
-
-
-  /**
-   * \brief offset for an SE3
-   */
-  class G2O_TYPES_SLAM3D_API ParameterSE3Offset: public Parameter
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      ParameterSE3Offset();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      /**
-       * update the offset to a new value.
-       * re-calculates the different representations, e.g., the rotation matrix
-       */
-      void setOffset(const Isometry3& offset_=Isometry3::Identity());
-
-      //! rotation of the offset as 3x3 rotation matrix
-      const Isometry3& offset() const { return _offset;}
-
-      //! rotation of the inverse offset as 3x3 rotation matrix
-      const Isometry3& inverseOffset() const { return _inverseOffset;}
-
-    protected:
-      Isometry3 _offset;
-      Isometry3 _inverseOffset;
-  };
-
-  /**
-   * \brief caching the offset related to a vertex
-   */
-  class G2O_TYPES_SLAM3D_API CacheSE3Offset: public Cache {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      CacheSE3Offset();
-      virtual void updateImpl();
-
-      const ParameterSE3Offset* offsetParam() const { return _offsetParam;}
-      void setOffsetParam(ParameterSE3Offset* offsetParam);
-
-      const Isometry3& w2n() const { return _w2n;}
-      const Isometry3& n2w() const { return _n2w;}
-      const Isometry3& w2l() const { return _w2l;}
-
-    protected:
-      ParameterSE3Offset* _offsetParam; ///< the parameter connected to the cache
-      Isometry3 _w2n;
-      Isometry3 _n2w;
-      Isometry3 _w2l;
-
-    protected:
-      virtual bool resolveDependancies();
-  };
-
-
-#ifdef G2O_HAVE_OPENGL
-  class G2O_TYPES_SLAM3D_API CacheSE3OffsetDrawAction: public DrawAction{
-    public:
-      CacheSE3OffsetDrawAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-          HyperGraphElementAction::Parameters* params_ );
-    protected:
-      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-      FloatProperty* _cubeSide;
-  };
-#endif
-
-}
-
-#endif
diff --git a/g2o/types/slam3d/parameter_stereo_camera.cpp b/g2o/types/slam3d/parameter_stereo_camera.cpp
deleted file mode 100644
index c0225db0..00000000
--- a/g2o/types/slam3d/parameter_stereo_camera.cpp
+++ /dev/null
@@ -1,47 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "parameter_stereo_camera.h"
-
-#include "g2o/stuff/misc.h"
-
-namespace g2o {
-
-ParameterStereoCamera::ParameterStereoCamera() : ParameterCamera(), _baseline(cst(0.075)) {}
-
-bool ParameterStereoCamera::read(std::istream& is) {
-  bool state = ParameterCamera::read(is);
-  is >> _baseline;
-  return is.good() && state;
-}
-
-bool ParameterStereoCamera::write(std::ostream& os) const {
-  bool state = ParameterCamera::write(os);
-  os << baseline() << " ";
-  return state && os.good();
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d/parameter_stereo_camera.h b/g2o/types/slam3d/parameter_stereo_camera.h
deleted file mode 100644
index d248bcfc..00000000
--- a/g2o/types/slam3d/parameter_stereo_camera.h
+++ /dev/null
@@ -1,54 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_STEREO_CAMERA_PARAMETERS_H_
-#define G2O_STEREO_CAMERA_PARAMETERS_H_
-
-#include "g2o/core/hyper_graph_action.h"
-#include "g2o_types_slam3d_api.h"
-#include "parameter_camera.h"
-
-namespace g2o {
-/**
- * \brief parameters for a camera
- */
-class G2O_TYPES_SLAM3D_API ParameterStereoCamera : public ParameterCamera {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-  ParameterStereoCamera();
-
-  virtual bool read(std::istream& is);
-  virtual bool write(std::ostream& os) const;
-
-  void setBaseline(number_t baseline_) { _baseline = baseline_; }
-  number_t baseline() const { return _baseline; }
-
- protected:
-  number_t _baseline;
-};
-}   // namespace g2o
-
-#endif
diff --git a/g2o/types/slam3d/se3_ops.h b/g2o/types/slam3d/se3_ops.h
deleted file mode 100644
index 46940839..00000000
--- a/g2o/types/slam3d/se3_ops.h
+++ /dev/null
@@ -1,48 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SE3_OPS_H
-#define G2O_SE3_OPS_H
-
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-
-  inline G2O_TYPES_SLAM3D_API Matrix3 skew(const Vector3&v);
-  inline G2O_TYPES_SLAM3D_API Vector3 deltaR(const Matrix3& R);
-  inline G2O_TYPES_SLAM3D_API Vector2 project(const Vector3&);
-  inline G2O_TYPES_SLAM3D_API Vector3 project(const Vector4&);
-  inline G2O_TYPES_SLAM3D_API Vector3 unproject(const Vector2&);
-  inline G2O_TYPES_SLAM3D_API Vector4 unproject(const Vector3&);
-
-  #include "se3_ops.hpp"
-
-}
-
-#endif //MATH_STUFF
diff --git a/g2o/types/slam3d/se3_ops.hpp b/g2o/types/slam3d/se3_ops.hpp
deleted file mode 100644
index 79e42ca9..00000000
--- a/g2o/types/slam3d/se3_ops.hpp
+++ /dev/null
@@ -1,85 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-  Matrix3 skew(const Vector3&v)
-  {
-    Matrix3 m;
-    m.fill(0.);
-    m(0,1)  = -v(2);
-    m(0,2)  =  v(1);
-    m(1,2)  = -v(0);
-    m(1,0)  =  v(2);
-    m(2,0) = -v(1);
-    m(2,1) = v(0);
-    return m;
-  }
-
-  Vector3 deltaR(const Matrix3& R)
-  {
-    Vector3 v;
-    v(0)=R(2,1)-R(1,2);
-    v(1)=R(0,2)-R(2,0);
-    v(2)=R(1,0)-R(0,1);
-    return v;
-  }
-
-  Vector2 project(const Vector3& v)
-  {
-    Vector2 res;
-    res(0) = v(0)/v(2);
-    res(1) = v(1)/v(2);
-    return res;
-  }
-
-  Vector3 project(const Vector4& v)
-  {
-    Vector3 res;
-    res(0) = v(0)/v(3);
-    res(1) = v(1)/v(3);
-    res(2) = v(2)/v(3);
-    return res;
-  }
-
-  Vector3 unproject(const Vector2& v)
-  {
-    Vector3 res;
-    res(0) = v(0);
-    res(1) = v(1);
-    res(2) = 1;
-    return res;
-  }
-
-  Vector4 unproject(const Vector3& v)
-  {
-    Vector4 res;
-    res(0) = v(0);
-    res(1) = v(1);
-    res(2) = v(2);
-    res(3) = 1;
-    return res;
-  }
-
-
diff --git a/g2o/types/slam3d/se3quat.h b/g2o/types/slam3d/se3quat.h
deleted file mode 100644
index 705cebf4..00000000
--- a/g2o/types/slam3d/se3quat.h
+++ /dev/null
@@ -1,310 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 H. Strasdat
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_SE3QUAT_H_
-#define G2O_SE3QUAT_H_
-
-#include "se3_ops.h"
-#include "g2o/stuff/misc.h"
-
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM3D_API SE3Quat {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-    protected:
-
-      Quaternion _r;
-      Vector3 _t;
-
-    public:
-      SE3Quat(){
-        _r.setIdentity();
-        _t.setZero();
-      }
-
-      SE3Quat(const Matrix3& R, const Vector3& t):_r(Quaternion(R)),_t(t){ 
-        normalizeRotation();
-      }
-
-      SE3Quat(const Quaternion& q, const Vector3& t):_r(q),_t(t){
-        normalizeRotation();
-      }
-
-      /**
-       * templaized constructor which allows v to be an arbitrary Eigen Vector type, e.g., Vector6 or Map<Vector6>
-       */
-      template <typename Derived>
-        explicit SE3Quat(const Eigen::MatrixBase<Derived>& v)
-        {
-          assert((v.size() == 6 || v.size() == 7) && "Vector dimension does not match");
-          if (v.size() == 6) {
-            for (int i=0; i<3; i++){
-              _t[i]=v[i];
-              _r.coeffs()(i)=v[i+3];
-            }
-            _r.w() = 0.; // recover the positive w
-            if (_r.norm()>1.){
-              _r.normalize();
-            } else {
-              number_t w2= cst(1.)-_r.squaredNorm();
-              _r.w()= (w2<cst(0.)) ? cst(0.) : std::sqrt(w2);
-            }
-          }
-          else if (v.size() == 7) {
-            int idx = 0;
-            for (int i=0; i<3; ++i, ++idx)
-              _t(i) = v(idx);
-            for (int i=0; i<4; ++i, ++idx)
-              _r.coeffs()(i) = v(idx);
-            normalizeRotation();
-          }
-        }
-
-      inline const Vector3& translation() const {return _t;}
-
-      inline void setTranslation(const Vector3& t_) {_t = t_;}
-
-      inline const Quaternion& rotation() const {return _r;}
-
-      void setRotation(const Quaternion& r_) {_r=r_;}
-
-      inline SE3Quat operator* (const SE3Quat& tr2) const{
-        SE3Quat result(*this);
-        result._t += _r*tr2._t;
-        result._r*=tr2._r;
-        result.normalizeRotation();
-        return result;
-      }
-
-      inline SE3Quat& operator*= (const SE3Quat& tr2){
-        _t+=_r*tr2._t;
-        _r*=tr2._r;
-        normalizeRotation();
-        return *this;
-      }
-
-      inline Vector3 operator* (const Vector3& v) const {
-        return _t+_r*v;
-      }
-
-      inline SE3Quat inverse() const{
-        SE3Quat ret;
-        ret._r=_r.conjugate();
-        ret._t=ret._r*(_t*-cst(1.));
-        return ret;
-      }
-
-      inline number_t operator [](int i) const {
-        assert(i<7);
-        if (i<3)
-          return _t[i];
-        return _r.coeffs()[i-3];
-      }
-
-
-      inline Vector7 toVector() const{
-        Vector7 v;
-        v[0]=_t(0);
-        v[1]=_t(1);
-        v[2]=_t(2);
-        v[3]=_r.x();
-        v[4]=_r.y();
-        v[5]=_r.z();
-        v[6]=_r.w();
-        return v;
-      }
-
-      inline void fromVector(const Vector7& v){
-        _r=Quaternion(v[6], v[3], v[4], v[5]);
-        _t=Vector3(v[0], v[1], v[2]);
-      }
-
-      inline Vector6 toMinimalVector() const{
-        Vector6 v;
-        v[0]=_t(0);
-        v[1]=_t(1);
-        v[2]=_t(2);
-        v[3]=_r.x();
-        v[4]=_r.y();
-        v[5]=_r.z();
-        return v;
-      }
-
-      inline void fromMinimalVector(const Vector6& v){
-        number_t w = cst(1.)-v[3]*v[3]-v[4]*v[4]-v[5]*v[5];
-        if (w>0){
-          _r=Quaternion(std::sqrt(w), v[3], v[4], v[5]);
-        } else {
-          _r=Quaternion(0, -v[3], -v[4], -v[5]);
-        }
-        _t=Vector3(v[0], v[1], v[2]);
-      }
-
-
-
-      Vector6 log() const {
-        Vector6 res;
-        Matrix3 _R = _r.toRotationMatrix();
-        number_t d = cst(0.5)*(_R(0,0)+_R(1,1)+_R(2,2)-1);
-        Vector3 omega;
-        Vector3 upsilon;
-
-
-        Vector3 dR = deltaR(_R);
-        Matrix3 V_inv;
-
-        if (std::abs(d)>cst(0.99999))
-        {
-
-          omega=0.5*dR;
-          Matrix3 Omega = skew(omega);
-          V_inv = Matrix3::Identity()- cst(0.5)*Omega + (cst(1.)/ cst(12.))*(Omega*Omega);
-        }
-        else
-        {
-          number_t theta = std::acos(d);
-          omega = theta/(2*std::sqrt(1-d*d))*dR;
-          Matrix3 Omega = skew(omega);
-          V_inv = ( Matrix3::Identity() - cst(0.5)*Omega
-              + ( 1-theta/(2*std::tan(theta/2)))/(theta*theta)*(Omega*Omega) );
-        }
-
-        upsilon = V_inv*_t;
-        for (int i=0; i<3;i++){
-          res[i]=omega[i];
-        }
-        for (int i=0; i<3;i++){
-          res[i+3]=upsilon[i];
-        }
-
-        return res;
-
-      }
-
-      Vector3 map(const Vector3 & xyz) const
-      {
-        return _r*xyz + _t;
-      }
-
-
-      static SE3Quat exp(const Vector6 & update)
-      {
-        Vector3 omega;
-        for (int i=0; i<3; i++)
-          omega[i]=update[i];
-        Vector3 upsilon;
-        for (int i=0; i<3; i++)
-          upsilon[i]=update[i+3];
-
-        number_t theta = omega.norm();
-        Matrix3 Omega = skew(omega);
-
-        Matrix3 R;
-        Matrix3 V;
-        if (theta<cst(0.00001))
-        {
-          Matrix3 Omega2 = Omega*Omega;
-
-          R = (Matrix3::Identity()
-              + Omega
-              + cst(0.5) * Omega2);
-
-          V = (Matrix3::Identity()
-              + cst(0.5) * Omega
-              + cst(1.) / cst(6.) * Omega2);
-        }
-        else
-        {
-          Matrix3 Omega2 = Omega*Omega;
-
-          R = (Matrix3::Identity()
-              + std::sin(theta)/theta *Omega
-              + (1-std::cos(theta))/(theta*theta)*Omega2);
-
-          V = (Matrix3::Identity()
-              + (1-std::cos(theta))/(theta*theta)*Omega
-              + (theta-std::sin(theta))/(std::pow(theta,3))*Omega2);
-        }
-        return SE3Quat(Quaternion(R),V*upsilon);
-      }
-
-      Eigen::Matrix<number_t, 6, 6, Eigen::ColMajor> adj() const
-      {
-        Matrix3 R = _r.toRotationMatrix();
-        Eigen::Matrix<number_t, 6, 6, Eigen::ColMajor> res;
-        res.block(0,0,3,3) = R;
-        res.block(3,3,3,3) = R;
-        res.block(3,0,3,3) = skew(_t)*R;
-        res.block(0,3,3,3) = Matrix3::Zero(3,3);
-        return res;
-      }
-
-      Eigen::Matrix<number_t,4,4,Eigen::ColMajor> to_homogeneous_matrix() const
-      {
-        Eigen::Matrix<number_t,4,4,Eigen::ColMajor> homogeneous_matrix;
-        homogeneous_matrix.setIdentity();
-        homogeneous_matrix.block(0,0,3,3) = _r.toRotationMatrix();
-        homogeneous_matrix.col(3).head(3) = translation();
-
-        return homogeneous_matrix;
-      }
-
-      void normalizeRotation(){
-        if (_r.w()<0){
-          _r.coeffs() *= -1;
-        }
-        _r.normalize();
-      }
-
-      /**
-       * cast SE3Quat into an Isometry3
-       */
-      operator Isometry3() const
-      {
-        Isometry3 result = (Isometry3) rotation();
-        result.translation() = translation();
-        return result;
-      }
-  };
-
-  inline std::ostream& operator <<(std::ostream& out_str, const SE3Quat& se3)
-  {
-    out_str << se3.to_homogeneous_matrix()  << std::endl;
-    return out_str;
-  }
-
-  //G2O_TYPES_SLAM3D_API Quaternion euler_to_quat(number_t yaw, number_t pitch, number_t roll);
-  //G2O_TYPES_SLAM3D_API void quat_to_euler(const Quaternion& q, number_t& yaw, number_t& pitch, number_t& roll);
-  //G2O_TYPES_SLAM3D_API void jac_quat3_euler3(Eigen::Matrix<number_t, 6, 6, Eigen::ColMajor>& J, const SE3Quat& t);
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d/types_slam3d.cpp b/g2o/types/slam3d/types_slam3d.cpp
deleted file mode 100644
index 4fb14299..00000000
--- a/g2o/types/slam3d/types_slam3d.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_slam3d.h"
-#include "g2o/core/factory.h"
-#include "g2o/stuff/macros.h"
-
-#include <iostream>
-
-namespace g2o {
-
-  G2O_REGISTER_TYPE_GROUP(slam3d);
-
-  G2O_REGISTER_TYPE(VERTEX_SE3:QUAT, VertexSE3);
-  G2O_REGISTER_TYPE(EDGE_SE3:QUAT, EdgeSE3);
-  G2O_REGISTER_TYPE(VERTEX_TRACKXYZ, VertexPointXYZ);
-
-  G2O_REGISTER_TYPE(PARAMS_SE3OFFSET, ParameterSE3Offset);
-  G2O_REGISTER_TYPE(EDGE_SE3_TRACKXYZ, EdgeSE3PointXYZ);
-  G2O_REGISTER_TYPE(EDGE_SE3_PRIOR, EdgeSE3Prior);
-  G2O_REGISTER_TYPE(EDGE_SE3_XYZ_PRIOR, EdgeSE3XYZPrior);
-  G2O_REGISTER_TYPE(CACHE_SE3_OFFSET, CacheSE3Offset);
-  G2O_REGISTER_TYPE(EDGE_SE3_OFFSET, EdgeSE3Offset);
-
-  G2O_REGISTER_TYPE(PARAMS_CAMERACALIB, ParameterCamera);
-  G2O_REGISTER_TYPE(PARAMS_STEREOCAMERACALIB, ParameterStereoCamera);
-  G2O_REGISTER_TYPE(CACHE_CAMERA, CacheCamera);
-  G2O_REGISTER_TYPE(EDGE_PROJECT_DISPARITY, EdgeSE3PointXYZDisparity);
-  G2O_REGISTER_TYPE(EDGE_PROJECT_DEPTH, EdgeSE3PointXYZDepth);
-
-  G2O_REGISTER_TYPE(EDGE_POINTXYZ, EdgePointXYZ);
-  G2O_REGISTER_TYPE(EDGE_POINTXYZ_PRIOR, EdgeXYZPrior);
-
-  G2O_REGISTER_TYPE(EDGE_SE3_LOTSOF_XYZ, EdgeSE3LotsOfXYZ)
-
-  /*********** ACTIONS ************/
-  G2O_REGISTER_ACTION(VertexSE3WriteGnuplotAction);
-  G2O_REGISTER_ACTION(VertexPointXYZWriteGnuplotAction);
-  G2O_REGISTER_ACTION(EdgeSE3WriteGnuplotAction);
-
-#ifdef G2O_HAVE_OPENGL
-  G2O_REGISTER_ACTION(VertexPointXYZDrawAction);
-  G2O_REGISTER_ACTION(VertexSE3DrawAction);
-  G2O_REGISTER_ACTION(EdgeSE3DrawAction);
-  G2O_REGISTER_ACTION(EdgeSE3PointXYZDrawAction);
-  G2O_REGISTER_ACTION(EdgeProjectDisparityDrawAction);
-  G2O_REGISTER_ACTION(CacheCameraDrawAction);
-  G2O_REGISTER_ACTION(CacheSE3OffsetDrawAction);
-#endif
-
-} // end namespace
diff --git a/g2o/types/slam3d/types_slam3d.h b/g2o/types/slam3d/types_slam3d.h
deleted file mode 100644
index 72b03406..00000000
--- a/g2o/types/slam3d/types_slam3d.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_SLAM3D_
-#define G2O_TYPES_SLAM3D_
-
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/core/hyper_graph_action.h"
-
-#define THREE_D_TYPES_ANALYTIC_JACOBIAN
-
-#include "vertex_se3.h"
-#include "edge_se3.h"
-#include "vertex_pointxyz.h"
-
-#include "parameter_se3_offset.h"
-#include "edge_se3_pointxyz.h"
-#include "edge_se3_offset.h"
-
-#include "parameter_camera.h"
-#include "parameter_stereo_camera.h"
-#include "edge_se3_pointxyz_disparity.h"
-#include "edge_se3_pointxyz_depth.h"
-#include "edge_se3_prior.h"
-#include "edge_se3_xyzprior.h"
-
-#include "edge_pointxyz.h"
-#include "edge_xyz_prior.h"
-
-#include "edge_se3_lotsofxyz.h"
-#endif
diff --git a/g2o/types/slam3d/vertex_pointxyz.cpp b/g2o/types/slam3d/vertex_pointxyz.cpp
deleted file mode 100644
index 00f80733..00000000
--- a/g2o/types/slam3d/vertex_pointxyz.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_pointxyz.h"
-#include <stdio.h>
-
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_primitives.h"
-#include "g2o/stuff/opengl_wrapper.h"
-#endif
-
-#include <typeinfo>
-
-namespace g2o {
-
-bool VertexPointXYZ::read(std::istream& is) { return internal::readVector(is, _estimate); }
-
-bool VertexPointXYZ::write(std::ostream& os) const { return internal::writeVector(os, estimate()); }
-
-#ifdef G2O_HAVE_OPENGL
-VertexPointXYZDrawAction::VertexPointXYZDrawAction() : DrawAction(typeid(VertexPointXYZ).name()), _pointSize(nullptr) {}
-
-bool VertexPointXYZDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
-  if (!DrawAction::refreshPropertyPtrs(params_)) return false;
-  if (_previousParams) {
-    _pointSize = _previousParams->makeProperty<FloatProperty>(_typeName + "::POINT_SIZE", 1.);
-  } else {
-    _pointSize = nullptr;
-  }
-  return true;
-}
-
-  HyperGraphElementAction* VertexPointXYZDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                     HyperGraphElementAction::Parameters* params ){
-
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    initializeDrawActionsCache();
-    refreshPropertyPtrs(params);
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-    VertexPointXYZ* that = static_cast<VertexPointXYZ*>(element);
-
-
-    glPushMatrix();
-    glPushAttrib(GL_ENABLE_BIT | GL_POINT_BIT);
-    glDisable(GL_LIGHTING);
-    glColor3f(LANDMARK_VERTEX_COLOR);
-    float ps = _pointSize ? _pointSize->value() :  1.f;
-    glTranslatef((float)that->estimate()(0),(float)that->estimate()(1),(float)that->estimate()(2));
-    opengl::drawPoint(ps);
-    glPopAttrib();
-    drawCache(that->cacheContainer(), params);
-    drawUserData(that->userData(), params);
-    glPopMatrix();
-    return this;
-  }
-#endif
-
-  VertexPointXYZWriteGnuplotAction::VertexPointXYZWriteGnuplotAction() :
-    WriteGnuplotAction(typeid(VertexPointXYZ).name())
-  {
-  }
-
-  HyperGraphElementAction* VertexPointXYZWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_ )
-  {
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    VertexPointXYZ* v = static_cast<VertexPointXYZ*>(element);
-    *(params->os) << v->estimate().x() << " " << v->estimate().y() << " " << v->estimate().z() << " " << std::endl;
-    return this;
-  }
-
-}
-
diff --git a/g2o/types/slam3d/vertex_pointxyz.h b/g2o/types/slam3d/vertex_pointxyz.h
deleted file mode 100644
index 352c0b55..00000000
--- a/g2o/types/slam3d/vertex_pointxyz.h
+++ /dev/null
@@ -1,111 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_TRACKXYZ_H_
-#define G2O_VERTEX_TRACKXYZ_H_
-
-#include "g2o_types_slam3d_api.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-
-namespace g2o {
-  /**
-   * \brief Vertex for a tracked point in space
-   */
-  class G2O_TYPES_SLAM3D_API VertexPointXYZ : public BaseVertex<3, Vector3>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexPointXYZ() {}
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void setToOriginImpl() { _estimate.fill(0.); }
-
-      virtual void oplusImpl(const number_t* update_) {
-        Eigen::Map<const Vector3> update(update_);
-        _estimate += update;
-      }
-
-      virtual bool setEstimateDataImpl(const number_t* est){
-        Eigen::Map<const Vector3> estMap(est);
-        _estimate = estMap;
-        return true;
-      }
-
-      virtual bool getEstimateData(number_t* est) const{
-        Eigen::Map<Vector3> estMap(est);
-        estMap = _estimate;
-        return true;
-      }
-
-      virtual int estimateDimension() const {
-        return Dimension;
-      }
-
-      virtual bool setMinimalEstimateDataImpl(const number_t* est){
-        _estimate = Eigen::Map<const Vector3>(est);
-        return true;
-      }
-
-      virtual bool getMinimalEstimateData(number_t* est) const{
-        Eigen::Map<Vector3> v(est);
-        v = _estimate;
-        return true;
-      }
-
-      virtual int minimalEstimateDimension() const {
-        return Dimension;
-      }
-
-  };
-
-  class G2O_TYPES_SLAM3D_API VertexPointXYZWriteGnuplotAction: public WriteGnuplotAction
-  {
-    public:
-      VertexPointXYZWriteGnuplotAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_ );
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  /**
-   * \brief visualize a 3D point
-   */
-  class VertexPointXYZDrawAction: public DrawAction{
-    public:
-      VertexPointXYZDrawAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-          HyperGraphElementAction::Parameters* params_);
-
-
-    protected:
-      FloatProperty *_pointSize;
-      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-  };
-#endif
-
-}
-#endif
diff --git a/g2o/types/slam3d/vertex_se3.cpp b/g2o/types/slam3d/vertex_se3.cpp
deleted file mode 100644
index f707e2e1..00000000
--- a/g2o/types/slam3d/vertex_se3.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_se3.h"
-#include "g2o/core/factory.h"
-#ifdef G2O_HAVE_OPENGL
-#include "g2o/stuff/opengl_wrapper.h"
-#include "g2o/stuff/opengl_primitives.h"
-#endif
-
-#include <iostream>
-#include "g2o/core/cache.h"
-
-using namespace Eigen;
-
-namespace g2o {
-
-  VertexSE3::VertexSE3() :
-    BaseVertex<6, Isometry3>(),
-    _numOplusCalls(0)
-  {
-    setToOriginImpl();
-    updateCache();
-  }
-
-  bool VertexSE3::read(std::istream& is)
-  {
-    Vector7 est;
-    bool state = internal::readVector(is, est);
-    setEstimate(internal::fromVectorQT(est));
-    return state;
-  }
-
-  bool VertexSE3::write(std::ostream& os) const
-  {
-    return internal::writeVector(os, internal::toVectorQT(estimate()));
-  }
-
-  VertexSE3WriteGnuplotAction::VertexSE3WriteGnuplotAction(): WriteGnuplotAction(typeid(VertexSE3).name()){}
-
-  HyperGraphElementAction* VertexSE3WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
-    if (!params->os){
-      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid os specified" << std::endl;
-      return nullptr;
-    }
-
-    VertexSE3* v =  static_cast<VertexSE3*>(element);
-    Vector6 est=internal::toVectorMQT(v->estimate());
-    for (int i=0; i<6; i++)
-      *(params->os) << est[i] << " ";
-    *(params->os) << std::endl;
-    return this;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  void drawTriangle(float xSize, float ySize){
-    Vector3F p[3];
-    glBegin(GL_TRIANGLES);
-    p[0] << 0., 0., 0.;
-    p[1] << -xSize, ySize, 0.;
-    p[2] << -xSize, -ySize, 0.;
-    for (int i = 1; i < 2; ++i) {
-      Vector3F normal = (p[i] - p[0]).cross(p[i+1] - p[0]);
-      glNormal3f(normal.x(), normal.y(), normal.z());
-      glVertex3f(p[0].x(), p[0].y(), p[0].z());
-      glVertex3f(p[i].x(), p[i].y(), p[i].z());
-      glVertex3f(p[i+1].x(), p[i+1].y(), p[i+1].z());
-    }
-    glEnd();
-  }
-
-  VertexSE3DrawAction::VertexSE3DrawAction()
-      : DrawAction(typeid(VertexSE3).name()), _triangleX(nullptr), _triangleY(nullptr) {
-    _cacheDrawActions = 0;
-  }
-
-  bool VertexSE3DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::TRIANGLE_X", .2f);
-      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::TRIANGLE_Y", .05f);
-    } else {
-      _triangleX = 0;
-      _triangleY = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexSE3DrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                 HyperGraphElementAction::Parameters* params_){
-    if (typeid(*element).name()!=_typeName)
-      return nullptr;
-    initializeDrawActionsCache();
-    refreshPropertyPtrs(params_);
-
-    if (! _previousParams)
-      return this;
-
-    if (_show && !_show->value())
-      return this;
-
-    VertexSE3* that = static_cast<VertexSE3*>(element);
-
-    glColor3f(POSE_VERTEX_COLOR);
-    glPushMatrix();
-    glMultMatrixd(that->estimate().matrix().cast<double>().eval().data());
-    opengl::drawArrow2D(_triangleX->value(), _triangleY->value(), _triangleX->value()*.3f);
-    drawCache(that->cacheContainer(), params_);
-    drawUserData(that->userData(), params_);
-    glPopMatrix();
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d/vertex_se3.h b/g2o/types/slam3d/vertex_se3.h
deleted file mode 100644
index 16339d00..00000000
--- a/g2o/types/slam3d/vertex_se3.h
+++ /dev/null
@@ -1,151 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_SE3_
-#define G2O_VERTEX_SE3_
-
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "isometry3d_mappings.h"
-#include "g2o_types_slam3d_api.h"
-
-namespace g2o {
-
-/**
- * \brief 3D pose Vertex, represented as an Isometry3
- *
- * 3D pose vertex, represented as an Isometry3, i.e., an affine transformation
- * which is constructed by only concatenating rotation and translation
- * matrices. Hence, no scaling or projection.  To avoid that the rotational
- * part of the Isometry3 gets numerically unstable we compute the nearest
- * orthogonal matrix after a large number of calls to the oplus method.
- * 
- * The parameterization for the increments constructed is a 6d vector
- * (x,y,z,qx,qy,qz) (note that we leave out the w part of the quaternion.
- */
-  class G2O_TYPES_SLAM3D_API VertexSE3 : public BaseVertex<6, Isometry3>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-      static const int orthogonalizeAfter = 1000; //< orthogonalize the rotation matrix after N updates
-
-      VertexSE3();
-
-      virtual void setToOriginImpl() {
-        _estimate = Isometry3::Identity();
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual bool setEstimateDataImpl(const number_t* est){
-        Eigen::Map<const Vector7> v(est);
-        _estimate=internal::fromVectorQT(v);
-        return true;
-      }
-
-      virtual bool getEstimateData(number_t* est) const{
-        Eigen::Map<Vector7> v(est);
-        v=internal::toVectorQT(_estimate);
-        return true;
-      }
-
-      virtual int estimateDimension() const {
-        return 7;
-      }
-
-      virtual bool setMinimalEstimateDataImpl(const number_t* est){
-        Eigen::Map<const Vector6> v(est);
-        _estimate = internal::fromVectorMQT(v);
-        return true;
-      }
-
-      virtual bool getMinimalEstimateData(number_t* est) const{
-        Eigen::Map<Vector6> v(est);
-        v = internal::toVectorMQT(_estimate);
-        return true;
-      }
-
-      virtual int minimalEstimateDimension() const {
-        return 6;
-      }
-
-      /**
-       * update the position of this vertex. The update is in the form
-       * (x,y,z,qx,qy,qz) whereas (x,y,z) represents the translational update
-       * and (qx,qy,qz) corresponds to the respective elements. The missing
-       * element qw of the quaternion is recovred by
-       * || (qw,qx,qy,qz) || == 1 => qw = sqrt(1 - || (qx,qy,qz) ||
-       */
-      virtual void oplusImpl(const number_t* update)
-      {
-        Eigen::Map<const Vector6> v(update);
-        Isometry3 increment = internal::fromVectorMQT(v);
-        _estimate = _estimate * increment;
-        if (++_numOplusCalls > orthogonalizeAfter) {
-          _numOplusCalls = 0;
-          internal::approximateNearestOrthogonalMatrix(_estimate.matrix().topLeftCorner<3,3>());
-        }
-      }
-
-      //! wrapper function to use the old SE3 type
-      SE3Quat G2O_ATTRIBUTE_DEPRECATED(estimateAsSE3Quat() const) { return internal::toSE3Quat(estimate());}
-      //! wrapper function to use the old SE3 type
-      void G2O_ATTRIBUTE_DEPRECATED(setEstimateFromSE3Quat(const SE3Quat& se3)) { setEstimate(internal::fromSE3Quat(se3));}
-
-    protected:
-      int _numOplusCalls;     ///< store how often opluse was called to trigger orthogonaliation of the rotation matrix
-  };
-
-  /**
-   * \brief write the vertex to some Gnuplot data file
-   */
-  class VertexSE3WriteGnuplotAction: public WriteGnuplotAction {
-    public:
-      VertexSE3WriteGnuplotAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-          HyperGraphElementAction::Parameters* params_ );
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  /**
-   * \brief visualize the 3D pose vertex
-   */
-  class G2O_TYPES_SLAM3D_API VertexSE3DrawAction: public DrawAction{
-    public:
-      VertexSE3DrawAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_);
-    protected:
-      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-      FloatProperty* _triangleX, *_triangleY;
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d_addons/CMakeLists.txt b/g2o/types/slam3d_addons/CMakeLists.txt
deleted file mode 100644
index b2691604..00000000
--- a/g2o/types/slam3d_addons/CMakeLists.txt
+++ /dev/null
@@ -1,38 +0,0 @@
-add_library(types_slam3d_addons ${G2O_LIB_TYPE}
-  vertex_se3_euler.cpp
-  vertex_se3_euler.h
-  edge_se3_euler.cpp
-  edge_se3_euler.h
-  vertex_plane.cpp
-  vertex_plane.h
-  edge_se3_plane_calib.cpp
-  edge_se3_plane_calib.h
-  line3d.cpp line3d.h
-  vertex_line3d.cpp vertex_line3d.h
-  edge_se3_line.cpp edge_se3_line.h
-  edge_plane.cpp edge_plane.h
-  edge_se3_calib.cpp edge_se3_calib.h
-  types_slam3d_addons.cpp
-  types_slam3d_addons.h
-)
-
-
-set_target_properties(types_slam3d_addons PROPERTIES OUTPUT_NAME ${LIB_PREFIX}types_slam3d_addons)
-if (APPLE)
-  set_target_properties(types_slam3d_addons PROPERTIES INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
-endif()
-target_link_libraries(types_slam3d_addons types_slam3d core)
-if(G2O_HAVE_OPENGL)
-  target_link_libraries(types_slam3d_addons ${OPENGL_gl_LIBRARY} )
-endif()
-
-install(TARGETS types_slam3d_addons
-  EXPORT ${G2O_TARGETS_EXPORT_NAME}
-  RUNTIME DESTINATION ${RUNTIME_DESTINATION}
-  LIBRARY DESTINATION ${LIBRARY_DESTINATION}
-  ARCHIVE DESTINATION ${ARCHIVE_DESTINATION}
-  INCLUDES DESTINATION ${INCLUDES_DESTINATION}
-)
-
-file(GLOB headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/*.hpp")
-install(FILES ${headers} DESTINATION ${INCLUDES_INSTALL_DIR}/types/slam3d_addons)
diff --git a/g2o/types/slam3d_addons/edge_plane.cpp b/g2o/types/slam3d_addons/edge_plane.cpp
deleted file mode 100644
index ae766280..00000000
--- a/g2o/types/slam3d_addons/edge_plane.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_plane.h"
-
-namespace g2o {
-using namespace Eigen;
-
-EdgePlane::EdgePlane() : BaseBinaryEdge<4, Vector4, VertexPlane, VertexPlane>() {
-  _information.setIdentity();
-  _error.setZero();
-}
-
-bool EdgePlane::read(std::istream& is) {
-  Vector4 v;
-  internal::readVector(is, v);
-  setMeasurement(v);
-  return readInformationMatrix(is);
-}
-
-bool EdgePlane::write(std::ostream& os) const {
-  internal::writeVector(os, measurement());
-  return writeInformationMatrix(os);
-}
-
-#if 0
-void EdgePlane::linearizeOplus()
-{
-    _jacobianOplusXi=-Matrix3::Identity();
-    _jacobianOplusXj= Matrix3::Identity();
-}
-#endif
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d_addons/edge_plane.h b/g2o/types/slam3d_addons/edge_plane.h
deleted file mode 100644
index 36b878ab..00000000
--- a/g2o/types/slam3d_addons/edge_plane.h
+++ /dev/null
@@ -1,81 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_PLANE3D_H
-#define G2O_EDGE_PLANE3D_H
-
-#include "g2o/config.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o_types_slam3d_addons_api.h"
-#include "vertex_plane.h"
-
-namespace g2o {
-
-class G2O_TYPES_SLAM3D_ADDONS_API EdgePlane : public BaseBinaryEdge<4, Vector4, VertexPlane, VertexPlane> {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  EdgePlane();
-
-  void computeError() {
-    const VertexPlane* v1 = static_cast<const VertexPlane*>(_vertices[0]);
-    const VertexPlane* v2 = static_cast<const VertexPlane*>(_vertices[1]);
-    _error = (v2->estimate().toVector() - v1->estimate().toVector()) - _measurement;
-  }
-  virtual bool read(std::istream& is);
-  virtual bool write(std::ostream& os) const;
-
-  virtual void setMeasurement(const Vector4& m) { _measurement = m; }
-
-  virtual bool setMeasurementData(const number_t* d) {
-    Eigen::Map<const Vector4> m(d);
-    _measurement = m;
-    return true;
-  }
-
-  virtual bool getMeasurementData(number_t* d) const {
-    Eigen::Map<Vector4> m(d);
-    m = _measurement;
-    return true;
-  }
-
-  virtual int measurementDimension() const { return 4; }
-
-  virtual bool setMeasurementFromState() {
-    const VertexPlane* v1 = static_cast<const VertexPlane*>(_vertices[0]);
-    const VertexPlane* v2 = static_cast<const VertexPlane*>(_vertices[1]);
-    _measurement = (v2->estimate().toVector()) - v1->estimate().toVector();
-
-    return true;
-  }
-
-#if 0
-    virtual void linearizeOplus();
-#endif
-};
-
-}  // namespace g2o
-
-#endif
diff --git a/g2o/types/slam3d_addons/edge_se3_calib.cpp b/g2o/types/slam3d_addons/edge_se3_calib.cpp
deleted file mode 100644
index d9920942..00000000
--- a/g2o/types/slam3d_addons/edge_se3_calib.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_calib.h"
-
-#include "g2o/types/slam3d/vertex_se3.h"
-
-namespace g2o {
-
-EdgeSE3Calib::EdgeSE3Calib() : BaseMultiEdge<6, Isometry3>() { resize(3); }
-
-void EdgeSE3Calib::computeError() {
-  const VertexSE3* v1 = static_cast<const VertexSE3*>(_vertices[0]);
-  const VertexSE3* v2 = static_cast<const VertexSE3*>(_vertices[1]);
-  const VertexSE3* calib = static_cast<const VertexSE3*>(_vertices[2]);
-  _error = g2o::internal::toVectorMQT(_measurement.inverse() * calib->estimate().inverse() * v1->estimate().inverse() *
-                                      v2->estimate() * calib->estimate());
-}
-
-bool EdgeSE3Calib::write(std::ostream& os) const {
-  internal::writeVector(os, internal::toVectorQT(_measurement));
-  return writeInformationMatrix(os);
-}
-
-bool EdgeSE3Calib::read(std::istream& is) {
-  Vector7 meas;
-  internal::readVector(is, meas);
-  // normalize the quaternion to recover numerical precision lost by storing as human readable text
-  Vector4::MapType(meas.data() + 3).normalize();
-  setMeasurement(g2o::internal::fromVectorQT(meas));
-  return readInformationMatrix(is);
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d_addons/edge_se3_calib.h b/g2o/types/slam3d_addons/edge_se3_calib.h
deleted file mode 100644
index 0823cdc4..00000000
--- a/g2o/types/slam3d_addons/edge_se3_calib.h
+++ /dev/null
@@ -1,52 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_CALIB_H
-#define G2O_EDGE_SE3_CALIB_H
-
-#include "g2o_types_slam3d_addons_api.h"
-#include "g2o/core/base_multi_edge.h"
-#include "g2o/types/slam3d/isometry3d_mappings.h"
-
-namespace g2o
-{
-  /**
-   * \brief Landmark measurement that also calibrates an offset for the landmark measurement
-   */
-  class EdgeSE3Calib : public BaseMultiEdge<6, Isometry3> //Avoid redefinition of BaseEdge in MSVC
-  {
-    public:
-      G2O_TYPES_SLAM3D_ADDONS_API EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-      G2O_TYPES_SLAM3D_ADDONS_API EdgeSE3Calib();
-
-      G2O_TYPES_SLAM3D_ADDONS_API void computeError();
-      G2O_TYPES_SLAM3D_ADDONS_API virtual bool read(std::istream& is);
-      G2O_TYPES_SLAM3D_ADDONS_API virtual bool write(std::ostream& os) const;
-  };
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d_addons/edge_se3_euler.cpp b/g2o/types/slam3d_addons/edge_se3_euler.cpp
deleted file mode 100644
index b5244c28..00000000
--- a/g2o/types/slam3d_addons/edge_se3_euler.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_euler.h"
-#include "g2o/core/factory.h"
-#include <iostream>
-
-using namespace Eigen;
-
-namespace g2o
-{
-
-  /** conversion code from Euler angles */
-static void jac_quat3_euler3(Eigen::Matrix<number_t, 6, 6, Eigen::ColMajor>& J, const Isometry3& t)
-{
-  Vector7 t0 = g2o::internal::toVectorQT(t);
-
-  number_t delta= cst(1e-6);
-  number_t idelta= 1 / (2 * delta);
-
-  Vector7 ta;
-  Vector7 tb;
-  for (int i=0; i<6; i++){
-    ta=tb=t0;
-    ta[i]-=delta;
-    tb[i]+=delta;
-    Vector6 ea = g2o::internal::toVectorET(g2o::internal::fromVectorQT(ta));
-    Vector6 eb = g2o::internal::toVectorET(g2o::internal::fromVectorQT(tb));
-    J.col(i)=(eb-ea)*idelta;
-  }
-}
-
-
-  bool EdgeSE3Euler::read(std::istream& is)
-  {
-    Vector6 meas;
-    for (int i=0; i<6; i++)
-      is  >> meas[i];
-    Isometry3 transf= g2o::internal::fromVectorET(meas);
-    Matrix<number_t, 6, 6, Eigen::ColMajor> infMatEuler;
-    for (int i=0; i<6; i++)
-      for (int j=i; j<6; j++) {
-        is >> infMatEuler(i,j);
-        if (i!=j)
-          infMatEuler(j,i) = infMatEuler(i,j);
-      }
-    Matrix<number_t, 6, 6, Eigen::ColMajor> J;
-    jac_quat3_euler3(J, transf);
-    Matrix<number_t, 6, 6, Eigen::ColMajor> infMat = J.transpose() * infMatEuler * J;
-    setMeasurement(transf);
-    setInformation(infMat);
-    return true;
-  }
-
-  bool EdgeSE3Euler::write(std::ostream& os) const
-  {
-    Vector6 meas = g2o::internal::toVectorET(_measurement);
-    for (int i=0; i<6; i++)
-      os << meas[i] << " ";
-
-    Matrix<number_t, 6, 6, Eigen::ColMajor> J;
-    jac_quat3_euler3(J, measurement());
-    //HACK: invert the jacobian to simulate the inverse derivative
-    J=J.inverse();
-    Matrix<number_t, 6, 6, Eigen::ColMajor> infMatEuler = J.transpose()*information()*J;
-    for (int i=0; i<6; i++)
-      for (int j=i; j<6; j++){
-        os << " " <<  infMatEuler(i,j);
-      }
-    return os.good();
-  }
-
-} // end namespace
diff --git a/g2o/types/slam3d_addons/edge_se3_euler.h b/g2o/types/slam3d_addons/edge_se3_euler.h
deleted file mode 100644
index f32dfa24..00000000
--- a/g2o/types/slam3d_addons/edge_se3_euler.h
+++ /dev/null
@@ -1,52 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_EULER_
-#define G2O_EDGE_SE3_EULER_
-
-#include "g2o_types_slam3d_addons_api.h"
-#include "g2o/types/slam3d/edge_se3.h"
-#include "g2o/types/slam3d/vertex_se3.h"
-
-namespace g2o
-{
-
-/**
- * \brief 3D edge between two VertexSE3, uses the euler angle parameterization
- * for the read/write functions *only*.
- */
-class G2O_TYPES_SLAM3D_ADDONS_API EdgeSE3Euler : public EdgeSE3
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-};
-
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d_addons/edge_se3_line.cpp b/g2o/types/slam3d_addons/edge_se3_line.cpp
deleted file mode 100644
index b844fdef..00000000
--- a/g2o/types/slam3d_addons/edge_se3_line.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_line.h"
-
-#include "g2o/stuff/opengl_wrapper.h"
-
-namespace g2o {
-
-  EdgeSE3Line3D::EdgeSE3Line3D() {
-    information().setIdentity();
-    cache = 0;
-    offsetParam = 0;
-    resizeParameters(1);
-    installParameter(offsetParam, 0);
-    color << 0.0, 0.5, 1.0;
-  }
-
-  bool EdgeSE3Line3D::read(std::istream& is) {
-    bool state = readParamIds(is);
-    state &= internal::readVector(is, _measurement);
-    state &= readInformationMatrix(is);
-    return state;
-  }
-
-  bool EdgeSE3Line3D::write(std::ostream& os) const {
-    writeParamIds(os);
-    internal::writeVector(os, measurement());
-    return writeInformationMatrix(os);
-  }
-
-  void EdgeSE3Line3D::computeError() {
-    const VertexSE3* se3Vertex = static_cast<const VertexSE3*>(_vertices[0]);
-    const VertexLine3D* lineVertex = static_cast<const VertexLine3D*>(_vertices[1]);
-    const Line3D& line = lineVertex->estimate();
-    Line3D localLine = se3Vertex->estimate().inverse() * line;
-    _error = localLine.ominus(_measurement);
-  }
-
-  bool EdgeSE3Line3D::resolveCaches() {
-    ParameterVector pv(1);
-    pv[0] = offsetParam;
-    resolveCache(cache, (OptimizableGraph::Vertex*)_vertices[0], "CACHE_SE3_OFFSET", pv);
-    return cache != 0;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  EdgeSE3Line3DDrawAction::EdgeSE3Line3DDrawAction()
-      : DrawAction(typeid(EdgeSE3Line3D).name()), _lineLength(nullptr), _lineWidth(nullptr) {}
-
-  bool EdgeSE3Line3DDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
-    if(!DrawAction::refreshPropertyPtrs(params_)) {
-      return false;
-    }
-    if(_previousParams) {
-      _lineLength = _previousParams->makeProperty<FloatProperty>(_typeName + "::LINE_LENGTH", 4.0f);
-      _lineWidth = _previousParams->makeProperty<FloatProperty>(_typeName + "::LINE_WIDTH", 2.0f);
-    }
-    else {
-      _lineLength = 0;
-      _lineWidth = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* EdgeSE3Line3DDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-							       HyperGraphElementAction::Parameters* params_) {
-    if(typeid(*element).name() != _typeName)
-      return nullptr;
-
-    refreshPropertyPtrs(params_);
-    if(!_previousParams)
-      return this;
-
-
-    if(_show && !_show->value())
-      return this;
-
-
-    EdgeSE3Line3D* that = dynamic_cast<EdgeSE3Line3D*>(element);
-
-    if(!that)
-      return this;
-
-
-    const VertexSE3* robot  = dynamic_cast<const VertexSE3*>(that->vertex(0));
-    const VertexLine3D* landmark = dynamic_cast<const VertexLine3D*>(that->vertex(1));
-
-    if(!robot || !landmark)
-      return nullptr;
-
-    if (_lineLength && _lineWidth) {
-      Line3D line = that->measurement();
-      line.normalize();
-      Vector3 direction = line.d();
-      Vector3 npoint = line.d().cross(line.w());
-
-      glPushMatrix();
-      glMultMatrixd(robot->estimate().matrix().cast<double>().eval().data());
-      glColor3f(float(that->color(0)), float(that->color(1)), float(that->color(2)));
-      glLineWidth(float(_lineWidth->value()));
-      glBegin(GL_LINES);
-      glNormal3f(float(npoint.x()), float(npoint.y()), float(npoint.z()));
-      glVertex3f(float(npoint.x() - direction.x() * _lineLength->value() / 2),
-                 float(npoint.y() - direction.y() * _lineLength->value() / 2),
-                 float(npoint.z() - direction.z() * _lineLength->value() / 2));
-      glVertex3f(float(npoint.x() + direction.x() * _lineLength->value() / 2),
-                 float(npoint.y() + direction.y() * _lineLength->value() / 2),
-                 float(npoint.z() + direction.z() * _lineLength->value() / 2));
-      glEnd();
-      glPopMatrix();
-    }
-
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d_addons/edge_se3_line.h b/g2o/types/slam3d_addons/edge_se3_line.h
deleted file mode 100644
index 5f85bbcd..00000000
--- a/g2o/types/slam3d_addons/edge_se3_line.h
+++ /dev/null
@@ -1,99 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_LINE_H_
-#define G2O_EDGE_SE3_LINE_H_
-
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/types/slam3d/vertex_se3.h"
-#include "g2o/types/slam3d/parameter_se3_offset.h"
-
-#include "line3d.h"
-#include "vertex_line3d.h"
-#include "g2o_types_slam3d_addons_api.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM3D_ADDONS_API EdgeSE3Line3D : public BaseBinaryEdge<4, Line3D, VertexSE3, VertexLine3D> {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-      EdgeSE3Line3D();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      void computeError();
-
-      virtual void setMeasurement(const Vector6& m) {
-        _measurement = m;
-      }
-
-      virtual void setMeasurement(const Line3D& m) {
-        _measurement = Line3D(m);
-      }
-
-      virtual bool setMeasurementData(const number_t* d) {
-        Eigen::Map<const Vector6> v(d);	
-        _measurement = Line3D(v);
-        return true;
-      }
-
-      virtual bool getMeasurementData(number_t* d) const {
-        Eigen::Map<Vector6> v(d);
-        v = _measurement;
-        return true;
-      }
-
-      virtual int measurementDimension() const {
-	return 6;
-      }
-
-      Vector3 color;
-      
-  private:
-    ParameterSE3Offset* offsetParam;
-    CacheSE3Offset* cache;
-    virtual bool resolveCaches();
-
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class EdgeSE3Line3DDrawAction : public DrawAction {
-  public:
-    G2O_TYPES_SLAM3D_ADDONS_API EdgeSE3Line3DDrawAction();
-    G2O_TYPES_SLAM3D_ADDONS_API virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-									    HyperGraphElementAction::Parameters* params_);
-    
-  protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    FloatProperty* _lineLength, *_lineWidth;
-    
-  };
-#endif
-  
-}
-#endif
diff --git a/g2o/types/slam3d_addons/edge_se3_plane_calib.cpp b/g2o/types/slam3d_addons/edge_se3_plane_calib.cpp
deleted file mode 100644
index ca8d7746..00000000
--- a/g2o/types/slam3d_addons/edge_se3_plane_calib.cpp
+++ /dev/null
@@ -1,119 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "edge_se3_plane_calib.h"
-
-#include <iostream>
-
-#include "g2o/stuff/opengl_wrapper.h"
-
-namespace g2o {
-using namespace std;
-using namespace Eigen;
-
-EdgeSE3PlaneSensorCalib::EdgeSE3PlaneSensorCalib() : BaseMultiEdge<3, Plane3D>(), color(cst(0.1), cst(0.1), cst(0.1)) {
-  resize(3);
-}
-
-bool EdgeSE3PlaneSensorCalib::read(std::istream& is) {
-  Vector4 v;
-  bool state = internal::readVector(is, v);
-  setMeasurement(Plane3D(v));
-  state &= internal::readVector(is, color);
-  state &= readInformationMatrix(is);
-  return state;
-}
-
-bool EdgeSE3PlaneSensorCalib::write(std::ostream& os) const {
-  internal::writeVector(os, measurement().toVector());
-  internal::writeVector(os, color);
-  return writeInformationMatrix(os);
-}
-
-#ifdef G2O_HAVE_OPENGL
-EdgeSE3PlaneSensorCalibDrawAction::EdgeSE3PlaneSensorCalibDrawAction()
-    : DrawAction(typeid(EdgeSE3PlaneSensorCalib).name()), _planeWidth(nullptr), _planeHeight(nullptr) {}
-
-bool EdgeSE3PlaneSensorCalibDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
-  if (!DrawAction::refreshPropertyPtrs(params_)) return false;
-  if (_previousParams) {
-    _planeWidth = _previousParams->makeProperty<FloatProperty>(_typeName + "::PLANE_WIDTH", 0.5f);
-    _planeHeight = _previousParams->makeProperty<FloatProperty>(_typeName + "::PLANE_HEIGHT", 0.5f);
-  } else {
-    _planeWidth = 0;
-    _planeHeight = 0;
-  }
-  return true;
-}
-
-HyperGraphElementAction* EdgeSE3PlaneSensorCalibDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                                                                       HyperGraphElementAction::Parameters* params_) {
-  if (typeid(*element).name() != _typeName) return nullptr;
-
-  refreshPropertyPtrs(params_);
-  if (!_previousParams) return this;
-
-  if (_show && !_show->value()) return this;
-
-  EdgeSE3PlaneSensorCalib* that = dynamic_cast<EdgeSE3PlaneSensorCalib*>(element);
-
-  if (!that) return this;
-
-  const VertexSE3* robot = dynamic_cast<const VertexSE3*>(that->vertex(0));
-  const VertexSE3* sensor = dynamic_cast<const VertexSE3*>(that->vertex(2));
-  if (!robot || !sensor) return nullptr;
-
-  if (_planeWidth && _planeHeight) {
-    number_t d = that->measurement().distance();
-    number_t azimuth = Plane3D::azimuth(that->measurement().normal());
-    number_t elevation = Plane3D::elevation(that->measurement().normal());
-
-    glColor3f(float(that->color(0)), float(that->color(1)), float(that->color(2)));
-    glPushMatrix();
-    Isometry3 robotAndSensor = robot->estimate() * sensor->estimate();
-    glMultMatrixd(robotAndSensor.matrix().cast<double>().eval().data());
-
-    glRotatef(float(RAD2DEG(azimuth)), 0.f, 0.f, 1.f);
-    glRotatef(float(RAD2DEG(elevation)), 0.f, -1.f, 0.f);
-    glTranslatef(float(d), 0.f, 0.f);
-
-    float planeWidth = _planeWidth->value();
-    float planeHeight = _planeHeight->value();
-    glBegin(GL_QUADS);
-    glNormal3f(-1, 0, 0);
-    glVertex3f(0, -planeWidth, -planeHeight);
-    glVertex3f(0, planeWidth, -planeHeight);
-    glVertex3f(0, planeWidth, planeHeight);
-    glVertex3f(0, -planeWidth, planeHeight);
-    glEnd();
-    glPopMatrix();
-  }
-
-  return this;
-}
-#endif
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d_addons/edge_se3_plane_calib.h b/g2o/types/slam3d_addons/edge_se3_plane_calib.h
deleted file mode 100644
index fa6a4f7e..00000000
--- a/g2o/types/slam3d_addons/edge_se3_plane_calib.h
+++ /dev/null
@@ -1,81 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_EDGE_SE3_PLANE_CALIB_H
-#define G2O_EDGE_SE3_PLANE_CALIB_H
-
-#include "g2o/core/base_multi_edge.h"
-#include "g2o/types/slam3d/vertex_se3.h"
-#include "vertex_plane.h"
-#include "g2o/config.h"
-
-namespace g2o {
-  /**
-   * \brief plane measurement that also calibrates an offset for the sensor
-   */
-  class G2O_TYPES_SLAM3D_ADDONS_API EdgeSE3PlaneSensorCalib : public BaseMultiEdge<3, Plane3D>
-  {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      EdgeSE3PlaneSensorCalib();
-      Vector3 color;
-
-      void computeError()
-      {
-        const VertexSE3* v1            = static_cast<const VertexSE3*>(_vertices[0]);
-        const VertexPlane* planeVertex = static_cast<const VertexPlane*>(_vertices[1]);
-        const VertexSE3* offset        = static_cast<const VertexSE3*>(_vertices[2]);
-        const Plane3D& plane           = planeVertex->estimate();
-	// measurement function: remap the plane in global coordinates
-        Isometry3 w2n=(v1->estimate()*offset->estimate()).inverse();
-	Plane3D localPlane=w2n*plane;
-	_error = localPlane.ominus(_measurement);
-      }
-
-      void setMeasurement(const Plane3D& m){
-	_measurement = m;
-      }
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class EdgeSE3PlaneSensorCalibDrawAction: public DrawAction{
-  public:
-    G2O_TYPES_SLAM3D_ADDONS_API EdgeSE3PlaneSensorCalibDrawAction();
-    G2O_TYPES_SLAM3D_ADDONS_API virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-            HyperGraphElementAction::Parameters* params_ );
-  protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    FloatProperty* _planeWidth, *_planeHeight;
-  };
-#endif
-
-} // end namespace
-
-#endif
diff --git a/g2o/types/slam3d_addons/g2o_types_slam3d_addons_api.h b/g2o/types/slam3d_addons/g2o_types_slam3d_addons_api.h
deleted file mode 100644
index 827487fb..00000000
--- a/g2o/types/slam3d_addons/g2o_types_slam3d_addons_api.h
+++ /dev/null
@@ -1,49 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_SLAM3D_ADDONS_API_H
-#define G2O_TYPES_SLAM3D_ADDONS_API_H
-
-#include "g2o/config.h"
-
-#ifdef _MSC_VER
-// We are using a Microsoft compiler:
-#ifdef G2O_SHARED_LIBS
-#ifdef types_slam3d_addons_EXPORTS
-#define G2O_TYPES_SLAM3D_ADDONS_API __declspec(dllexport)
-#else
-#define G2O_TYPES_SLAM3D_ADDONS_API __declspec(dllimport)
-#endif
-#else
-#define G2O_TYPES_SLAM3D_ADDONS_API
-#endif
-
-#else
-// Not Microsoft compiler so set empty definition:
-#define G2O_TYPES_SLAM3D_ADDONS_API
-#endif
-
-#endif // G2O_TYPES_SLAM3D_ADDONS_API_H
diff --git a/g2o/types/slam3d_addons/line3d.cpp b/g2o/types/slam3d_addons/line3d.cpp
deleted file mode 100644
index 99537f39..00000000
--- a/g2o/types/slam3d_addons/line3d.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "line3d.h"
-
-#include "g2o/stuff/misc.h"
-
-namespace g2o {
-
-  using namespace std;
-
-  static inline Matrix3 _skew(const Vector3& t) {
-    Matrix3 S;
-    S <<
-           0, -t.z(),  t.y(),
-       t.z(),      0, -t.x(),
-      -t.y(),  t.x(),      0;
-    return S;
-  }
-
-
-  Vector6 Line3D::toCartesian() const {
-    Vector6 cartesian;
-    cartesian.tail<3>() = d()/d().norm();
-    Matrix3 W = -_skew(d());
-    number_t damping = cst(1e-9);
-    Matrix3 A = W.transpose()*W + (Matrix3::Identity()*damping);
-    cartesian.head<3>() = A.ldlt().solve(W.transpose()*w());
-    return cartesian;
-  }
-
-  Line3D operator*(const Isometry3& t, const Line3D& line){
-    Matrix6 A = Matrix6::Zero();
-    A.block<3, 3>(0, 0) = t.linear();
-    A.block<3, 3>(0, 3) = _skew(t.translation())*t.linear();
-    A.block<3, 3>(3, 3) = t.linear();
-    Vector6 v = (Vector6)line;
-    return Line3D(A*v);
-  }
-  
-  namespace internal {
-    Vector6 transformCartesianLine(const Isometry3& t, const Vector6& line) {
-      Vector6 l;
-      l.head<3>() = t*line.head<3>();
-      l.tail<3>() = t.linear()*line.tail<3>();
-      return normalizeCartesianLine(l);
-    }
-
-    Vector6 normalizeCartesianLine(const Vector6& line) {
-      Vector3 p0 = line.head<3>();
-      Vector3 d0 = line.tail<3>();
-      d0.normalize();
-      p0 -= d0*(d0.dot(p0));
-      Vector6 nl;
-      nl.head<3>() = p0;
-      nl.tail<3>() = d0;
-      return nl;
-    }
-    
-  }
-
-}
diff --git a/g2o/types/slam3d_addons/line3d.h b/g2o/types/slam3d_addons/line3d.h
deleted file mode 100644
index 0361d0a1..00000000
--- a/g2o/types/slam3d_addons/line3d.h
+++ /dev/null
@@ -1,209 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_LINE3D_H_
-#define G2O_LINE3D_H_
-
-
-#include <Eigen/Core>
-
-#include "g2o_types_slam3d_addons_api.h"
-
-namespace g2o {
-  
-  typedef Eigen::Matrix<number_t, 6, 1> Vector6;
-  typedef Eigen::Matrix<number_t, 6, 6> Matrix6;
-  typedef Eigen::Matrix<number_t, 6, 4> Matrix6x4;
-  
-  struct OrthonormalLine3D {
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-    Matrix2 W;
-    Matrix3 U;
-
-    OrthonormalLine3D() {
-      W = Matrix2::Identity();
-      U = Matrix3::Identity();
-    }
-  };
-  typedef struct OrthonormalLine3D OrthonormalLine3D;
-  
-  class Line3D : public Vector6 {
-    public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-    G2O_TYPES_SLAM3D_ADDONS_API friend Line3D operator*(const Isometry3& t,
-    							const Line3D& line);
-
-    G2O_TYPES_SLAM3D_ADDONS_API Line3D() {
-      *this << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API Line3D(const Vector6& v) {
-      (Vector6&)*this = v;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API Vector6 toCartesian() const;
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline Vector3 w() const {
-      return head<3>();
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline Vector3 d() const {
-      return tail<3>();
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline void setW(const Vector3& w_) {
-      head<3>() = w_;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline void setD(const Vector3& d_) {
-      tail<3>() = d_;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API static inline Line3D fromCartesian(const Vector6& cart) {
-      Line3D l;
-      Vector3 _p = cart.head<3>();
-      Vector3 _d = cart.tail<3>() * 1.0/cart.tail<3>().norm();
-      _p -= _d*(_d.dot(_p));
-      l.setW(_p.cross(_p+_d));
-      l.setD(_d);
-      return l;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API static inline Line3D fromOrthonormal(const OrthonormalLine3D& ortho) {
-      Vector3 w;
-      w.x() = ortho.U(0, 0) * ortho.W(0, 0);
-      w.y() = ortho.U(1, 0) * ortho.W(0, 0);
-      w.z() = ortho.U(2, 0) * ortho.W(0, 0);
-
-      Vector3 d;
-      d.x() = ortho.U(0, 1) * ortho.W(1, 0);
-      d.y() = ortho.U(1, 1) * ortho.W(1, 0);
-      d.z() = ortho.U(2, 1) * ortho.W(1, 0);
-
-      Line3D l;
-      l.setW(w);
-      l.setD(d);
-      l.normalize();
-      
-      return l;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API static inline OrthonormalLine3D toOrthonormal(const Line3D& line) {
-      OrthonormalLine3D ortho;
-
-      Vector2 mags;
-      mags << line.d().norm(), line.w().norm();
-
-      number_t wn = 1.0 / mags.norm();
-      ortho.W <<
-      	mags.y() * wn, -mags.x() * wn,
-      	mags.x() * wn,  mags.y() * wn;
-
-      number_t mn = 1.0 / mags.y();
-      number_t dn = 1.0 / mags.x();
-      Vector3 mdcross;
-      mdcross = line.w().cross(line.d());
-      number_t mdcrossn = 1.0 / mdcross.norm();
-      ortho.U <<
-      	line.w().x() * mn, line.d().x() * dn, mdcross.x() * mdcrossn,
-      	line.w().y() * mn, line.d().y() * dn, mdcross.y() * mdcrossn,
-      	line.w().z() * mn, line.d().z() * dn, mdcross.z() * mdcrossn;
-
-      return ortho;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline void normalize() {
-      number_t n = 1.0/d().norm();
-      (*this)*=n;
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline Line3D normalized() const {
-      return Line3D((Vector6)(*this)*(1.0/d().norm()));
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline void oplus(const Vector4& v){
-      OrthonormalLine3D ortho_estimate = toOrthonormal(*this);
-      OrthonormalLine3D ortho_update;
-      ortho_update.W <<
-    	std::cos(v[3]), -std::sin(v[3]),
-       	std::sin(v[3]),  std::cos(v[3]);
-      Quaternion quat(std::sqrt(1 - v.head<3>().squaredNorm()), v[0], v[1], v[2]);
-      quat.normalize();
-      ortho_update.U = quat.toRotationMatrix();
-
-      ortho_estimate.U = ortho_estimate.U * ortho_update.U;
-      ortho_estimate.W = ortho_estimate.W * ortho_update.W;
-
-      *this = fromOrthonormal(ortho_estimate);
-      this->normalize();
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline Vector4 ominus(const Line3D& line) {
-      OrthonormalLine3D ortho_estimate = toOrthonormal(*this);
-      OrthonormalLine3D ortho_line = toOrthonormal(line);
-
-      Matrix2 W_delta = ortho_estimate.W.transpose() * ortho_line.W;
-      Matrix3 U_delta = ortho_estimate.U.transpose() * ortho_line.U;
-	
-      Vector4 delta;
-      Quaternion q(U_delta);
-      q.normalize();
-      delta[0] = q.x();
-      delta[1] = q.y();
-      delta[2] = q.z();
-      delta[3] = std::atan2(W_delta(1, 0), W_delta(0, 0));
-     
-      return delta;
-    }
-
-  };
-
-  G2O_TYPES_SLAM3D_ADDONS_API Line3D operator*(const Isometry3& t, const Line3D& line);
-  
-  namespace internal {
-
-    G2O_TYPES_SLAM3D_ADDONS_API Vector6 transformCartesianLine(const Isometry3& t, const Vector6& line);
-    
-    G2O_TYPES_SLAM3D_ADDONS_API Vector6 normalizeCartesianLine(const Vector6& line);
-
-    static inline number_t mline_elevation(const number_t v[3]) {
-      return std::atan2(v[2], sqrt(v[0]*v[0] + v[1]*v[1]));
-    }
-    
-    G2O_TYPES_SLAM3D_ADDONS_API inline number_t getAzimuth(const Vector3& direction) {
-      return std::atan2(direction.y(), direction.x());
-    }
-
-    G2O_TYPES_SLAM3D_ADDONS_API inline number_t getElevation(const Vector3& direction) {
-      return std::atan2(direction.z(), direction.head<2>().norm());
-    }
-    
-  }
-
-}
-
-#endif
diff --git a/g2o/types/slam3d_addons/plane3d.h b/g2o/types/slam3d_addons/plane3d.h
deleted file mode 100644
index 1b8850cf..00000000
--- a/g2o/types/slam3d_addons/plane3d.h
+++ /dev/null
@@ -1,130 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_PLANE3D_H_
-#define G2O_PLANE3D_H_
-
-#include "g2o_types_slam3d_addons_api.h"
-#include "g2o/stuff/misc.h"
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM3D_ADDONS_API Plane3D {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-      friend Plane3D operator*(const Isometry3& t, const Plane3D& plane);
-
-      Plane3D(){
-        fromVector(Vector4(1., 0., 0., -1.));
-      }
-
-      Plane3D(const Vector4& v){
-        fromVector(v);
-      }
-
-      inline Vector4 toVector() const {
-        return _coeffs;
-      }
-
-      inline const Vector4& coeffs() const {return _coeffs;}
-
-      inline void fromVector(const Vector4& coeffs_) {
-        _coeffs=coeffs_;
-        normalize(_coeffs);
-      }
-
-      static number_t azimuth(const Vector3& v) {
-        return std::atan2(v(1),v(0));
-      }
-
-      static  number_t elevation(const Vector3& v) {
-        return std::atan2(v(2), v.head<2>().norm());
-      }
-
-    number_t distance() const {
-      return -_coeffs(3);
-    }
-
-    Vector3 normal() const {
-      return _coeffs.head<3>();
-    }
-
-
-    static Matrix3 rotation(const Vector3& v)  {
-      number_t _azimuth = azimuth(v);
-      number_t _elevation = elevation(v);
-      return (AngleAxis(_azimuth,  Vector3::UnitZ())* AngleAxis(- _elevation, Vector3::UnitY())).toRotationMatrix();
-    }
-
-    inline void oplus(const Vector3& v){
-      //construct a normal from azimuth and evelation;
-      number_t _azimuth=v[0];
-      number_t _elevation=v[1];
-      number_t s=std::sin(_elevation), c=std::cos(_elevation);
-      Vector3 n (c*std::cos(_azimuth), c*std::sin(_azimuth), s) ;
-
-      // rotate the normal
-      Matrix3 R=rotation(normal());
-      number_t d=distance()+v[2];
-      _coeffs.head<3>() = R*n;
-      _coeffs(3) = -d;
-      normalize(_coeffs);
-    }
-
-    inline Vector3 ominus(const Plane3D& plane){
-      //construct the rotation that would bring the plane normal in (1 0 0)
-      Matrix3 R=rotation(normal()).transpose();
-      Vector3 n=R*plane.normal();
-      number_t d=distance()-plane.distance();
-      return Vector3(azimuth(n), elevation(n), d);
-    }
-
-    protected:
-
-    static inline void normalize(Vector4& coeffs) {
-      number_t n=coeffs.head<3>().norm();
-      coeffs = coeffs * (1./n);
-    }
-
-    Vector4 _coeffs;
-  };
-
-  inline Plane3D operator*(const Isometry3& t, const Plane3D& plane){
-    Vector4 v=plane._coeffs;
-    Vector4 v2;
-    Matrix3 R=t.rotation();
-    v2.head<3>() = R*v.head<3>();
-    v2(3)=v(3) - t.translation().dot(v2.head<3>());
-    return Plane3D(v2);
-  };
-
-
-}
-
-#endif
diff --git a/g2o/types/slam3d_addons/types_slam3d_addons.cpp b/g2o/types/slam3d_addons/types_slam3d_addons.cpp
deleted file mode 100644
index 4dc3c365..00000000
--- a/g2o/types/slam3d_addons/types_slam3d_addons.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "types_slam3d_addons.h"
-#include "g2o/core/factory.h"
-#include "g2o/stuff/macros.h"
-
-#include <typeinfo>
-#include <iostream>
-
-namespace g2o {
-
-  G2O_REGISTER_TYPE_GROUP(slam3d_addons);
-
-  G2O_REGISTER_TYPE(VERTEX3, VertexSE3Euler);
-  G2O_REGISTER_TYPE(EDGE3, EdgeSE3Euler);
-  G2O_REGISTER_TYPE(VERTEX_PLANE, VertexPlane);
-  G2O_REGISTER_TYPE(EDGE_SE3_PLANE_CALIB, EdgeSE3PlaneSensorCalib);
-
-  G2O_REGISTER_TYPE(VERTEX_LINE3D, VertexLine3D);
-  G2O_REGISTER_TYPE(EDGE_SE3_LINE3D, EdgeSE3Line3D);
-  G2O_REGISTER_TYPE(EDGE_PLANE, EdgePlane);
-  G2O_REGISTER_TYPE(EDGE_SE3_CALIB, EdgeSE3Calib);
-
-#ifdef G2O_HAVE_OPENGL
-  G2O_REGISTER_ACTION(CacheCameraDrawAction);
-  G2O_REGISTER_ACTION(VertexPlaneDrawAction);  
-  G2O_REGISTER_ACTION(EdgeSE3PlaneSensorCalibDrawAction);
-  G2O_REGISTER_ACTION(VertexLine3DDrawAction);
-  G2O_REGISTER_ACTION(EdgeSE3Line3DDrawAction);
-#endif
-
-  G2O_ATTRIBUTE_CONSTRUCTOR(init_slam3d_addons_types)
-  {
-    static bool initialized = false;
-    if (initialized)
-      return;
-    initialized = true;
-
-#ifdef G2O_HAVE_OPENGL
-    HyperGraphActionLibrary* actionLib = HyperGraphActionLibrary::instance();
-    HyperGraphElementAction* vertexse3eulerdraw=new g2o::VertexSE3DrawAction;
-    vertexse3eulerdraw->setTypeName(typeid(VertexSE3Euler).name());
-    actionLib->registerAction(vertexse3eulerdraw);
-
-    HyperGraphElementAction* edgese3eulerdraw=new g2o::EdgeSE3DrawAction;
-    edgese3eulerdraw->setTypeName(typeid(EdgeSE3Euler).name());
-    actionLib->registerAction(edgese3eulerdraw);
-#endif
-  }
-
-} // end namespace
diff --git a/g2o/types/slam3d_addons/types_slam3d_addons.h b/g2o/types/slam3d_addons/types_slam3d_addons.h
deleted file mode 100644
index 91bb8d26..00000000
--- a/g2o/types/slam3d_addons/types_slam3d_addons.h
+++ /dev/null
@@ -1,46 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_TYPES_SLAM3D_ADDONS_
-#define G2O_TYPES_SLAM3D_ADDONS_
-
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/base_binary_edge.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "g2o/types//slam3d/types_slam3d.h"
-
-#include "vertex_se3_euler.h"
-#include "edge_se3_euler.h"
-#include "vertex_plane.h"
-#include "edge_se3_plane_calib.h"
-
-#include "vertex_line3d.h"
-#include "edge_se3_line.h"
-#include "edge_plane.h"
-#include "edge_se3_calib.h"
-
-#endif
diff --git a/g2o/types/slam3d_addons/vertex_line3d.cpp b/g2o/types/slam3d_addons/vertex_line3d.cpp
deleted file mode 100644
index f8aa484e..00000000
--- a/g2o/types/slam3d_addons/vertex_line3d.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_line3d.h"
-
-#include "g2o/stuff/misc.h"
-#include "g2o/stuff/opengl_wrapper.h"
-
-namespace g2o {
-
-  VertexLine3D::VertexLine3D() : BaseVertex<4, Line3D>(), color(1., 0.5, 0.) {
-  }
-
-  bool VertexLine3D::read(std::istream& is) {
-    Vector6 lv;
-    bool state = internal::readVector(is, lv);
-    setEstimate(Line3D(lv));
-    return state;
-  }
-
-  bool VertexLine3D::write(std::ostream& os) const {
-    return internal::writeVector(os, _estimate);
-  }
-
-#ifdef G2O_HAVE_OPENGL
-  VertexLine3DDrawAction::VertexLine3DDrawAction()
-      : DrawAction(typeid(VertexLine3D).name()), _lineLength(nullptr), _lineWidth(nullptr) {}
-
-  bool VertexLine3DDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
-    if(!DrawAction::refreshPropertyPtrs(params_)) {
-      return false;
-    }
-    if(_previousParams) {
-      _lineLength = _previousParams->makeProperty<FloatProperty>(_typeName + "::LINE_LENGTH", 15);
-      _lineWidth = _previousParams->makeProperty<FloatProperty>(_typeName + "::LINE_WIDTH", 5);
-    }
-    else {
-      _lineLength = 0;
-      _lineWidth = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexLine3DDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-							     HyperGraphElementAction::Parameters* params_) {
-    if(typeid(*element).name() != _typeName) {
-      return nullptr;
-    }
-
-    refreshPropertyPtrs(params_);
-    if(!_previousParams) {
-      return this;
-    }
-
-    if(_show && !_show->value()) {
-      return this;
-    }
-
-    VertexLine3D* that = static_cast<VertexLine3D*>(element);
-    Line3D line = that->estimate();
-    line.normalize();
-    Vector3 direction = line.d();
-    Vector3 npoint = line.d().cross(line.w());
-    glPushMatrix();
-    glColor3f(float(that->color(0)), float(that->color(1)), float(that->color(2)));
-    if(_lineLength && _lineWidth) {
-      glLineWidth(float(_lineWidth->value()));
-      glBegin(GL_LINES);
-      glNormal3f(float(npoint.x()), float(npoint.y()), float(npoint.z()));
-      glVertex3f(float(npoint.x() - direction.x() * _lineLength->value() / 2),
-                 float(npoint.y() - direction.y() * _lineLength->value() / 2),
-                 float(npoint.z() - direction.z() * _lineLength->value() / 2));
-      glVertex3f(float(npoint.x() + direction.x() * _lineLength->value() / 2),
-                 float(npoint.y() + direction.y() * _lineLength->value() / 2),
-                 float(npoint.z() + direction.z() * _lineLength->value() / 2));
-      glEnd();
-    }
-    glPopMatrix();
-
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d_addons/vertex_line3d.h b/g2o/types/slam3d_addons/vertex_line3d.h
deleted file mode 100644
index a1efc67d..00000000
--- a/g2o/types/slam3d_addons/vertex_line3d.h
+++ /dev/null
@@ -1,87 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_LINE3D_H_
-#define G2O_VERTEX_LINE3D_H_
-
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-
-#include "g2o_types_slam3d_addons_api.h"
-#include "line3d.h"
-
-namespace g2o {
-
-  class G2O_TYPES_SLAM3D_ADDONS_API VertexLine3D : public BaseVertex<4, Line3D> {
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-
-    VertexLine3D();
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-
-    virtual void setToOriginImpl() { _estimate = Line3D(); }
-
-    virtual void oplusImpl(const number_t* update_) {
-      Eigen::Map<const Vector4> update(update_);
-      _estimate.oplus(update);
-    }
-
-    virtual bool setEstimateDataImpl(const number_t* est) {
-      Eigen::Map<const Vector6> _est(est);
-      _estimate = Line3D(_est);
-      return true;
-    }
-
-    virtual bool getEstimateData(number_t* est) const {
-      Eigen::Map<Vector6> _est(est);
-      _est = _estimate;
-      return true;
-    }
-
-    virtual int estimateDimension() const {
-      return 6;
-    }
-
-    Vector3 color;
-  };
-
-#ifdef G2O_HAVE_OPENGL
-  class VertexLine3DDrawAction : public DrawAction {
-  public:
-    VertexLine3DDrawAction();
-    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
-						HyperGraphElementAction::Parameters* params_);
-  protected:
-    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-    FloatProperty* _lineLength, *_lineWidth;
-
-  };
-#endif
-
-}
-#endif
diff --git a/g2o/types/slam3d_addons/vertex_plane.cpp b/g2o/types/slam3d_addons/vertex_plane.cpp
deleted file mode 100644
index 7a62e0ce..00000000
--- a/g2o/types/slam3d_addons/vertex_plane.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_plane.h"
-
-#include "g2o/stuff/opengl_wrapper.h"
-
-namespace g2o
-{
-
-  VertexPlane::VertexPlane(){
-    color << cst(.2), cst(.2), cst(.2);
-  }
-
-  bool VertexPlane::read(std::istream& is) {
-    Vector4 lv;
-    bool state = internal::readVector(is, lv);
-    setEstimate(Plane3D(lv));
-    state &= internal::readVector(is, color);
-    return state;
-  }
-
-  bool VertexPlane::write(std::ostream& os) const {
-    bool state = internal::writeVector(os, _estimate.toVector());
-    state &= internal::writeVector(os, color);
-    return state;
-  }
-
-#ifdef G2O_HAVE_OPENGL
-
-  VertexPlaneDrawAction::VertexPlaneDrawAction()
-      : DrawAction(typeid(VertexPlane).name()), _planeWidth(nullptr), _planeHeight(nullptr) {}
-
-  bool VertexPlaneDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_)
-  {
-    if (!DrawAction::refreshPropertyPtrs(params_))
-      return false;
-    if (_previousParams){
-      _planeWidth = _previousParams->makeProperty<FloatProperty>(_typeName + "::PLANE_WIDTH", 3);
-      _planeHeight = _previousParams->makeProperty<FloatProperty>(_typeName + "::PLANE_HEIGHT", 3);
-    } else {
-      _planeWidth = 0;
-      _planeHeight = 0;
-    }
-    return true;
-  }
-
-  HyperGraphElementAction* VertexPlaneDrawAction::operator()(HyperGraph::HyperGraphElement* element,
-                 HyperGraphElementAction::Parameters* params_)
-  {
-    if (typeid(*element).name() != _typeName) return nullptr;
-    refreshPropertyPtrs(params_);
-    if (!_previousParams) return this;
-    if (_show && !_show->value()) return this;
-
-    if (_planeWidth && _planeHeight) {
-      VertexPlane* that = static_cast<VertexPlane*>(element);
-      number_t d = that->estimate().distance();
-      number_t azimuth = Plane3D::azimuth(that->estimate().normal());
-      number_t elevation = Plane3D::elevation(that->estimate().normal());
-      glColor3f(float(that->color(0)), float(that->color(1)), float(that->color(2)));
-      glPushMatrix();
-      glRotatef(float(RAD2DEG(azimuth)), 0.f, 0.f, 1.f);
-      glRotatef(float(RAD2DEG(elevation)), 0.f, -1.f, 0.f);
-      glTranslatef(float(d), 0.f, 0.f);
-
-      glBegin(GL_QUADS);
-      glNormal3f(-1.f, 0.f, 0.f);
-      glVertex3f(0.f, -_planeWidth->value(), -_planeHeight->value());
-      glVertex3f(0.f, _planeWidth->value(), -_planeHeight->value());
-      glVertex3f(0.f, _planeWidth->value(), _planeHeight->value());
-      glVertex3f(0.f, -_planeWidth->value(), _planeHeight->value());
-      glEnd();
-      glPopMatrix();
-    }
-
-    return this;
-  }
-#endif
-
-}
diff --git a/g2o/types/slam3d_addons/vertex_plane.h b/g2o/types/slam3d_addons/vertex_plane.h
deleted file mode 100644
index 0ef1cc33..00000000
--- a/g2o/types/slam3d_addons/vertex_plane.h
+++ /dev/null
@@ -1,88 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_PLANE_H_
-#define G2O_VERTEX_PLANE_H_
-
-#include "g2o_types_slam3d_addons_api.h"
-#include "g2o/config.h"
-#include "g2o/core/base_vertex.h"
-#include "g2o/core/hyper_graph_action.h"
-#include "plane3d.h"
-
-namespace g2o
-{
-
-  class G2O_TYPES_SLAM3D_ADDONS_API VertexPlane : public BaseVertex<3, Plane3D>
-    {
-    public:
-      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-      VertexPlane();
-
-      virtual bool read(std::istream& is);
-      virtual bool write(std::ostream& os) const;
-
-      virtual void setToOriginImpl() { _estimate = Plane3D(); }
-
-      virtual void oplusImpl(const number_t* update_) {
-        Eigen::Map<const Vector3> update(update_);
-        _estimate.oplus(update);
-      }
-
-      virtual bool setEstimateDataImpl(const number_t* est) {
-        Eigen::Map<const Vector4> _est(est);
-        _estimate.fromVector(_est);
-        return true;
-      }
-
-      virtual bool getEstimateData(number_t* est) const {
-        Eigen::Map<Vector4> _est(est);
-        _est = _estimate.toVector();
-        return true;
-      }
-
-      virtual int estimateDimension() const {
-        return 4;
-      }
-
-      Vector3 color;
-    };
-
-#ifdef G2O_HAVE_OPENGL
-  class VertexPlaneDrawAction: public DrawAction
-  {
-    public:
-      VertexPlaneDrawAction();
-      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
-          HyperGraphElementAction::Parameters* params_ );
-    protected:
-      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
-      FloatProperty* _planeWidth, *_planeHeight;
-  };
-#endif
-
-}
-#endif
diff --git a/g2o/types/slam3d_addons/vertex_se3_euler.cpp b/g2o/types/slam3d_addons/vertex_se3_euler.cpp
deleted file mode 100644
index fc5af706..00000000
--- a/g2o/types/slam3d_addons/vertex_se3_euler.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "vertex_se3_euler.h"
-
-#include "g2o/types/slam3d/isometry3d_mappings.h"
-
-namespace g2o {
-
-bool VertexSE3Euler::read(std::istream& is) {
-  Vector6 est;
-  bool state = internal::readVector(is, est);
-  setEstimate(internal::fromVectorET(est));
-  return state;
-}
-
-bool VertexSE3Euler::write(std::ostream& os) const {
-  return internal::writeVector(os, internal::toVectorET(estimate()));
-}
-
-}  // namespace g2o
diff --git a/g2o/types/slam3d_addons/vertex_se3_euler.h b/g2o/types/slam3d_addons/vertex_se3_euler.h
deleted file mode 100644
index 68e69255..00000000
--- a/g2o/types/slam3d_addons/vertex_se3_euler.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// g2o - General Graph Optimization
-// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-// * Redistributions of source code must retain the above copyright notice,
-//   this list of conditions and the following disclaimer.
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef G2O_VERTEX_SE3_EULER_
-#define G2O_VERTEX_SE3_EULER_
-
-#include "g2o_types_slam3d_addons_api.h"
-#include "g2o/types/slam3d/vertex_se3.h"
-
-namespace g2o {
-
-/**
- * \brief 3D pose Vertex, (x,y,z,roll,pitch,yaw)
- * the internal parameterization is the same as veretx_se3_quat. 
- * Only the read/write operations are rewritten to input/output euler angles.
- */
-class G2O_TYPES_SLAM3D_ADDONS_API VertexSE3Euler : public VertexSE3
-{
-  public:
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    virtual bool read(std::istream& is);
-    virtual bool write(std::ostream& os) const;
-};
-
-} // end namespace
-
-#endif
